CCS PCH C Compiler, Version 4.033, 15176               04-Sep-07 00:13

               Filename: C:\Users\Projects\PIC\GPS\Firmware\PIC18F67j50\App\GPS_67J50.lst

               ROM used: 9306 bytes (7%)
                         Largest free fragment is 65528
               RAM used: 2552 (66%) at main() level
                         2599 (68%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
00000:  GOTO   214E
*
00008:  GOTO   00E6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  05
0001A:  MOVFF  FD8,06
0001E:  MOVFF  FE0,07
00022:  MOVLB  0
00024:  MOVFF  FE9,0D
00028:  MOVFF  FEA,08
0002C:  MOVFF  FE1,09
00030:  MOVFF  FE2,0A
00034:  MOVFF  FD9,0B
00038:  MOVFF  FDA,0C
0003C:  MOVFF  FF3,14
00040:  MOVFF  FF4,15
00044:  MOVFF  FFA,16
00048:  MOVFF  FFB,17
0004C:  MOVFF  00,0F
00050:  MOVFF  01,10
00054:  MOVFF  02,11
00058:  MOVFF  03,12
0005C:  MOVFF  04,13
00060:  BTFSS  FF2.5
00062:  GOTO   006C
00066:  BTFSC  FF2.2
00068:  GOTO   10CA
0006C:  BTFSS  FF0.3
0006E:  GOTO   0078
00072:  BTFSC  FF0.0
00074:  GOTO   0FE2
00078:  BTFSS  FF0.4
0007A:  GOTO   0084
0007E:  BTFSC  FF0.1
00080:  GOTO   1002
00084:  BTFSS  FF2.3
00086:  GOTO   0090
0008A:  BTFSC  FF2.0
0008C:  GOTO   1042
00090:  BTFSS  FA3.5
00092:  GOTO   009C
00096:  BTFSC  FA4.5
00098:  GOTO   1070
0009C:  MOVFF  0F,00
000A0:  MOVFF  10,01
000A4:  MOVFF  11,02
000A8:  MOVFF  12,03
000AC:  MOVFF  13,04
000B0:  BSF    0E.7
000B2:  MOVFF  0D,FE9
000B6:  MOVFF  08,FEA
000BA:  MOVFF  09,FE1
000BE:  MOVFF  0A,FE2
000C2:  MOVFF  0B,FD9
000C6:  MOVFF  0C,FDA
000CA:  MOVFF  14,FF3
000CE:  MOVFF  15,FF4
000D2:  MOVFF  16,FFA
000D6:  MOVFF  17,FFB
000DA:  MOVF   05,W
000DC:  MOVFF  07,FE0
000E0:  MOVFF  06,FD8
000E4:  RETFIE 0
000E6:  MOVLB  0
000E8:  MOVFF  FE9,1F
000EC:  MOVFF  FEA,1A
000F0:  MOVFF  FE1,1B
000F4:  MOVFF  FE2,1C
000F8:  MOVFF  FD9,1D
000FC:  MOVFF  FDA,1E
00100:  MOVFF  FF3,26
00104:  MOVFF  FF4,27
00108:  MOVFF  FFA,28
0010C:  MOVFF  FFB,29
00110:  MOVFF  00,21
00114:  MOVFF  01,22
00118:  MOVFF  02,23
0011C:  MOVFF  03,24
00120:  MOVFF  04,25
00124:  BTFSS  FF2.4
00126:  GOTO   0130
0012A:  BTFSC  FF2.1
0012C:  GOTO   0FC2
00130:  BTFSS  FF0.5
00132:  GOTO   013C
00136:  BTFSC  FF0.2
00138:  GOTO   1022
0013C:  BTFSS  F9D.5
0013E:  GOTO   0148
00142:  BTFSC  F9E.5
00144:  GOTO   079E
00148:  MOVFF  21,00
0014C:  MOVFF  22,01
00150:  MOVFF  23,02
00154:  MOVFF  24,03
00158:  MOVFF  25,04
0015C:  BSF    20.7
0015E:  MOVFF  1F,FE9
00162:  MOVFF  1A,FEA
00166:  MOVFF  1B,FE1
0016A:  MOVFF  1C,FE2
0016E:  MOVFF  1D,FD9
00172:  MOVFF  1E,FDA
00176:  MOVFF  26,FF3
0017A:  MOVFF  27,FF4
0017E:  MOVFF  28,FFA
00182:  MOVFF  29,FFB
00186:  RETFIE 1
.................... #include "GPS_67J50.h" 
.................... #include <18F67J50.h> 
.................... //////// Standard Header file for the PIC18F67J50 device //////////////// 
.................... #device PIC18F67J50 
.................... #list 
....................  
.................... #device adc=10 
.................... #DEVICE HIGH_INTS=TRUE 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PLL_DIV1                   //4MHz input 
.................... #FUSES CPUDIV1                    //No CPU system clock divide 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOEXTCPU               //Disable extended CPU 
.................... #FUSES HSPLLUSBHSPLL 
....................  
.................... #byte INTCON2=0xFF1 
.................... #byte RCSTA1=0xFAC 
.................... #byte RCSTA2=0xF9C 
....................  
.................... #bit RBPU=INTCON2.7 
.................... #bit SPEN1=RCSTA1.7 
.................... #bit SPEN2=RCSTA2.7 
....................  
.................... #use delay(clock=48000000) 
*
01108:  MOVLW  09
0110A:  MOVWF  FEA
0110C:  MOVLW  F5
0110E:  MOVWF  FE9
01110:  MOVF   FEF,W
01112:  BZ    1130
01114:  MOVLW  0F
01116:  MOVWF  01
01118:  CLRF   00
0111A:  DECFSZ 00,F
0111C:  BRA    111A
0111E:  DECFSZ 01,F
01120:  BRA    1118
01122:  MOVLW  8F
01124:  MOVWF  00
01126:  DECFSZ 00,F
01128:  BRA    1126
0112A:  NOP   
0112C:  DECFSZ FEF,F
0112E:  BRA    1114
01130:  RETLW  00
.................... #use rs232(baud=38400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, ERRORS, stream=GPS) 
*
00734:  BTFSS  F9E.5
00736:  BRA    0734
00738:  MOVFF  FAC,2B
0073C:  MOVFF  FAF,01
00740:  BTFSS  2B.1
00742:  BRA    0748
00744:  BCF    FAC.4
00746:  BSF    FAC.4
00748:  GOTO   07A0 (RETURN)
.................... #use rs232(baud=115200,parity=N,xmit=PIN_G1,rcv=PIN_G2,bits=8, stream=BT_232) 
.................... //#use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F4,bits=8, stream=DEBUG, FORCE_SW ) 
....................  
.................... //#use rs232(baud=38400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... //#use rs232(baud=38400,parity=N,xmit=PIN_G1,rcv=PIN_G2,bits=8, stream=debug) 
.................... //#use i2c(master, sda=PIN_D6, scl=PIN_D5) 
....................  
.................... #use i2c(Master,FAST,sda=PIN_D5,scl=PIN_D6) 
*
012F6:  MOVLW  08
012F8:  MOVWF  01
012FA:  MOVLW  02
012FC:  MOVWF  00
012FE:  DECFSZ 00,F
01300:  BRA    12FE
01302:  BCF    F8C.6
01304:  BCF    F95.6
01306:  MOVLW  02
01308:  MOVWF  00
0130A:  DECFSZ 00,F
0130C:  BRA    130A
0130E:  MOVLB  9
01310:  RLCF   xF6,F
01312:  BCF    F8C.5
01314:  BTFSC  FD8.0
01316:  BSF    F95.5
01318:  BTFSS  FD8.0
0131A:  BCF    F95.5
0131C:  BSF    F95.6
0131E:  BTFSS  F83.6
01320:  BRA    131E
01322:  DECFSZ 01,F
01324:  BRA    1328
01326:  BRA    132C
01328:  MOVLB  0
0132A:  BRA    12FA
0132C:  MOVLW  02
0132E:  MOVWF  00
01330:  DECFSZ 00,F
01332:  BRA    1330
01334:  BCF    F8C.6
01336:  BCF    F95.6
01338:  NOP   
0133A:  BSF    F95.5
0133C:  MOVLW  02
0133E:  MOVWF  00
01340:  DECFSZ 00,F
01342:  BRA    1340
01344:  MOVLW  02
01346:  MOVWF  00
01348:  DECFSZ 00,F
0134A:  BRA    1348
0134C:  BSF    F95.6
0134E:  BTFSS  F83.6
01350:  BRA    134E
01352:  CLRF   01
01354:  MOVLW  02
01356:  MOVWF  00
01358:  DECFSZ 00,F
0135A:  BRA    1358
0135C:  BTFSC  F83.5
0135E:  BSF    01.0
01360:  BCF    F8C.6
01362:  BCF    F95.6
01364:  BCF    F8C.5
01366:  BCF    F95.5
01368:  MOVLB  0
0136A:  RETLW  00
....................  
.................... //#define _DEBUG 
.................... #ifdef _DEBUG 
.................... #define TRACE0(format)   fprintf(debug, format) 
.................... #define TRACE1(format, arg1)   fprintf(debug, format, arg1) 
.................... #define TRACE2(format, arg1, arg2)   fprintf(debug, format, arg1, arg2) 
.................... #define TRACE3(format, arg1, arg2, arg3)   fprintf(debug, format, arg1, arg2, arg3) 
.................... #define TRACE4(format, arg1, arg2, arg3, arg4)   fprintf(debug, format, arg1, arg2, arg3, arg4) 
.................... #else  
.................... #define TRACE0(format)    
.................... #define TRACE1(format, arg1) 
.................... #define TRACE2(format, arg1, arg2) 
.................... #define TRACE3(format, arg1, arg2, arg3) 
.................... #define TRACE4(format, arg1, arg2, arg3, arg4) 
.................... #endif 
....................  
.................... #include "math.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *((int8 *)(&res)) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................  
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................      *((int8 *)(&y)) = 0x7E;  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *((int8 *)(&x)) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
....................    float y, t, t2 = 1.0; 
....................    int quad, i; 
....................    float frac; 
....................    float p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #include "HaltiLCD.c" 
....................  
.................... //#use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3) 
.................... #use fast_io(d) 
.................... //#use fast_io(e) 
....................  
.................... #define LCD_WRX      PIN_D0 
.................... #define LCD_DC      PIN_D1 
.................... #define LCD_CSX      PIN_D2 
.................... #define LCD_RESX   PIN_D3 
.................... //#define LCD_VDDI   PIN_A2 
.................... //#define LCD_RDX      PIN_A5 
.................... //#define LCD_VDD      PIN_C0 
.................... #define LCD_DATAOUT(data)      output_e(data) 
....................  
.................... #define LCDCMD_NOP   0x00 
.................... #define LCDCMD_SWRESET   0x01 
.................... #define LCDCMD_SLPIN   0x10   //Sleep in 
.................... #define LCDCMD_SLPOUT   0x11   //Sleep out 
.................... #define LCDCMD_PTLON   0x12   //Partial Mode On 
.................... #define LCDCMD_NORON   0x13   //Normal Mode On 
.................... #define LCDCMD_DSPOFF   0x28   //Display Off 
.................... #define LCDCMD_DSPON   0x29   //Display On 
.................... #define LCDCMD_CASET   0x2A   //Column address set 
.................... #define LCDCMD_PASET   0x2B   //Page address set 
.................... #define LCDCMD_RAMWR   0x2C   //Memory Write 
.................... #define LCDCMD_RGBSET   0x2D   //RGB table set 
.................... #define LCDCMD_IDMOFF   0x38   //Idle mode off 
.................... #define LCDCMD_IDMON   0x39   //Idle mode On 
.................... #define LCDCMD_COLMOD   0x3A   //Interface pixel format 
.................... #define LCDCMD_MADCTL    0x36 
....................  
....................  
.................... #define MADCTL_HORIZ      0xA8 
.................... #define MADCTL_VERT       0x68 
....................  
.................... #define LCD_WIDTH      208 
.................... #define LCD_HEIGHT      176 
....................  
.................... int lcd_x; 
.................... int lcd_y; 
.................... int16 bkgColor; 
.................... int16 textColor; 
....................  
.................... void LCD_WriteData(byte data) 
.................... { 
....................    output_high(LCD_DC); 
*
01144:  BSF    F8C.1
....................    output_high(LCD_WRX); 
01146:  BSF    F8C.0
....................    LCD_DATAOUT(data); 
01148:  CLRF   F96
0114A:  MOVFF  A13,F8D
....................    output_low(LCD_WRX); 
0114E:  BCF    F8C.0
....................    delay_cycles(1); 
01150:  NOP   
....................    output_high(LCD_WRX); 
01152:  BSF    F8C.0
.................... } 
01154:  RETLW  00
....................  
.................... #define FAST_WRITE(data)   LCD_DATAOUT(data);output_low(LCD_WRX);output_high(LCD_WRX); 
....................  
.................... void LCD_WriteCommand(byte command) 
.................... { 
....................    output_low(LCD_DC); 
*
01132:  BCF    F8C.1
....................    output_high(LCD_WRX); 
01134:  BSF    F8C.0
....................    LCD_DATAOUT(command); 
01136:  CLRF   F96
01138:  MOVFF  A13,F8D
....................    output_low(LCD_WRX); 
0113C:  BCF    F8C.0
....................    delay_cycles(1); 
0113E:  NOP   
....................    output_high(LCD_WRX); 
01140:  BSF    F8C.0
.................... } 
01142:  RETLW  00
....................  
.................... void LCD_SetWindow(int left, int top, int right, int bottom) 
.................... { 
....................    LCD_WriteCommand(LCDCMD_CASET); 
*
01258:  MOVLW  2A
0125A:  MOVLB  A
0125C:  MOVWF  x13
0125E:  MOVLB  0
01260:  RCALL  1132
....................    LCD_WriteData(0); 
01262:  MOVLB  A
01264:  CLRF   x13
01266:  MOVLB  0
01268:  RCALL  1144
....................    LCD_WriteData(left); 
0126A:  MOVFF  A0F,A13
0126E:  RCALL  1144
....................    LCD_WriteData(0); 
01270:  MOVLB  A
01272:  CLRF   x13
01274:  MOVLB  0
01276:  RCALL  1144
....................    LCD_WriteData(right); 
01278:  MOVFF  A11,A13
0127C:  RCALL  1144
....................    LCD_WriteCommand(LCDCMD_PASET); 
0127E:  MOVLW  2B
01280:  MOVLB  A
01282:  MOVWF  x13
01284:  MOVLB  0
01286:  RCALL  1132
....................    LCD_WriteData(0); 
01288:  MOVLB  A
0128A:  CLRF   x13
0128C:  MOVLB  0
0128E:  RCALL  1144
....................    LCD_WriteData(top); 
01290:  MOVFF  A10,A13
01294:  RCALL  1144
....................    LCD_WriteData(0); 
01296:  MOVLB  A
01298:  CLRF   x13
0129A:  MOVLB  0
0129C:  RCALL  1144
....................    LCD_WriteData(bottom); 
0129E:  MOVFF  A12,A13
012A2:  RCALL  1144
.................... } 
012A4:  RETLW  00
....................  
.................... //Sleep in : 0.8mA 
.................... void LCD_SleepIn() 
.................... { 
....................    LCD_WriteCommand(LCDCMD_SLPIN); 
.................... } 
....................  
.................... void LCD_SleepOut() 
.................... { 
....................    LCD_WriteCommand(LCDCMD_SLPOUT); 
.................... } 
....................  
.................... //Idle mode: 1.5mA 
.................... void LCD_IdleMode() 
.................... { 
....................    LCD_WriteCommand(LCDCMD_NORON); 
....................    LCD_WriteCommand(LCDCMD_IDMON); 
.................... } 
....................  
.................... //Normal mode: 4mA 
.................... void LCD_NormalMode() 
.................... { 
....................    LCD_WriteCommand(LCDCMD_NORON); 
....................    LCD_WriteCommand(LCDCMD_IDMOFF); 
.................... } 
....................  
.................... void LCD_PartialMode() 
.................... { 
....................    LCD_WriteCommand(LCDCMD_PTLON); 
....................    LCD_WriteCommand(LCDCMD_IDMON); 
.................... } 
....................  
.................... void LCD_DisplayOff() 
.................... { 
....................    output_low(LCD_CSX); 
....................   LCD_WriteCommand(LCDCMD_SLPIN); 
....................   LCD_WriteCommand(LCDCMD_DSPOFF); 
....................    output_high(LCD_CSX); 
.................... } 
....................  
.................... void LCD_Shutdown() 
.................... { 
....................    	LCD_DisplayOff(); 
....................     
....................    	delay_ms(50); 
....................    output_high(LCD_RESX);	 
.................... } 
....................  
.................... void LCD_Init() 
.................... { 
....................    int i=0; 
*
01156:  MOVLB  9
01158:  CLRF   xF4
....................     
....................    lcd_x = 0; 
0115A:  CLRF   2C
....................    lcd_y = 0; 
0115C:  CLRF   2D
....................    textColor = 0x0; 
0115E:  CLRF   31
01160:  CLRF   30
....................    bkgColor = 0xFFFF; 
01162:  MOVLW  FF
01164:  MOVWF  2F
01166:  MOVWF  2E
....................     
....................    set_tris_d(0b01110000); 
01168:  MOVLW  70
0116A:  MOVWF  F95
....................     
....................    output_Low(LCD_CSX); 
0116C:  BCF    F8C.2
....................    output_low(LCD_RESX); 
0116E:  BCF    F8C.3
....................    //output_high(LCD_VDDI); 
....................    //output_high(LCD_VDD); 
....................  
....................    delay_ms(1); 
01170:  MOVLW  01
01172:  MOVWF  xF5
01174:  MOVLB  0
01176:  RCALL  1108
....................  
....................    output_low(LCD_RESX); 
01178:  BCF    F8C.3
....................    output_high(LCD_RESX); 
0117A:  BSF    F8C.3
....................  
.................... //   output_high(LCD_RDX); 
....................    output_high(LCD_WRX); 
0117C:  BSF    F8C.0
....................    output_high(LCD_DC); 
0117E:  BSF    F8C.1
....................  
....................    //Enable LCD 
....................    output_low(LCD_CSX); 
01180:  BCF    F8C.2
....................  
....................    delay_ms(10); 
01182:  MOVLW  0A
01184:  MOVLB  9
01186:  MOVWF  xF5
01188:  MOVLB  0
0118A:  RCALL  1108
....................  
....................    LCD_WriteCommand(LCDCMD_NOP); 
0118C:  MOVLB  A
0118E:  CLRF   x13
01190:  MOVLB  0
01192:  RCALL  1132
....................    LCD_WriteCommand(LCDCMD_SWRESET);   //Reset LCD 
01194:  MOVLW  01
01196:  MOVLB  A
01198:  MOVWF  x13
0119A:  MOVLB  0
0119C:  RCALL  1132
....................    delay_ms(120); 
0119E:  MOVLW  78
011A0:  MOVLB  9
011A2:  MOVWF  xF5
011A4:  MOVLB  0
011A6:  RCALL  1108
....................    LCD_WriteCommand(LCDCMD_SLPOUT);   //Sleep out 
011A8:  MOVLW  11
011AA:  MOVLB  A
011AC:  MOVWF  x13
011AE:  MOVLB  0
011B0:  RCALL  1132
....................    LCD_WriteCommand(LCDCMD_DSPON);      //Display on 
011B2:  MOVLW  29
011B4:  MOVLB  A
011B6:  MOVWF  x13
011B8:  MOVLB  0
011BA:  RCALL  1132
....................    LCD_WriteCommand(LCDCMD_NORON);      //Normal mode 
011BC:  MOVLW  13
011BE:  MOVLB  A
011C0:  MOVWF  x13
011C2:  MOVLB  0
011C4:  RCALL  1132
....................    LCD_WriteCommand(LCDCMD_IDMOFF);   //Idle mode off 
011C6:  MOVLW  38
011C8:  MOVLB  A
011CA:  MOVWF  x13
011CC:  MOVLB  0
011CE:  RCALL  1132
....................    //LCD_WriteCommand(LCDCMD_IDMON); 
....................    LCD_WriteCommand(LCDCMD_COLMOD);   //Bits per Pixel 
011D0:  MOVLW  3A
011D2:  MOVLB  A
011D4:  MOVWF  x13
011D6:  MOVLB  0
011D8:  RCALL  1132
....................    //LCD_WriteData(0x02);   //8bit    
....................    LCD_WriteData(0x05);   //16bit 
011DA:  MOVLW  05
011DC:  MOVLB  A
011DE:  MOVWF  x13
011E0:  MOVLB  0
011E2:  RCALL  1144
....................     
....................    LCD_WriteCommand(LCDCMD_MADCTL);   //Memory data acces control 
011E4:  MOVLW  36
011E6:  MOVLB  A
011E8:  MOVWF  x13
011EA:  MOVLB  0
011EC:  RCALL  1132
....................    LCD_WriteData(MADCTL_HORIZ);    //X Mirror and BGR format 
011EE:  MOVLW  A8
011F0:  MOVLB  A
011F2:  MOVWF  x13
011F4:  MOVLB  0
011F6:  RCALL  1144
....................     //    lcdWrdata(0x98); 
....................  
....................    LCD_WriteCommand(LCDCMD_RGBSET);   //Set RGB color lookup table 
011F8:  MOVLW  2D
011FA:  MOVLB  A
011FC:  MOVWF  x13
011FE:  MOVLB  0
01200:  RCALL  1132
....................    for(i=0; i<32; i++)   //RED 
01202:  MOVLB  9
01204:  CLRF   xF4
01206:  MOVF   xF4,W
01208:  SUBLW  1F
0120A:  BNC   1220
....................       LCD_WriteData(i*2); 
0120C:  BCF    FD8.0
0120E:  RLCF   xF4,W
01210:  MOVWF  xF5
01212:  MOVFF  FE8,A13
01216:  MOVLB  0
01218:  RCALL  1144
0121A:  MOVLB  9
0121C:  INCF   xF4,F
0121E:  BRA    1206
....................    for(i=0; i<64; i++)   ///GREEN 
01220:  CLRF   xF4
01222:  MOVF   xF4,W
01224:  SUBLW  3F
01226:  BNC   1236
....................       LCD_WriteData(i); 
01228:  MOVFF  9F4,A13
0122C:  MOVLB  0
0122E:  RCALL  1144
01230:  MOVLB  9
01232:  INCF   xF4,F
01234:  BRA    1222
....................    for(i=0; i<32; i++)   //BLUE 
01236:  CLRF   xF4
01238:  MOVF   xF4,W
0123A:  SUBLW  1F
0123C:  BNC   1252
....................       LCD_WriteData(i*2); 
0123E:  BCF    FD8.0
01240:  RLCF   xF4,W
01242:  MOVWF  xF5
01244:  MOVFF  FE8,A13
01248:  MOVLB  0
0124A:  RCALL  1144
0124C:  MOVLB  9
0124E:  INCF   xF4,F
01250:  BRA    1238
.................... } 
01252:  MOVLB  0
01254:  GOTO   23A6 (RETURN)
....................  
.................... //Text drawing functions 
.................... #include "ascii.h" 
.................... const char charMap8x14[] = { 
.................... /* 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7e, 0x81, 0xa5, 0x81, 0x81, 0xbd, 0x99, 0x81, 0x7e, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7e, 0xff, 0xdb, 0xff, 0xff, 0xc3, 0xe7, 0xff, 0x7e, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 
.................... 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff, 0xff, 0xff, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00, 0x00, 0x00, 
.................... 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff, 0xff, 0xff, 
.................... 0x00, 0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3f, 0x33, 0x3f, 0x30, 0x30, 0x30, 0x70, 0xf0, 0xe0, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7f, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x67, 0xe7, 0xe6, 0xc0, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x18, 0xdb, 0x3c, 0xe7, 0x3c, 0xdb, 0x18, 0x18, 0x00, 0x00, 
.................... */ 
.................... 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0xc0, 0x80, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x02, 0x06, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x06, 0x02, 0x00, 0x00, 
.................... /* 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7f, 0xdb, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 
.................... 0x00, 0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6, 0x7c, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x7e, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6c, 0xfe, 0x6c, 0x28, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 
.................... */ 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//32 - Space 
.................... 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 
.................... 0x00, 0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x86, 0xc6, 0x7c, 0x18, 0x18, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x66, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 
.................... 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xd6, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x0c, 0x78, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0x66, 0x3a, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0e, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x7c, 0x38, 0x7c, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x8c, 0x18, 0x30, 0x60, 0xc2, 0xc6, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00, 
.................... 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
.................... 0x00, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x1c, 0x36, 0x32, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78, 
.................... 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c, 
.................... 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0xf0, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x66, 0xfe, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 
.................... 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00 
.................... }; 
....................  
....................  
....................  
.................... void LCD_Gotoxy(int x, int y) 
.................... { 
....................    lcd_x = x; 
*
01818:  MOVFF  A02,2C
....................    lcd_y = y; 
0181C:  MOVFF  A03,2D
.................... } 
01820:  RETLW  00
.................... void LCD_NewLine() 
.................... { 
....................   lcd_x  = 0; 
*
0184E:  CLRF   2C
....................   lcd_y   += 14; 
01850:  MOVLW  0E
01852:  ADDWF  2D,F
....................   if(lcd_y > LCD_HEIGHT) 
01854:  MOVF   2D,W
01856:  SUBLW  B0
01858:  BC    185E
....................      lcd_y -= 14; 
0185A:  MOVLW  0E
0185C:  SUBWF  2D,F
....................   } 
0185E:  GOTO   197E (RETURN)
....................  
.................... void LCD_SetTextColor(int16 nColor) 
.................... { 
....................    textColor = nColor; 
.................... } 
....................  
.................... void LCD_SetBackgroundColor(int16 nColor) 
.................... { 
....................    bkgColor = nColor; 
.................... } 
....................  
.................... void gps_FloodFill(int left, int top, int right, int bottom, int16 color) 
.................... { 
....................    int16 i, numPixel; 
....................   //select controller 
....................   output_low(LCD_CSX); 
*
01CDE:  BCF    F8C.2
....................    
....................    LCD_SetWindow(left,top, right, bottom); 
01CE0:  MOVFF  A05,A0F
01CE4:  MOVFF  A06,A10
01CE8:  MOVFF  A07,A11
01CEC:  MOVFF  A08,A12
01CF0:  CALL   1258
....................    LCD_WriteCommand(LCDCMD_RAMWR); 
01CF4:  MOVLW  2C
01CF6:  MOVLB  A
01CF8:  MOVWF  x13
01CFA:  MOVLB  0
01CFC:  CALL   1132
....................     
....................    output_high(LCD_DC); 
01D00:  BSF    F8C.1
....................    numPixel = ((int16)(right-left+1))*((int16)(bottom-top+1)); 
01D02:  MOVLB  A
01D04:  MOVF   x05,W
01D06:  SUBWF  x07,W
01D08:  ADDLW  01
01D0A:  CLRF   x11
01D0C:  MOVWF  x10
01D0E:  MOVF   x06,W
01D10:  SUBWF  x08,W
01D12:  ADDLW  01
01D14:  CLRF   03
01D16:  MOVWF  x13
01D18:  MOVFF  03,A14
01D1C:  CLRF   19
01D1E:  BTFSC  FF2.6
01D20:  BSF    19.6
01D22:  BCF    FF2.6
01D24:  BTFSC  FF2.7
01D26:  BSF    19.7
01D28:  BCF    FF2.7
01D2A:  MOVFF  A11,A22
01D2E:  MOVFF  A10,A21
01D32:  MOVFF  03,A24
01D36:  MOVWF  x23
01D38:  MOVLB  0
01D3A:  CALL   074C
01D3E:  BTFSC  19.6
01D40:  BSF    FF2.6
01D42:  BTFSC  19.7
01D44:  BSF    FF2.7
01D46:  MOVFF  02,A0E
01D4A:  MOVFF  01,A0D
....................    for(i=0; i<numPixel; i++) 
01D4E:  MOVLB  A
01D50:  CLRF   x0C
01D52:  CLRF   x0B
01D54:  MOVF   x0C,W
01D56:  SUBWF  x0E,W
01D58:  BNC   1D7E
01D5A:  BNZ   1D62
01D5C:  MOVF   x0D,W
01D5E:  SUBWF  x0B,W
01D60:  BC    1D7E
....................    { 
....................              FAST_WRITE(make8(color, 1)); 
01D62:  CLRF   F96
01D64:  MOVFF  A0A,F8D
01D68:  BCF    F8C.0
01D6A:  BSF    F8C.0
....................              FAST_WRITE(make8(color, 0)); 
01D6C:  CLRF   F96
01D6E:  MOVFF  A09,F8D
01D72:  BCF    F8C.0
01D74:  BSF    F8C.0
....................     }	 
01D76:  INCF   x0B,F
01D78:  BTFSC  FD8.2
01D7A:  INCF   x0C,F
01D7C:  BRA    1D54
....................   
....................   output_high(LCD_CSX); 
01D7E:  BSF    F8C.2
.................... } 
01D80:  MOVLB  0
01D82:  RETLW  00
....................  
.................... void LCD_ClearScreen() 
.................... { 
....................    int16 i; 
....................    //LCD_Floor(0,0, LCD_WIDTH-1, LCD_HEIGHT-1, bkgColor); 
....................    //return; 
....................   //select controller 
....................   output_low(LCD_CSX); 
*
012A6:  BCF    F8C.2
....................    
....................    LCD_SetWindow(0,0, LCD_WIDTH-1, LCD_HEIGHT-1); 
012A8:  MOVLB  A
012AA:  CLRF   x0F
012AC:  CLRF   x10
012AE:  MOVLW  CF
012B0:  MOVWF  x11
012B2:  MOVLW  AF
012B4:  MOVWF  x12
012B6:  MOVLB  0
012B8:  RCALL  1258
....................    LCD_WriteCommand(LCDCMD_RAMWR); 
012BA:  MOVLW  2C
012BC:  MOVLB  A
012BE:  MOVWF  x13
012C0:  MOVLB  0
012C2:  RCALL  1132
....................     
....................    output_high(LCD_DC); 
012C4:  BSF    F8C.1
....................    for(i=0; i<LCD_WIDTH*LCD_HEIGHT; i++) 
012C6:  MOVLB  9
012C8:  CLRF   xF5
012CA:  CLRF   xF4
012CC:  MOVF   xF5,W
012CE:  SUBLW  8E
012D0:  BNC   12EE
....................    { 
....................              FAST_WRITE(make8(bkgColor, 1)); 
012D2:  CLRF   F96
012D4:  MOVFF  2F,F8D
012D8:  BCF    F8C.0
012DA:  BSF    F8C.0
....................              FAST_WRITE(make8(bkgColor, 0)); 
012DC:  CLRF   F96
012DE:  MOVFF  2E,F8D
012E2:  BCF    F8C.0
012E4:  BSF    F8C.0
....................     } 
012E6:  INCF   xF4,F
012E8:  BTFSC  FD8.2
012EA:  INCF   xF5,F
012EC:  BRA    12CC
....................      
....................   output_high(LCD_CSX); 
012EE:  BSF    F8C.2
.................... } 
012F0:  MOVLB  0
012F2:  GOTO   23AA (RETURN)
....................  
.................... /***************************************************************************** 
....................  * 
....................  * Description: 
....................  *    Draw one character withc current foreground and background color 
....................  *    at current xy position on display. Update x-position (+8). 
....................  * 
....................  ****************************************************************************/ 
.................... void LCD_OutChar8(int data) 
.................... { 
....................    int i,j, byteToShift; 
....................    int16 mapOffset; 
....................     
....................   //select controller 
....................   output_low(LCD_CSX); 
*
01862:  BCF    F8C.2
....................  
....................   if (data <= 127) 
01864:  MOVLB  A
01866:  MOVF   x07,W
01868:  SUBLW  7F
0186A:  BTFSS  FD8.0
0186C:  BRA    1958
....................   { 
....................     data -= 30; 
0186E:  MOVLW  1E
01870:  SUBWF  x07,F
....................     mapOffset = data; 
01872:  CLRF   x0C
01874:  MOVFF  A07,A0B
01878:  CLRF   19
0187A:  BTFSC  FF2.6
0187C:  BSF    19.6
0187E:  BCF    FF2.6
01880:  BTFSC  FF2.7
01882:  BSF    19.7
01884:  BCF    FF2.7
....................     mapOffset *= 14; 
01886:  MOVFF  A0C,A22
0188A:  MOVFF  A0B,A21
0188E:  CLRF   x24
01890:  MOVLW  0E
01892:  MOVWF  x23
01894:  MOVLB  0
01896:  CALL   074C
0189A:  BTFSC  19.6
0189C:  BSF    FF2.6
0189E:  BTFSC  19.7
018A0:  BSF    FF2.7
018A2:  MOVFF  02,A0C
018A6:  MOVFF  01,A0B
....................  
....................    LCD_SetWindow(lcd_x, lcd_y, lcd_x+7, lcd_y+13); 
018AA:  MOVLW  07
018AC:  ADDWF  2C,W
018AE:  MOVLB  A
018B0:  MOVWF  x0D
018B2:  MOVLW  0D
018B4:  ADDWF  2D,W
018B6:  MOVWF  x0E
018B8:  MOVFF  2C,A0F
018BC:  MOVFF  2D,A10
018C0:  MOVFF  A0D,A11
018C4:  MOVWF  x12
018C6:  MOVLB  0
018C8:  RCALL  1258
....................     LCD_WriteCommand(LCDCMD_RAMWR); 
018CA:  MOVLW  2C
018CC:  MOVLB  A
018CE:  MOVWF  x13
018D0:  MOVLB  0
018D2:  RCALL  1132
....................    output_high(LCD_DC); 
018D4:  BSF    F8C.1
....................     
....................     for(i=0; i<14; i++) 
018D6:  MOVLB  A
018D8:  CLRF   x08
018DA:  MOVF   x08,W
018DC:  SUBLW  0D
018DE:  BNC   1958
....................     { 
....................       byteToShift = charMap8x14[mapOffset++]; 
018E0:  MOVFF  A0C,03
018E4:  MOVF   x0B,W
018E6:  INCF   x0B,F
018E8:  BTFSC  FD8.2
018EA:  INCF   x0C,F
018EC:  MOVWF  x0D
018EE:  MOVFF  03,A0E
018F2:  MOVFF  03,03
018F6:  MOVF   x0D,W
018F8:  MOVFF  FF2,A0F
018FC:  BCF    FF2.6
018FE:  BCF    FF2.7
01900:  MOVFF  03,FF7
01904:  MOVLB  0
01906:  CALL   0188
0190A:  MOVLB  A
0190C:  BTFSC  x0F.6
0190E:  BSF    FF2.6
01910:  BTFSC  x0F.7
01912:  BSF    FF2.7
01914:  MOVWF  x0A
....................       for(j=0; j<8; j++) 
01916:  CLRF   x09
01918:  MOVF   x09,W
0191A:  SUBLW  07
0191C:  BNC   1954
....................       { 
....................         if (byteToShift & 0x80) 
0191E:  BTFSS  x0A.7
01920:  BRA    1938
....................            { 
....................              //LCD_WriteData(textColor); 
....................              FAST_WRITE(make8(textColor, 1)); 
01922:  CLRF   F96
01924:  MOVFF  31,F8D
01928:  BCF    F8C.0
0192A:  BSF    F8C.0
....................              FAST_WRITE(make8(textColor, 0)); 
0192C:  CLRF   F96
0192E:  MOVFF  30,F8D
01932:  BCF    F8C.0
01934:  BSF    F8C.0
....................           } 
....................         else 
01936:  BRA    194C
....................            { 
....................              //LCD_WriteData(bkgColor); 
....................              FAST_WRITE(make8(bkgColor, 1)); 
01938:  CLRF   F96
0193A:  MOVFF  2F,F8D
0193E:  BCF    F8C.0
01940:  BSF    F8C.0
....................              FAST_WRITE(make8(bkgColor, 0)); 
01942:  CLRF   F96
01944:  MOVFF  2E,F8D
01948:  BCF    F8C.0
0194A:  BSF    F8C.0
....................            } 
....................         byteToShift <<= 1; 
0194C:  BCF    FD8.0
0194E:  RLCF   x0A,F
....................       } 
01950:  INCF   x09,F
01952:  BRA    1918
....................     } 
01954:  INCF   x08,F
01956:  BRA    18DA
....................   } 
....................  
....................   //deselect controller 
....................   output_high(LCD_CSX); 
01958:  BSF    F8C.2
....................  
....................   lcd_x += 8; 
0195A:  MOVLW  08
0195C:  ADDWF  2C,F
.................... } 
0195E:  MOVLB  0
01960:  GOTO   197E (RETURN)
....................  
.................... void LCD_PutChar(int data) 
.................... { 
....................   if (data == '\n') 
01964:  MOVLB  A
01966:  MOVF   x06,W
01968:  SUBLW  0A
0196A:  BNZ   1970
....................     LCD_NewLine(); 
0196C:  MOVLB  0
0196E:  BRA    184E
....................   else if (data != '\r') 
01970:  MOVF   x06,W
01972:  SUBLW  0D
01974:  BZ    1980
....................   { 
....................       LCD_OutChar8(data); 
01976:  MOVFF  A06,A07
0197A:  MOVLB  0
0197C:  BRA    1862
0197E:  MOVLB  A
....................    } 
....................  
.................... } 
01980:  MOVLB  0
01982:  RETLW  00
....................  
.................... #include "MyMMCFat32.h" 
.................... #define MAXFILES 1  
....................  
.................... //#define DIR_SHARE_IOBUFFER 
.................... #ifdef DIR_SHARE_IOBUFFER 
.................... #define DIR_BUFFER gFiles[hFile].IObuffer 
.................... #else 
.................... #define DIR_BUFFER gFiles[hFile].DIRbuffer 
.................... #endif 
....................  
.................... typedef struct _diskinforec  
.................... {  
.................... 	char   	JumpCode[3]; 	//0xEB??90 or 0xE9???? 
.................... 	char  	OEMName[8];  
.................... 	int16   BytsPerSec; 	//512, 1024 or 4096. Only 512 supported 
.................... 	char   	SecPerClus; 	//1~128 
.................... 	int16 	RsvdSecCnt; 	//Number of reserved sectors 
.................... 	char   	NumFATs; 	//Number of FAT data structure 
.................... 	int16 	RootEntCnt; 	//FAT12, FAT16: Number of root dir. FAT32: 0 
.................... 	int16 	TotSec16; 	//Total sectors. If 0 check TotalSectors32 
.................... 	char   	Media; 		//Media 
.................... 	int16 	FATSz16; 	//For FAT12/FAT16, Sectors per FAT. FAT32: 0 
.................... 	int16 	SecPerTrk; 	// 
.................... 	int16 	NumHeads; 	//Number of heads 
.................... 	int32   HiddSec; 	//Hidden sectors 
....................  
.................... 	int32   TotSec32; 	//If nSectors is 0, this is the total number of sectors 
....................  
.................... 	int32 	FATSz32;  
.................... 	int16 	ExtFlags;  
.................... 	int16 	FSVer;  
.................... 	int32 	RootClus;  
.................... } diskinforec;  
....................  
.................... typedef struct _direntry  
.................... {  
.................... 	char   sName[8];  
.................... 	char   sExt[3];  
.................... 	char   bAttr;  
.................... 	char   bReserved[8];  
.................... 	int16 	hClusterH;  
.................... 	int16   hTime;  
.................... 	int16   hDate;  
.................... 	int16   hCluster;  
.................... 	int32   wSize;  
.................... } DIR;  
....................  
.................... typedef struct  
.................... {  
.................... 	char	IObuffer[512]; 		//Data buffer 
.................... #ifndef DIR_SHARE_IOBUFFER 
.................... 	char 	DIRbuffer[512];		 
.................... #endif	 
.................... 	DIR	DirEntry; 		//DIR entry 
.................... 	int32	CurrentCluster; 	//Current data cluster# 
.................... 	int	SecInCluster;		//Current sector# in cluster (0~DiskInfo.SecPerClus-1) 
.................... 	int16	posinsector; 		//Byte index in current sector (0~511) 
.................... 	int32   wFileSize; 		//Byte index in whole file 
.................... 	int32	dirSector; 		//DIR entry sector# 
.................... 	int16	dirIdx; 		//DIR entry index in sector 
.................... 	char	mode; 			//'a' append, 'w' over write, 'r' read only 
.................... 	char	Free;  
.................... }FILE;  
....................  
.................... typedef struct  
.................... {  
.................... 	int32 MMCAddress;  
.................... 	int32 FATstartidx;  
.................... 	int32 gStartSector;  
.................... 	int32 gFirstDataSector;  
.................... 	int16 gDirEntryIdx;  
.................... 	int32 gDirEntrySector;  
.................... 	int16 gFirstEmptyDirEntry;  
.................... 	int32 gFirstDirEntryCluster;  
.................... 	int32 nRootDirSectors; 
.................... 	int32 nFatSize; 
.................... 	int   bFATModified; 
.................... } FAT32Vars;  
....................  
.................... #define HANDLE	char 
....................  
.................... int InitFAT();  
.................... char FindDirEntry(char *fname, HANDLE hFile);  
....................  
.................... char fopen(char *fname, char mode);  
.................... void fclose(HANDLE hFile);  
.................... void fflush(HANDLE hFile);  
.................... char cwd(char *fname, HANDLE hFile);  
.................... void fputch(char ch, HANDLE hFile);  
.................... void fputchar(char ch){fputch(ch, 0);} 
.................... char fgetch(char *ch, HANDLE hFile);  
.................... void fputstring(char *str, HANDLE hFile); // fputs is reserved in CCS C  
.................... int16 fread(char *buffer, int16 leng, HANDLE hFile);  
.................... void fwrite(char *buffer, int16 leng, HANDLE hFile);  
.................... char remove(char *fname);  
.................... char getfsize(char *fname, int32 *fsiz);  
....................  
.................... #include "MyMMCFat32.c" 
.................... #include <String.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... union 
.................... { 
....................    int32 FAT32[128]; 
....................    int16 FAT16[256]; 
.................... }FATTable; 
....................  
.................... typedef struct  { 
....................    unsigned long    tm_year; 
....................    char            tm_mon; 
....................    char            tm_day; 
....................    char            tm_mday; 
....................    char            tm_hour; 
....................    char            tm_min; 
....................    char            tm_sec; 
.................... } TimeRecord; 
.................... TimeRecord myrec; 
....................  
.................... int32 gFirstEmptyCluster; 
....................  
.................... FAT32Vars gFAT32Vars; 
.................... diskinforec DiskInfo; 
.................... FILE gFiles[MAXFILES]; 
.................... int gFATErrCode; 
....................  
.................... #byte MMCAddressL = gFAT32Vars 
.................... #byte MMCAddressH = gFAT32Vars+1 
.................... #byte MMCAddressHL = gFAT32Vars+2 
.................... #byte MMCAddressHH = gFAT32Vars+3 
.................... #byte gStartSectorL = gFAT32Vars+8 
.................... #byte gStartSectorH = gFAT32Vars+9 
.................... #byte gStartSectorHL = gFAT32Vars+10 
.................... /* 
.................... #locate FATTable.FAT32 = 0x0600 
.................... #locate gFiles = 0x0800 
.................... #locate gFAT32Vars = 0x0C70 
.................... #locate DiskInfo = 0x0C90 
.................... */ 
.................... enum{ 
....................    FAT_UNKNOWN = 0, 
....................    FAT12, 
....................    FAT16, 
....................    FAT32 
.................... }; 
....................  
.................... char sFATName[4][6]={"FAT?", "FAT12", "FAT16", "FAT32"}; 
.................... int gFATType; 
....................  
.................... #include "MMC.h" 
.................... #define MMC_NO_ERR	0 
.................... #define MMC_READ_GEN_ERR	0x10 
.................... #define MMC_READ_INVALID_ERR	0x11	//Invalid sector address 
.................... #define MMC_READ_TOKEN_ERR	0x12	 
.................... #define MMC_WRITE_GEN_ERR	0x20 
.................... #define MMC_WRITE_SEC0_ERR	0x21	//Attempt to write sector #0 
.................... #define MMC_WRITE_INVALID_ERR	0x22	//Invalid sector address 
.................... #define MMC_INIT_RESET_ERR	0x30 
.................... #define MMC_INIT_IDLE_ERR	0x31 
....................  
.................... char Init_MMC(int max_tries);  
.................... int ReadSector(int32 sector, char *buff);	//Read 512 bytes to buff 
.................... int WriteSector(int32 sector, char *buff);	//Write 512 bytes from buff 
....................  
.................... #include "MMC.c" 
....................  
.................... #use FAST_IO(C) 
.................... #define ChipSel pin_c2 
.................... #define ChipClk pin_c3 
.................... #define ChipDin pin_c5 
....................  
.................... //#define TRACE 
.................... //#define TRACE_READ_SECTOR 
.................... //#define TRACE_WRITE_SECTOR 
....................  
....................  
.................... #define NO_MMC_CARD	input(CardInserted) 
....................  
....................  
.................... int mmc_cmd(int8 cmd,int32 address,int8 tries,int8 valid,int8 invalid) 
.................... { 
.................... 	int i,r1; 
.................... 	for( i=0;i<16;i++)  
.................... 		SPI_READ(0xFF);// digest prior operation 
.................... 	// commands 
.................... 	// 7 6 5 4 3 2 1 0 
.................... 	// 0 1 b b b b b b    bbbbbb=cmd 
.................... 	// 16=0x50 set blocklength 
.................... 	// 17=0x51 read block 
.................... 	// 24=0x58 write block 
.................... #ifdef TRACE 
.................... //	TRACE2("\r\ncmd=%2X, address=%lu",cmd, address); 
.................... #endif 
....................  
.................... 	SPI_READ(cmd); 
.................... 	SPI_READ(MAKE8(address,3)); 
.................... 	SPI_READ(MAKE8(address,2)); 
.................... 	SPI_READ(MAKE8(address,1)); 
.................... 	SPI_READ(MAKE8(address,0)); 
.................... 	SPI_READ(0x95); 
.................... 	// card comes up in MMC mode and requires a valid MMC cmd to switch to SPI mode 
.................... 	// valid crc for MMC 0x40 cmd only 
.................... 	// spi mode doesn't require the CRC to be correct just there 
....................  
.................... 	for(i=0;i< tries;i++)  
.................... 	{ 
.................... 		r1=SPI_READ(0xFF); 
.................... 		if (r1==valid)  break; 
.................... 		if (r1==invalid)  break; 
.................... 	} 
....................  
.................... 	return(r1); 
.................... } 
....................  
.................... int init_MMC(int max_tries) 
.................... { 
.................... 	int i,tries,c; 
.................... 	tries=0; 
.................... 		 
.................... 	output_low(ChipSel);   /// reset chip hardware !!! required 
.................... 	delay_ms(100); 
....................  
.................... 	for(tries=0; tries < max_tries; tries++) 
.................... 	{ 
.................... 		output_high(ChipSel);   /// reset chip hardware !!! required 
.................... 		delay_ms(20); 
.................... 		for(i=0;i<20;i++)  
.................... 			SPI_READ(0xFF); // min 80 clocks to get MMC ready 
....................  
.................... 		output_low(ChipSel);   ///                      !!! required 
.................... 	 
.................... 		delay_ms(20); 
....................  
.................... 		c=mmc_cmd(0x40,0x00000000,128,0x01,0x99); 
....................  
.................... 		if (c==0x01)  
.................... 			break; 
.................... 	} 
.................... 	 
.................... 	if(tries >= max_tries) 
.................... 	{ 
.................... 		output_high(ChipSel); 
.................... 		return MMC_INIT_RESET_ERR; 
.................... 	} 
....................  
.................... 	/// now try  to switch to idle mode 
.................... 	/// Note: cmd1(idle) is the only command allowed after a cmd0(reset) 
....................  
.................... 	for(tries=0; tries < max_tries; tries++) 
.................... 	{ 
.................... 		c=mmc_cmd(0x41,0x00000000,128,0x00,0x99); 
.................... 		if (c==0x00)  
.................... 			break; 
.................... 	} 
....................  
.................... 	output_high(ChipSel); 
.................... 	 
.................... 	if(tries >= max_tries) 
.................... 		return MMC_INIT_IDLE_ERR; 
.................... 		 
.................... 	return MMC_NO_ERR; 
....................  
.................... } 
....................  
.................... int mmc_response(unsigned char response) 
.................... { 
.................... 	unsigned long count = 0xFFFF;           // 16bit repeat, it may be possible to shrink this to 8 bit but there is not much point 
....................  
.................... 	while(SPI_READ(0xFF) != response && --count > 0); 
....................  
.................... 	if(count==0)  
.................... 		return 1;                  // loop was exited due to timeout 
.................... 	else  
.................... 		return 0;                          // loop was exited before timeout 
.................... } 
....................  
....................  
.................... int ReadSector( int32 sector, char *buff) 
.................... { 
.................... 	int r1; 
.................... 	long i,iw; /// allows large gt 255 buff size addressing 
....................  
.................... 	output_low(ChipSel);    
.................... 	delay_ms(1); 
.................... 	 
.................... 	TRACE1("\r\nRead sector# %lu.", sector); 
.................... 	 
.................... 	r1=mmc_cmd(0x51,sector<<9,16,0x00,0x40); 
....................  
.................... 	if(r1 == 0x40) 
.................... 	{ 
.................... 		output_high(ChipSel); 
.................... 		return MMC_READ_INVALID_ERR; 
.................... 	} 
.................... 	else if(r1 != 0x00) 
.................... 	{ 
.................... 		output_high(ChipSel); 
.................... 		return MMC_READ_GEN_ERR; 
.................... 	} 
.................... 	 
.................... 	//Get token 
.................... 	for(iw=0;iw<1024;iw++) 
.................... 	{ 
.................... 		r1=SPI_READ(0xFF); 
.................... 		if (r1==0xFE)  
.................... 			break; 
.................... 	} 
.................... 	 
.................... 	//Get token error. It may be caused by improper MMC reset 
.................... 	if(r1 != 0xFE) 
.................... 	{ 
.................... 		output_high(ChipSel); 
.................... 		return MMC_READ_TOKEN_ERR; 
.................... 	} 
....................  
.................... 	//Read the whole sector (512 bytes) 
.................... 	for (i=0;i<512;i++)  
.................... 		buff[i]=SPI_READ(0xFF); 
....................  
.................... 	SPI_READ(0xFF); // read crc 
.................... 	SPI_READ(0xFF); 
....................  
.................... #ifdef TRACE_READ_SECTOR 
.................... 	fprintf(debug, "\r\nRead sector #%lu:", sector); 
....................  
.................... 	for(i = 0; i<512; i++) 
.................... 	{ 
.................... 		if(i%16 == 0) 
.................... 			fprintf(debug, "\r\n%04LX - ", i); 
.................... 		r1 = *buff; 
.................... 		if(r1 < ' ' || r1 > 'z') 
.................... 			r1 = '.'; 
.................... 		fprintf(debug, "%02X%c ", *buff++, r1); 
....................  
.................... 	} 
.................... #endif 
....................  
.................... 	output_high(ChipSel); 
.................... 	return MMC_NO_ERR; 
.................... } 
....................  
.................... int WriteSector(int32 sector, char *buff) 
....................  
.................... { 
.................... 	int r1; 
.................... 	int16 i; 
....................  
....................  
.................... 	TRACE1("\r\nWriteSector(%lu).", sector); 
....................  
.................... 	if(sector == 0)	//never write sector 0 
.................... 		return MMC_WRITE_SEC0_ERR; 
....................  
.................... 	output_low(ChipSel); 
.................... 	delay_ms(1); 
.................... 	 
.................... 	r1=mmc_cmd(0x58,sector<<9,16,0x00,0x40); 
....................  
....................  
.................... 	if(r1 == 0x40) 
.................... 	{ 
.................... 		output_high(ChipSel);	 
.................... 		return MMC_WRITE_INVALID_ERR; 
.................... 	} 
.................... 	else if(r1 != 0x00) 
.................... 	{ 
.................... 		output_high(ChipSel); 
.................... 		return MMC_WRITE_GEN_ERR; 
.................... 	} 
....................  
.................... 	SPI_READ(0xFE); 
....................  
.................... 	for (i=0;i < 512;i++)  
.................... 	{ 
.................... 		SPI_READ(buff[i]);  /// send payload 
.................... 	} 
....................  
....................  
.................... 	SPI_READ(0xFF); // send dummy chcksum 
.................... 	SPI_READ(0xFF); 
.................... 	r1=SPI_READ(0xFF); 
.................... 	for( i=0;i<0x0fff;i++)  
.................... 	{ 
.................... 		r1=SPI_READ(0xFF);// digest prior operation 
.................... 		if (r1!=0x00)  
.................... 			break; 
.................... 	} 
....................  
.................... #ifdef TRACE_WRITE_SECTOR 
.................... 	fprintf(debug, "\r\nWrite sector #%lu:", sector); 
....................  
.................... 	for(i = 0; i<512; i++) 
.................... 	{ 
.................... 		if(i%16 == 0) 
.................... 			fprintf(debug, "\r\n%04LX - ", i); 
.................... 		r1 = *buff; 
.................... 		if(r1 < ' ' || r1 > 'z') 
.................... 			r1 = '.'; 
.................... 		fprintf(debug, "%02X%c ", *buff++, r1); 
....................  
.................... 	} 
....................  
.................... #endif 
....................  
.................... 	output_high(ChipSel); 
.................... 	return MMC_NO_ERR; 
.................... } 
....................  
....................  
....................  
....................  
.................... char IsSelfDir(char *ch) 
.................... { 
....................    if (ch[0] == '.' && ch[1] == '.') return 0xFF; 
....................    else return 0; 
.................... } 
....................  
....................  
.................... int16 GetCurrentDOSDate() 
.................... { 
....................    int16 retval; 
....................  
....................    retval = myrec.tm_year - 1980; 
....................    retval <<= 9; 
....................    retval |= ((int16)myrec.tm_mon << 5); 
....................    retval |= (int16)myrec.tm_mday; 
....................    return retval; 
.................... } 
....................  
.................... int16 GetCurrentDOSTime() 
.................... { 
....................    int16 retval; 
....................  
....................    retval = myrec.tm_hour; 
....................    retval <<= 11; 
....................    retval |= ((int16)myrec.tm_min << 5); 
....................    retval |= (int16)myrec.tm_sec >> 1; 
....................    return retval; 
.................... } 
....................  
.................... int InitFAT() 
.................... { 
....................    int32 actsector; 
....................    int32 nTotalSec, nDataSec, nCountofClusters; 
....................    char i; 
....................  
....................    gFirstEmptyCluster = 0; 
....................    gFAT32Vars.gStartSector = 0; 
....................    gFAT32Vars.bFATModified = 0; 
....................    gFATType = FAT_UNKNOWN; 
....................  
....................    //Read start sector to temp buffer 
....................    //fprintf(debug, "\r\nRead start sector "); 
....................    gFATErrCode = ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IObuffer); 
....................     
....................    if(gFATErrCode != MMC_NO_ERR) 
....................       return  gFATErrCode; 
....................  
....................    if (gFiles[MAXFILES-1].IObuffer[0] != 0xEB)  
....................    { 
....................       gStartSectorL = gFiles[MAXFILES-1].IObuffer[0x1C6]; 
....................       gStartSectorH = gFiles[MAXFILES-1].IObuffer[0x1C7]; 
....................       gStartSectorHL = gFiles[MAXFILES-1].IObuffer[0x1C8]; 
....................  
....................       //fprintf(debug, "\r\nRead start sector"); 
....................       gFATErrCode = ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IObuffer); 
....................       if(gFATErrCode != MMC_NO_ERR) 
....................          return  gFATErrCode; 
....................    } 
....................     
....................    memcpy(&DiskInfo,gFiles[MAXFILES-1].IObuffer,sizeof(DiskInfo)); 
....................  
....................    //Check FAT type 
....................    gFAT32Vars.nRootDirSectors = (DiskInfo.RootEntCnt*32 + (DiskInfo.BytsPerSec - 1))/DiskInfo.BytsPerSec; 
....................  
....................    gFAT32Vars.nFatSize = DiskInfo.FATSz16; 
....................    if(gFAT32Vars.nFatSize == 0) 
....................       gFAT32Vars.nFatSize = DiskInfo.FATSz32; 
....................  
....................    nTotalSec = DiskInfo.TotSec16; 
....................    if(nTotalSec == 0) 
....................       nTotalSec = DiskInfo.TotSec32; 
....................  
....................    nDataSec = nTotalSec - (DiskInfo.RsvdSecCnt + DiskInfo.NumFATs*gFAT32Vars.nFatSize) + gFAT32Vars.nRootDirSectors; 
....................  
....................    nCountofClusters = nDataSec/DiskInfo.SecPerClus; 
....................  
....................    //fprintf(debug, "\r\nFatSize=%lu, TotalSec=%lu, CountofClusters=%lu", 
....................    //   gFAT32Vars.nFatSize, nTotalSec, nCountofClusters); 
....................  
....................    if(nCountofClusters < 4085) 
....................       gFATType = FAT12; 
....................    else if(nCountofClusters < 65525) 
....................       gFATType = FAT16; 
....................    else 
....................       gFATType = FAT32; 
....................  
....................    actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt; 
....................  
....................    //Read FAT table 
....................    //fprintf(debug, "\r\nRead FAT table "); 
....................    gFATErrCode = ReadSector(actsector,FATTable.FAT32); 
....................  
....................    gFAT32Vars.FATstartidx = 0; 
....................  
....................    gFAT32Vars.gFirstDataSector = gFAT32Vars.gStartSector  
....................       + DiskInfo.NumFATs*gFAT32Vars.nFatSize 
....................       + gFAT32Vars.nRootDirSEctors  
....................       + DiskInfo.RsvdSecCnt - 2*DiskInfo.SecPerClus; 
....................     
....................    for (i=0;i<MAXFILES;i++) 
....................       gFiles[i].Free = TRUE; 
....................        
....................    return  gFATErrCode; 
....................  
.................... } 
....................  
.................... void SaveFATTable() 
.................... { 
....................    int32 actsector; 
....................    actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
....................    gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
....................    actsector += gFAT32Vars.nFatSize; 
....................    gFATErrCode = WriteSector(actsector,FATTable.FAT32);    
....................  
....................    gFAT32Vars.bFATModified = 0; 
....................     
.................... } 
....................  
.................... int32 GetNextCluster(int32 curcluster) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
.................... #ifdef TRACE 
....................    TRACE1("\r\nGetNextCluster(%lu)", curcluster);    
.................... #endif 
....................    if(gFATType == FAT32) 
....................    { 
....................       clpage = curcluster >> 7; 
....................       clpos = curcluster & 0x7F; 
....................       if (clpage != gFAT32Vars.FATstartidx) // read in the requested page 
....................       {  
....................          if(gFAT32Vars.bFATModified) 
....................             SaveFATTable();          
....................          actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
....................          ReadSector(actsector,FATTable.FAT32); 
....................          gFAT32Vars.FATstartidx = clpage; 
....................       } 
....................       return (FATTable.FAT32[clpos]); 
....................    } 
....................    else   //FAT16 
....................    { 
....................       clpage = curcluster >> 8; 
....................       clpos = curcluster & 0xFF;       
....................       if (clpage != gFAT32Vars.FATstartidx) // read in the requested page 
....................       {  
....................          if(gFAT32Vars.bFATModified) 
....................             SaveFATTable(); 
....................          actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
....................          ReadSector(actsector,FATTable.FAT16); 
....................          gFAT32Vars.FATstartidx = clpage; 
....................       } 
....................       if(FATTable.FAT16[clpos] > 0xFFF4) 
....................          return (FATTable.FAT16[clpos]|0x0FFF0000); 
....................       else 
....................          return (FATTable.FAT16[clpos]); 
....................    } 
....................     
.................... } 
....................  
.................... void SetClusterEntry(int32 curcluster,int32 value) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
.................... #ifdef TRACE 
....................    //fprintf(debug, "\r\nSetClusterEntry(%lu, %lu)", curcluster, value);    
.................... #endif 
....................    if(gFATType == FAT32) 
....................    { 
....................       //FAT32, 4 bytes per entery. Total 128 entries per sector (512 bytes) 
....................       clpage = curcluster >> 7;   //Calculate sector# in FAT table 
....................       clpos = curcluster & 0x7F;   //Calculate FAT index in sector 
....................       //Calculate FAT physical sector # 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
....................        
....................       if (clpage != gFAT32Vars.FATstartidx)  
....................       { 
....................          if(gFAT32Vars.bFATModified) 
....................             SaveFATTable(); 
....................          ReadSector(actsector,FATTable.FAT32); 
....................          gFAT32Vars.FATstartidx = clpage; 
....................       } 
....................       FATTable.FAT32[clpos] = value; 
....................       gFAT32Vars.bFATModified = 1; 
....................    } 
....................    else   //FAT16 
....................    { 
....................       //FAT16, 2 bytes per entry. Total 256 entries per sector (512 bytes) 
....................       clpage = curcluster >> 8; 
....................       clpos = curcluster & 0xFF; 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
....................       if (clpage != gFAT32Vars.FATstartidx)  
....................       { 
....................          if(gFAT32Vars.bFATModified) 
....................             SaveFATTable(); 
....................          ReadSector(actsector,FATTable.FAT16); 
....................          gFAT32Vars.FATstartidx = clpage; 
....................       } 
....................       FATTable.FAT16[clpos] = value; 
....................       gFAT32Vars.bFATModified = 1; 
....................    } 
.................... //   gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
.................... //   actsector += gFAT32Vars.nFatSize; 
.................... //   gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
.................... } 
....................  
.................... void ClearClusterEntry(int32 curcluster) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
.................... #ifdef TRACE 
....................    //fprintf(debug, "\r\nClearClusterEntry()");    
.................... #endif 
....................    if(gFATType == FAT32) 
....................    { 
....................       clpage = curcluster >> 7; 
....................       clpos = curcluster & 0x7F; 
....................    } 
....................    else   //FAT16 
....................    { 
....................       clpage = curcluster >> 8; 
....................       clpos = curcluster & 0xFF; 
....................    } 
....................    if (clpage != gFAT32Vars.FATstartidx)  
....................    { 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
....................       WriteSector(actsector,FATTable.FAT32); 
....................       actsector += gFAT32Vars.nFatSize; 
....................       WriteSector(actsector,FATTable.FAT32); 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
....................       ReadSector(actsector,FATTable.FAT32); 
....................       gFAT32Vars.FATstartidx = clpage; 
....................    } 
....................     
....................    if(gFATType == FAT32) 
....................    { 
....................       FATTable.FAT32[clpos] = 0; 
....................    } 
....................    else   //FAT16 
....................    { 
....................       FATTable.FAT16[clpos] = 0; 
....................    } 
....................    gFAT32Vars.bFATModified = 1; 
.................... } 
....................  
.................... int32 FindFirstFreeCluster() 
.................... { 
....................    int32 i,st,actsector,retval; 
....................    int16 j; 
....................  
.................... #ifdef TRACE 
....................    //fprintf(debug, "\r\nFindFirstFreeCluster()");    
.................... #endif 
....................    st = gFirstEmptyCluster; 
....................    if(gFATType == FAT32) 
....................    { 
....................       for (i=st;i<DiskInfo.FATSz32;i++)  
....................       { 
....................          if (i != gFAT32Vars.FATstartidx)  
....................          { 
....................             actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + i; 
....................             //Save FAT 
....................             if(gFAT32Vars.bFATModified) 
....................                SaveFATTable(); 
....................             ReadSector(actsector,FATTable.FAT32); 
....................             gFAT32Vars.FATstartidx = gFirstEmptyCluster = i; 
....................          } 
....................          for (j=0;j<128;j++) 
....................             if (FATTable.FAT32[j] == 0)  
....................             { 
....................                retval = i; 
....................                retval <<= 7; 
....................                retval |= j; 
....................                return retval; 
....................             } 
....................       } 
....................    } 
....................    else   //FAT16 
....................    { 
....................       for (i=st;i<DiskInfo.FATSz16;i++)  
....................       { 
....................          if (i != gFAT32Vars.FATstartidx)  
....................          { 
....................             actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + i; 
....................             if(gFAT32Vars.bFATModified) 
....................                SaveFATTable(); 
....................             ReadSector(actsector,FATTable.FAT16); 
....................             gFAT32Vars.FATstartidx = gFirstEmptyCluster = i; 
....................          } 
....................          for (j=0;j<256;j++) 
....................             if (FATTable.FAT16[j] == 0)  
....................             { 
....................                retval = i; 
....................                retval <<= 8; 
....................                retval |= j; 
....................                if(retval > 0xFFF4) 
....................                   return (retval|0x0FFF0000); 
....................                else 
....................                   return retval; 
....................             } 
....................       } 
....................    } 
....................    return 0x0FFFFFFF; 
.................... } 
....................  
.................... void ConvertFilename(DIR *beDir,char *name) 
.................... { 
....................    char i,j,c; 
....................  
....................    j = 0; 
....................    name[0] = 0; 
....................    for (i=0;i<8;i++) { 
....................       c = beDir->sName[i]; 
....................       if (c == ' ') break; 
....................       name[j++] = c; 
....................    } 
....................    for (i=0;i<3;i++) { 
....................       c = beDir->sExt[i]; 
....................       if (c == ' ' || c == 0) break; 
....................       if (!i) name[j++] = '.'; 
....................       name[j++] = c; 
....................    } 
....................    name[j++] = 0; 
.................... } 
....................  
.................... void GetDOSName(DIR *pDir, char *fname) 
.................... { 
....................    char i,j,leng,c,toext; 
....................  
....................    toext = FALSE; 
....................    j = 0; 
....................    leng = strlen(fname); 
....................    for (i=0;i<8;i++) 
....................       pDir->sName[i] = ' '; 
....................    for (i=0;i<3;i++) 
....................       pDir->sExt[i] = ' '; 
....................    for (i=0;i<leng;i++) { 
....................       c = fname[i]; 
....................       c = toupper(c); 
....................       if (c == '.') { 
....................          toext = TRUE; 
....................          continue; 
....................       } 
....................       if (toext) pDir->sExt[j++] = c; 
....................       else pDir->sName[i] = c; 
....................    } 
.................... } 
....................  
.................... //Read the first dir sector 
.................... void ReadRootDirectory(HANDLE hFile) 
.................... { 
....................    int32 actsector; 
....................  
....................    TRACE0("\r\nReadRootDirectory()");    
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return; 
....................        
....................    actsector = gFAT32Vars.gStartSector + DiskInfo.NumFATs*gFAT32Vars.nFatSize+DiskInfo.RsvdSecCnt; 
....................     
....................    ReadSector(actsector,DIR_BUFFER); 
....................     
....................    gFAT32Vars.gDirEntrySector = actsector; 
....................    gFiles[hFile].dirSector = actsector; 
....................    gFiles[hFile].dirIdx = 0; 
....................    memcpy(&(gFiles[hFile].DirEntry),DIR_BUFFER,32); 
....................    gFiles[hFile].CurrentCluster = DiskInfo.RootClus; 
.................... } 
....................  
.................... //Always call TryFile before calling FindDirEntry to allow search from root dir sector 
.................... char FindDirEntry(char *fname,HANDLE hFile) 
.................... { 
....................    DIR *pDir; 
....................    int16 i; 
....................    char filename[16]; 
....................    int32 nextcluster,actsector; 
....................    int nSecInClus; 
....................    int bDone; 
....................  
....................  
....................    TRACE2("\r\nFindDirEntry(%s,%d)", fname, hFile);    
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return FALSE; 
....................  
....................    bDone = false; 
....................    nSecInClus = 0; 
....................    gFAT32Vars.gFirstEmptyDirEntry = 0xFFFF; 
....................    gFAT32Vars.gFirstDirEntryCluster = 0x0FFFFFFF; 
....................    nextcluster = gFiles[hFile].CurrentCluster; 
....................    do { 
....................       pDir = (DIR*)(DIR_BUFFER); 
....................       for (i=0;i<16;i++)  
....................       { 
....................          if ((pDir->sName[0] == 0xE5 || pDir->sName[0] == 0) && gFAT32Vars.gFirstEmptyDirEntry == 0xFFFF)  // store first free 
....................          { 
....................             gFAT32Vars.gFirstEmptyDirEntry = i; 
....................             gFAT32Vars.gFirstDirEntryCluster = gFiles[hFile].CurrentCluster; 
....................          } 
....................  
....................          if (pDir->sName[0] == 0)    //Searched all exist dir entries 
....................             return FALSE; 
....................  
....................          ConvertFilename(pDir,filename); 
....................  
....................          if (!strcmp(filename,fname))    //Found matching dir entry 
....................          { 
....................             memcpy(&(gFiles[hFile].DirEntry),pDir,32); 
....................             gFiles[hFile].dirIdx = i; 
....................             gFAT32Vars.gDirEntryIdx = i; 
....................             return TRUE; 
....................          } 
....................          pDir++; 
....................       } 
....................        
....................       if(gFATType == FAT32)   //FAT32 DIR sector are chained 
....................       { 
....................          //Searched all sector in cluster? 
....................          if(++nSecInClus < DiskInfo.SecPerClus) 
....................          { 
....................             actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector + nSecInClus; 
....................             ReadSector(actsector,DIR_BUFFER); 
....................             gFAT32Vars.gDirEntrySector = actsector; 
....................             gFiles[hFile].dirSector = actsector; 
....................          } 
....................          else   //Get next cluster 
....................          { 
....................             nSecInClus = 0; 
....................             nextcluster = GetNextCluster(gFiles[hFile].CurrentCluster); 
....................             gFAT32Vars.gFirstDirEntryCluster = nextcluster; 
....................             if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
....................             { 
....................                actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................                ReadSector(actsector,DIR_BUFFER); 
....................                gFAT32Vars.gDirEntrySector = actsector; 
....................                gFiles[hFile].dirSector = actsector; 
....................                gFiles[hFile].CurrentCluster = nextcluster; 
....................             } 
....................             else  
....................                bDone = true; 
....................          } 
....................          //bDone = !(nSecInClus < DiskInfo.SecPerClus || (nextcluster != 0x0FFFFFFF && nextcluster != 0)); 
....................       } 
....................       else   //FAT16 
....................       { 
....................           
....................          if(++nSecInClus < gFAT32Vars.nRootDirSectors) 
....................          { 
....................             actsector = gFAT32Vars.gStartSector + DiskInfo.NumFATs*gFAT32Vars.nFatSize+DiskInfo.RsvdSecCnt + nSecInClus; 
....................             ReadSector(actsector,DIR_BUFFER); 
....................             gFAT32Vars.gDirEntrySector = actsector; 
....................             gFiles[hFile].dirSector = actsector; 
....................          } 
....................          else 
....................          { 
....................             bDone = true; 
....................          } 
....................           
....................       } 
....................    } while (!bDone); 
....................  
....................    return FALSE; 
.................... } 
....................  
.................... // file I/O routines 
.................... char* TryFile(char *fname, HANDLE *hFile) 
.................... { 
....................    char i,leng; 
....................    char *filename; 
....................  
....................    TRACE1("\r\nTryFile(%s)", fname); 
....................    *hFile = 0xFF; 
....................    for (i=0;i<MAXFILES;i++)  
....................    { 
....................       if (gFiles[i].Free)  
....................       { 
....................          *hFile = i; 
....................          break; 
....................       } 
....................    } 
....................    if (*hFile == 0xFF)  
....................       return 0; 
....................  
....................    ReadRootDirectory(*hFile); 
....................  
....................    filename = fname; 
....................    leng = strlen(fname); 
....................    for (i=0;i<leng;i++)  
....................    { 
....................       if (fname[i] == '/')  
....................       { 
....................          fname[i] = 0; 
....................          if (!cwd(filename,*hFile))  
....................          { 
....................             gFiles[*hFile].Free = TRUE; 
....................             return 0; 
....................          } 
....................          filename = fname+i+1; 
....................       } 
....................    } 
....................    return filename; 
.................... } 
....................  
.................... char fcreate(HANDLE hFile,char *fname) 
.................... { 
....................    DIR *pDir; 
....................    int32 actsector,actcl; 
....................    int16 i; 
....................  
.................... #ifdef TRACE 
....................    TRACE2("\r\nfcreate(%d, %s)", hFile, fname);    
.................... #endif 
....................  
....................    if (hFile > (MAXFILES-1)) 
....................       return FALSE; 
....................  
....................    if(gFATType == FAT32) 
....................    { 
....................       if (gFAT32Vars.gFirstDirEntryCluster == 0x0FFFFFFF)  
....................       { 
.................... #ifdef TRACE 
....................          TRACE0("\r\nfcreate() - gFirstDirEntryCluster == 0xFFFFFFF");    
.................... #endif         // extend the directory file !!! 
....................          gFAT32Vars.gFirstDirEntryCluster = FindFirstFreeCluster(); 
....................          gFAT32Vars.gFirstEmptyDirEntry = 0; 
....................          SetClusterEntry(gFiles[hFile].CurrentCluster,gFAT32Vars.gFirstDirEntryCluster); 
....................          SetClusterEntry(gFAT32Vars.gFirstDirEntryCluster,0x0FFFFFFF); 
....................          actsector = gFAT32Vars.gFirstDirEntryCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................           
....................          for (i=0;i<512;i++) 
....................             DIR_BUFFER[i] = 0; 
....................  
....................          //Clean up  all sectors in the dir cluster 
....................          for(i=0; i<DiskInfo.SecPerClus; i++) 
....................             gFATErrCode = WriteSector(actsector + i,DIR_BUFFER); 
....................              
....................          if(gFATErrCode != MMC_NO_ERR) 
....................          { 
.................... #ifdef TRACE 
....................             TRACE0( "\r\nfcreate() - WriteSector failed");    
.................... #endif            return false; 
....................          } 
....................       } 
....................       else 
....................          actsector = gFiles[hFile].dirSector; 
....................  
....................       //actsector = gFAT32Vars.gFirstDirEntryCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................    } 
....................    else   //FAT16 
....................    { 
....................       //FAT16 has fixed size DIR sectors 
....................       actsector = gFiles[hFile].dirSector; 
....................    } 
....................     
....................    ReadSector(actsector,DIR_BUFFER); 
....................  
....................    pDir = (DIR*)(&(DIR_BUFFER[32*gFAT32Vars.gFirstEmptyDirEntry])); 
....................    gFiles[hFile].dirSector = actsector; 
....................    gFiles[hFile].dirIdx = gFAT32Vars.gFirstEmptyDirEntry; 
....................     
....................    GetDOSName(pDir,fname); 
....................    pDir->bAttr = 0; 
....................    actcl = FindFirstFreeCluster(); 
....................  
.................... #ifdef TRACE 
....................    TRACE1("\r\nFindFirstFreeCluster returns %lu", actcl);    
.................... #endif    
....................  
....................    pDir->hCluster = actcl & 0xFFFF; 
....................    pDir->hClusterH = actcl >> 16; 
....................    SetClusterEntry(actcl,0x0FFFFFFF); 
....................    pDir->wSize = 0; 
....................    gFiles[hFile].wFileSize = 0; 
....................    pDir->hDate = GetCurrentDOSDate(); 
....................    pDir->hTime = GetCurrentDOSTime(); 
....................  
....................    gFATErrCode = WriteSector(actsector,DIR_BUFFER); 
....................  
....................    memcpy(&(gFiles[hFile].DirEntry),pDir,32); 
....................    return TRUE; 
.................... } 
....................  
.................... int32 ComposeCluster(HANDLE hFile) 
.................... { 
....................    int32 retval; 
....................  
....................    retval = gFiles[hFile].DirEntry.hClusterH; 
....................    retval <<= 16; 
....................    retval |= gFiles[hFile].DirEntry.hCluster; 
....................    return retval; 
.................... } 
....................  
.................... char fopen(char *fname, char mode) 
.................... { 
....................    char found; 
....................    HANDLE hFile; 
....................    int32 actsector,actcluster,nextcluster; 
....................    char *filename; 
....................  
.................... #ifdef TRACE 
....................    TRACE2("\r\nfopen(%s, %c)", fname, mode);    
.................... #endif 
.................... //   if (NO_MMC_CARD)  
.................... //      return 0xFF; 
....................  
....................    filename = TryFile(fname,&hFile); 
....................     
....................    if (filename == 0)    //Invalid filename? 
....................       return 0xFF; 
....................     
....................    found = FALSE; 
....................    found = FindDirEntry(filename,hFile); 
....................     
....................    if (!found)    //File not exist 
....................    { 
....................       if (mode == 'r')  
....................       { 
....................          gFiles[hFile].Free = TRUE; 
....................          return 0xFF; 
....................       }  
....................       else  
....................       { 
....................          if (!fcreate(hFile,filename))  
....................             return 0xFF; 
....................          found = TRUE; 
....................       } 
....................    } 
....................    if (found)  
....................    { 
....................       gFiles[hFile].Free = FALSE; 
....................       gFiles[hFile].mode = mode; 
....................       if  (mode == 'a')    //Append 
....................       { 
....................          gFiles[hFile].wFileSize = gFiles[hFile].DirEntry.wSize; 
....................          actcluster = ComposeCluster(hFile); 
....................          nextcluster = actcluster; 
....................          TRACE2("\r\nCluster starts at %lu(0x%04X).", actcluster, actcluster); 
....................          while (actcluster != 0x0FFFFFFF && nextcluster != 0)  
....................          { 
....................             nextcluster = GetNextCluster(actcluster); 
....................             if (nextcluster == 0x0FFFFFFF || nextcluster == 0)  
....................                break; 
....................             actcluster = nextcluster; 
....................          } 
....................          TRACE2("\r\nFound end cluster %lu(0x%04X).", actcluster, actcluster); 
....................           
....................          actsector = actcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................          gFiles[hFile].SecInCluster = (gFiles[hFile].wFileSize>>9)%DiskInfo.SecPerClus; 
....................          actsector += gFiles[hFile].SecInCluster; 
....................           
....................          ReadSector(actsector,gFiles[hFile].IObuffer); 
....................           
....................          gFiles[hFile].CurrentCluster = actcluster; 
....................          gFiles[hFile].posinsector = gFiles[hFile].wFileSize & 0x01FF; 
....................           
....................          if (gFiles[hFile].posinsector == 0 && gFiles[hFile].wFileSize != 0)  
....................             gFiles[hFile].posinsector = 512; 
....................       }  
....................       else    //Write or read only 
....................       { 
....................          gFiles[hFile].wFileSize = 0; 
....................          actsector = ComposeCluster(hFile)*DiskInfo.SecPerClus; 
....................          actsector += gFAT32Vars.gFirstDataSector; 
....................          ReadSector(actsector,gFiles[hFile].IObuffer); 
....................          gFiles[hFile].CurrentCluster = ComposeCluster(hFile); 
....................          gFiles[hFile].posinsector = 0; 
....................          gFiles[hFile].SecInCluster = 0; 
....................       } 
....................    } 
....................    return hFile; 
.................... } 
....................  
.................... void fclose(HANDLE hFile) 
.................... { 
.................... #ifdef TRACE 
....................    //fprintf(debug, "\r\nfclose()");    
.................... #endif 
....................    //   output_low(YELLOWLED); 
....................    if (hFile > (MAXFILES-1)) return; 
....................    if ((gFiles[hFile].mode == 'a') || (gFiles[hFile].mode == 'w'))  
....................       fflush(hFile); 
....................    gFiles[hFile].Free = TRUE; 
.................... } 
....................  
....................  
.................... void fflush(HANDLE hFile) 
.................... { 
....................    int32 actsector; 
....................    DIR *pDir; 
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return; 
....................     
....................    //Write data sector 
....................    actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................    actsector += gFiles[hFile].SecInCluster; 
....................    WriteSector(actsector,gFiles[hFile].IObuffer); 
....................     
....................    if(gFAT32Vars.bFATModified) 
....................       SaveFATTable(); 
....................     
....................    //Read dir entry 
.................... #ifdef DIR_SHARE_IOBUFFER    
....................    if(ReadSector(gFiles[hFile].dirSector,gFiles[hFile].IObuffer) == MMC_NO_ERR) 
....................    { 
.................... #endif 
....................       pDir = (DIR*)(&(DIR_BUFFER[32*gFiles[hFile].dirIdx])); 
....................        
....................       //Update file size 
....................       if (gFiles[hFile].DirEntry.bAttr & 0x10)  
....................          pDir->wSize = 0; // if it is a directory 
....................       else  
....................          pDir->wSize = gFiles[hFile].wFileSize; 
....................  
....................       //Update file date/time 
....................       pDir->hDate = GetCurrentDOSDate(); 
....................       pDir->hTime = GetCurrentDOSTime(); 
....................  
....................       //Write dir entry 
....................       WriteSector(gFiles[hFile].dirSector,DIR_BUFFER); 
.................... #ifdef DIR_SHARE_IOBUFFER 
....................    } 
....................    //Read back data sector 
....................    ReadSector(actsector,gFiles[hFile].IObuffer); 
.................... #else 
....................  
.................... } 
....................  
.................... char cwd(char *fname, HANDLE hFile) 
.................... { 
....................    int32 actsector; 
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return FALSE; // just in case of overaddressing 
....................     
....................    if (IsSelfDir(fname))  
....................       return TRUE; // already in Root dir 
....................     
....................    if (!FindDirEntry(fname,hFile))  
....................       return FALSE; // not found 
....................     
....................    actsector = ComposeCluster(hFile)*DiskInfo.SecPerClus; 
....................    actsector += gFAT32Vars.gFirstDataSector; // read current dir 
....................    ReadSector(actsector,DIR_BUFFER); 
....................    gFAT32Vars.gDirEntrySector = actsector; 
....................    gFiles[hFile].dirSector = actsector; 
....................    gFiles[hFile].CurrentCluster = ComposeCluster(hFile); 
....................    return TRUE; 
.................... } 
....................  
.................... void fputch(char ch, HANDLE hFile) 
.................... { 
....................    int32 nextcluster,actsector; 
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return; 
....................        
....................    //Sector buffer full? Write to disk 
....................    if (gFiles[hFile].posinsector >= 512)  
....................    { 
.................... #ifdef DIR_SHARE_IOBUFFER       
....................       //Calculate physical sector# 
....................       actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................       actsector += gFiles[hFile].SecInCluster; 
....................        
....................       //Write to disk 
....................       WriteSector(actsector,gFiles[hFile].IObuffer); 
.................... #else 
....................       fflush(hFile); 
.................... #endif 
....................       //Increase sector counter 
....................       gFiles[hFile].SecInCluster++;    
....................  
....................       //Finished a cluster? Find a free cluster and append it to FAT chain. 
....................       if(gFiles[hFile].SecInCluster >= DiskInfo.SecPerClus) 
....................       { 
....................          //Get next free cluster 
....................          nextcluster = FindFirstFreeCluster(); 
....................  
....................          //Is it a valid cluster? 
....................          if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
....................          { 
....................             //Append new found cluster to FAT chain 
....................             SetClusterEntry(gFiles[hFile].CurrentCluster,nextcluster); 
....................             SetClusterEntry(nextcluster,0x0FFFFFFF); 
....................              
....................             //Calculate phsical sector# 
....................             actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................              
....................             //Read sector into buffer          
....................             ReadSector(actsector,gFiles[hFile].IObuffer); 
....................              
....................             //Clear buffer 
....................             memset(gFiles[hFile].IObuffer, 0, 512); 
....................           
....................             //Remember cluster# 
....................             gFiles[hFile].CurrentCluster = nextcluster; 
....................          } 
....................           
....................          //Reset sector (in cluster) counter 
....................          gFiles[hFile].SecInCluster = 0; 
....................       } 
....................  
....................       //Reset byte (in sector) counter 
....................       gFiles[hFile].posinsector = 0; 
....................    } 
....................     
....................    gFiles[hFile].IObuffer[gFiles[hFile].posinsector] = ch; 
....................    gFiles[hFile].posinsector++; 
....................    gFiles[hFile].wFileSize++; 
....................  
.................... } 
....................  
.................... void fputstring(char *str, HANDLE hFile) 
.................... { 
....................  
.................... #ifdef TRACE 
.................... //   fprintf(debug, "\r\nfputstring(%s, %d)", str, hFile);    
.................... #endif 
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return; 
....................  
....................    while(*str) 
....................       fputch(*str++,hFile); 
.................... } 
....................  
.................... int16 fread(char *buffer, int16 leng, HANDLE hFile) 
.................... { 
....................    int16 i,retv; 
....................    char c,v; 
....................  
....................    TRACE1("\r\nfread(length=%ld)", leng);    
....................  
....................    if (hFile > (MAXFILES-1)) return 0; 
....................    retv = 0; 
....................    for (i=0;i<leng;i++)  
....................    { 
....................       v = fgetch(&c,hFile); 
....................       if (v) { 
....................          buffer[i] = c; 
....................          retv++; 
....................       } 
....................       else break; 
....................    } 
....................    return retv; 
.................... } 
....................  
.................... void fwrite(char *buffer, int16 leng, HANDLE hFile) 
.................... { 
....................    int16 i; 
....................  
....................    TRACE1("\r\nfwrite(length=%ld)", leng);    
....................     
....................    if (hFile > (MAXFILES-1))  
....................       return; 
....................        
....................    for (i=0;i<leng;i++) 
....................       fputch(buffer[i],hFile); 
....................  
.................... } 
....................  
.................... char fgetch(char *ch,HANDLE hFile) 
.................... { 
....................    int32 nextcluster,actsector; 
....................  
....................    if (hFile > (MAXFILES-1))  
....................       return FALSE; 
....................     
....................    if (gFiles[hFile].wFileSize >= gFiles[hFile].DirEntry.wSize) //Invalid read pointer 
....................       return FALSE; 
....................     
....................    *ch = gFiles[hFile].IObuffer[gFiles[hFile].posinsector]; 
....................     
....................    gFiles[hFile].posinsector++; 
....................    gFiles[hFile].wFileSize++; 
....................     
....................    if (gFiles[hFile].posinsector >= 512)  
....................    { 
....................       //More sector in cluster? 
....................       gFiles[hFile].SecInCluster++;  
....................       if(gFiles[hFile].SecInCluster < DiskInfo.SecPerClus)   //Get next sector incluster 
....................       { 
....................          actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................          actsector += gFiles[hFile].SecInCluster; 
....................          ReadSector(actsector,gFiles[hFile].IObuffer); 
....................          gFiles[hFile].posinsector = 0; 
....................       } 
....................       else   //Get next cluster 
....................       { 
....................          gFiles[hFile].SecInCluster = 0; 
....................          nextcluster = GetNextCluster(gFiles[hFile].CurrentCluster); 
....................          if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
....................          { 
....................             actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
....................             ReadSector(actsector,gFiles[hFile].IObuffer); 
....................             gFiles[hFile].CurrentCluster = nextcluster; 
....................             gFiles[hFile].posinsector = 0; 
....................          } 
....................       } 
....................    } 
....................    return TRUE; 
.................... } 
....................  
.................... char remove(char *fname) 
.................... { 
....................    char i,found; 
....................    HANDLE hFile; 
....................    DIR *pDir; 
....................    int32 nextcluster,currentcluster; 
....................    char *filename; 
....................  
....................    filename = TryFile(fname,&hFile); 
....................    if (filename == 0) return FALSE; 
....................    found = FindDirEntry(filename,hFile); 
....................    if (!found) { 
....................       gFiles[hFile].Free = TRUE; 
....................       return FALSE; 
....................    } 
....................    pDir = (DIR*)(&(DIR_BUFFER[32*gFAT32Vars.gDirEntryIdx])); 
....................    pDir->sName[0] = 0xE5; 
....................    for (i=1;i<8;i++) 
....................       pDir->sName[i] = ' '; 
....................    for (i=0;i<3;i++) 
....................       pDir->sExt[i] = ' '; 
....................    WriteSector(gFAT32Vars.gDirEntrySector,DIR_BUFFER); 
....................    currentcluster = ComposeCluster(hFile); 
....................    while (currentcluster != 0x0FFFFFFF && nextcluster != 0)  
....................    { 
....................       nextcluster = GetNextCluster(currentcluster); 
....................       ClearClusterEntry(currentcluster); 
....................       currentcluster = nextcluster; 
....................    } 
....................    ClearClusterEntry(currentcluster); 
....................    SetClusterEntry(currentcluster,0); 
....................    SaveFATTable(); 
.................... //   currentcluster = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
.................... //   WriteSector(currentcluster,FATTable.FAT32); 
.................... //   currentcluster += DiskInfo.FATSz32; 
.................... //   WriteSector(currentcluster,FATTable.FAT32); 
....................    gFiles[hFile].Free = TRUE; 
....................    return TRUE; 
.................... } 
....................  
.................... char getfsize(char *fname, int32 *fsiz) 
.................... { 
....................    char found; 
....................    HANDLE hFile; 
....................    DIR *pDir; 
....................    char *filename; 
....................  
....................    *fsiz = 0; 
....................    filename = TryFile(fname,&hFile); 
....................    if (filename == 0)  
....................       return 1; 
....................  
....................    found = FindDirEntry(filename,hFile); 
....................    if (!found)  
....................    { 
....................       gFiles[hFile].Free = TRUE; 
....................       return 2; 
....................    } 
....................    //fprintf(debug, "getfsize - found DirEntry %lu.\r\n", gFAT32Vars.gDirEntryIdx); 
....................     
....................    pDir = (DIR*)(&(DIR_BUFFER[32*gFAT32Vars.gDirEntryIdx])); 
....................    gFiles[hFile].Free = TRUE; 
....................    *fsiz = pDir->wSize; 
....................    return 0; 
.................... } 
....................  
....................  
....................  
.................... HANDLE hFile=0xff; 
.................... char gfilename[32]; 
....................  
.................... #define LCD_BKLT   PIN_G0 
.................... #define SENSOR_ENX   PIN_F7 
.................... #define BT_RST   PIN_G4 
.................... #define MEM_CS   PIN_F6 
.................... #define HMC_RESET   PIN_F5 
.................... #define POWER_OFF   PIN_F2 
.................... #define CHARGE_IND   PIN_A5 
.................... #define GPS_EN   PIN_A4 
.................... #define SD_DETECT   PIN_D4 
.................... #define SD_PWR   PIN_D7 
.................... #define KEY_POWER   PIN_B0 
.................... #define KEY_DOWN   PIN_B1 
.................... #define KEY_CENTER   PIN_B2 
.................... #define KEY_LEFT   PIN_B3 
.................... #define KEY_RIGHT   PIN_B4 
.................... #define KEY_UP      PIN_B5 
.................... #define SD_CS      PIN_C2 
....................  
.................... #define ADCCH_BATT   0   //ADC Channel: Battery voltage 
.................... #define ADCCH_HMCA   1   //ADC Channel: HMC Out A 
.................... #define ADCCH_HMCB   2   //ADC Channel: HMC Out B 
.................... #define ADCCH_TEMP   3   //ADC Channel: Temperature 
....................  
.................... double fVLDO = 2.9833; 
....................  
.................... float fStandardPressure = 101.96;   //Sea level pressure 101.325(kPa)  
....................  
.................... #include "ADS11xx.c" 
.................... #ifndef ADS11XX_H 
.................... #define ADS11XX_H 
....................  
....................  
.................... // Conversion Mode 
.................... #define ADS11XX_SINGLE_CONVERSION	0x10 
.................... #define ADS11XX_CONTINUOUS_CONVERSION	0x00 
....................  
.................... // Effective Bits 
.................... #define ADS11XX_12_BITS		0x00	//128 SPS 
.................... #define ADS11XX_14_BITS		0x04	//32 SPS 
.................... #define ADS11XX_15_BITS		0x08	//16 SPS 
.................... #define ADS11XX_16_BITS		0x0C	// 8 SPS 
....................  
.................... // Onchip OP gain 
.................... #define ADS11XX_PGA_1		0x00 
.................... #define ADS11XX_PGA_2		0x01 
.................... #define ADS11XX_PGA_4		0x02 
.................... #define ADS11XX_PGA_8		0x03 
....................  
.................... //for ADS1112 input selection 
.................... #define ADS11XX_INP_0		0x00	//AIN0, AIN1 
.................... #define ADS11XX_INP_1		0x20	//AIN2, AIN3 
.................... #define ADS11XX_INP_2		0x40	//AIN0, AIN3 
.................... #define ADS11XX_INP_3		0x60	//AIN1, AIN3 
....................  
.................... #SEPARATE 
.................... void ADS11XX_Init( int nAddress, int configByte) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(nAddress);           // Send the address of the device 
.................... 	i2c_write(configByte); 
....................  
.................... 	i2c_stop(); 
.................... } 
.................... #SEPARATE 
.................... int ADS11XX_ReadConfig(int nAddress) 
.................... { 
.................... 	int tmp; 
....................  
.................... 	i2c_start(); 
....................  
.................... 	tmp = i2c_write(nAddress| 0x01);           // Send the address of the device 
....................  
.................... 	tmp = i2c_read(1);      // Ignore the output data 
.................... 	tmp = i2c_read(1);      // Ignore the output data 
....................  
.................... 	tmp = i2c_read(1); 
....................  
.................... 	i2c_stop(); 
....................  
.................... 	return tmp; 
.................... } 
.................... #SEPARATE 
.................... long ADS11XX_ReadData(int nAddress) 
.................... { 
.................... 	long ad_val; 
.................... 	int tmp; 
....................  
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(nAddress | 0x01);           // Send the address of the device 
....................  
.................... 	ad_val = i2c_read(1);    // High byte of data 
.................... 	tmp = i2c_read(1);      // Low byte of data 
.................... 	i2c_read(1);		//skip config data 
....................  
.................... 	i2c_stop(); 
....................  
.................... 	ad_val <<= 8; 
.................... 	ad_val += tmp; 
....................  
....................  
.................... 	return ad_val; 
.................... } 
.................... #endif 
....................  
....................  
.................... #define ADS1112_ADDRESS 0x9A 
.................... #define ADS1112_CONFIG   (ADS11XX_CONTINUOUS_CONVERSION | ADS11XX_16_BITS | ADS11XX_PGA_8) 
....................  
.................... int g_nKeyNewState; 
.................... #define KB_POWER   0x01 
.................... #define KB_DOWN   0x02 
.................... #define KB_CENTER   0x04 
.................... #define KB_LEFT   0x08 
.................... #define KB_RIGHT   0x10 
.................... #define KB_UP      0x20 
....................  
.................... int g_bBKLight = 1; 
.................... int16 nLEDTimer = 500; 
.................... int nSampleTimer = 100; 
.................... int16 g_nTimerTick=0; 
.................... int16 g_nPwrBtnHoldTick=0; 
....................  
.................... #include "gpsParser.c" 
.................... //#define _DEBUG 
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define GPS_BUFFER_LEN   512 
....................  
.................... char GPSBuffer[GPS_BUFFER_LEN]; 
.................... int16 g_nGPSBufferWritePtr=0;   //Write pointer 
.................... int16 g_nGPSBufferReadPtr=0;   //Read pointer 
.................... int16 g_nGPSBufferEOLPtr=0;      //End of line pointer 
.................... int g_nGPSSentences=0;      //Number of sentences in buffer 
.................... int g_nGPSOverlapped = 0; 
....................  
.................... #define GPS_INC_READPTR(n)   (g_nGPSBufferReadPtr = (g_nGPSBufferReadPtr + (n))%GPS_BUFFER_LEN) 
.................... #define GPS_INC_WRITEPTR(n)   (g_nGPSBufferWritePtr = (g_nGPSBufferWritePtr + (n))%GPS_BUFFER_LEN) 
....................  
.................... #define LOG_FLAG_DISCARD_ZERO_KHM   0x01 
....................  
.................... /* 
.................... typedef struct 
.................... { 
....................    TimeRecord tStartTime; 
....................    TimeRecord tEndTime; 
....................    int32   nDistance; 
....................    float fMaxSpeed; 
....................    float fMaxAltitude; 
....................    float fMinAltitude; 
.................... }LOG_SESSION; 
.................... LOG_SESSION gLogSession; 
.................... */ 
.................... int nStillSecCount=0;   //Start counting when fSpeed=0 
....................  
.................... typedef struct 
.................... { 
....................    int nSatID; 
....................    int nSatSNR; 
.................... }SATINFO; 
....................  
.................... SATINFO satData; 
....................  
.................... typedef struct 
.................... { 
....................    int bFixed; 
....................    TimeRecord time; 
....................    int32 nLatitude; 
....................    float fLatitude; 
....................    char northSouth; 
....................    int32 nLongitude; 
....................    float fLongitude; 
....................    char eastWest; 
....................    int32 nSpeed; 
....................    float fSpeed; 
....................    long direction; 
....................    int numSat;   //Number of satellite 
....................    signed int32 nAltitude; 
....................    float fAltitude; 
....................    int fixType;    //1:Not fixed, 2: 2D, 3:3D 
....................    int satSNR[32]; //Satellite signal level : 0xFF:Not in sky, 0x80~0xFE: Fixed, 0x00~0x7F: Not fixed 
.................... }GPSDATA; 
....................  
.................... float fAccDistance=0; 
....................  
.................... GPSDATA recGPSData; 
....................  
.................... char GPSFlag = 1; 
....................  
.................... #bit g_bGPStoBT=GPSFlag.0   //Send GPS sentence to Bluetooth port 
.................... #bit g_bGPSNewSentence=GPSFlag.1 
.................... #bit g_bGPSFixed = GPSFlag.2 
.................... #bit g_bGPSDataReady = GPSFlag.3   //End of all one second sentences. normally end with $GPVTG 
.................... #bit g_bGPSOverlapped = GPSFlag.4 
....................  
.................... int16 g_nTickNewData = 0; 
....................  
.................... enum{ 
....................    GPS_STATE_IDLE = 0, 
....................    GPS_STATE_NEWSENTENCE, 
....................    GPS_STATE_GPGGA, 
....................    GPS_STATE_GPRMC, 
....................    GPS_STATE_GPGSA, 
....................    GPS_STATE_GPGSV, 
....................    GPS_STATE_GPVTG 
.................... }; 
....................  
....................  
.................... int g_nGPSState = GPS_STATE_IDLE; 
.................... int g_nGPSReceived = 0; 
.................... int g_nGPSParamIndex = 0; 
.................... int g_bGPSNumSign = 0; 
....................  
.................... void gps_ResetSatelliteSignal(); 
....................  
.................... #int_RDA HIGH 
.................... void GPS_isr() 
.................... { 
....................    int ch; 
....................    static char chKeyword[5]; 
....................     
....................    ch = fgetc(GPS);   //Get one char from GPS 
*
0079E:  BRA    0734
007A0:  MOVFF  01,A20
....................     
.................... //   if(g_bGPStoBT) 
.................... //      fputc(ch, BT_232); 
....................     
....................    if(ch == 0x0D) 
007A4:  MOVLB  A
007A6:  MOVF   x20,W
007A8:  SUBLW  0D
007AA:  BNZ   07B4
....................    { 
....................       g_nGPSState = GPS_STATE_IDLE; 
007AC:  MOVLB  9
007AE:  CLRF   x79
....................       return; 
007B0:  BRA    0E4E
007B2:  MOVLB  A
....................    } 
....................     
....................    switch(g_nGPSState) 
....................    { 
007B4:  MOVLB  9
007B6:  MOVF   x79,W
007B8:  ADDLW  F9
007BA:  BTFSC  FD8.0
007BC:  BRA    0E4E
007BE:  ADDLW  07
007C0:  MOVLB  0
007C2:  GOTO   0F94
....................       case GPS_STATE_IDLE: 
....................          if(ch == '$') 
007C6:  MOVLB  A
007C8:  MOVF   x20,W
007CA:  SUBLW  24
007CC:  BNZ   07D6
....................          { 
....................             g_nGPSState = GPS_STATE_NEWSENTENCE; 
007CE:  MOVLW  01
007D0:  MOVLB  9
007D2:  MOVWF  x79
....................             g_nGPSReceived = 0; 
007D4:  CLRF   x7A
....................          } 
....................          break; 
007D6:  MOVLB  9
007D8:  BRA    0E4E
....................       case GPS_STATE_NEWSENTENCE: 
....................          chKeyword[g_nGPSReceived++] = ch; 
007DA:  MOVLB  9
007DC:  MOVF   x7A,W
007DE:  INCF   x7A,F
007E0:  CLRF   03
007E2:  ADDLW  7D
007E4:  MOVWF  FE9
007E6:  MOVLW  09
007E8:  ADDWFC 03,W
007EA:  MOVWF  FEA
007EC:  MOVFF  A20,FEF
....................          if(g_nGPSReceived == 5)   //Received GPGGA/GPRMC/GPGSA/GPGSV/GPVTG 
007F0:  MOVF   x7A,W
007F2:  SUBLW  05
007F4:  BNZ   0856
....................          { 
....................             if(chKeyword[3] == 'G' && chKeyword[4] == 'A')   //GPGGA 
007F6:  MOVF   x80,W
007F8:  SUBLW  47
007FA:  BNZ   0808
007FC:  MOVF   x81,W
007FE:  SUBLW  41
00800:  BNZ   0808
....................                g_nGPSState = GPS_STATE_GPGGA; 
00802:  MOVLW  02
00804:  MOVWF  x79
....................             else if(chKeyword[3] == 'M' && chKeyword[4] == 'C')   //GPRMC 
00806:  BRA    0852
00808:  MOVF   x80,W
0080A:  SUBLW  4D
0080C:  BNZ   081A
0080E:  MOVF   x81,W
00810:  SUBLW  43
00812:  BNZ   081A
....................                g_nGPSState = GPS_STATE_GPRMC; 
00814:  MOVLW  03
00816:  MOVWF  x79
....................             else if(chKeyword[3] == 'S' && chKeyword[4] == 'A')   //GPGSA 
00818:  BRA    0852
0081A:  MOVF   x80,W
0081C:  SUBLW  53
0081E:  BNZ   082C
00820:  MOVF   x81,W
00822:  SUBLW  41
00824:  BNZ   082C
....................                g_nGPSState = GPS_STATE_GPGSA; 
00826:  MOVLW  04
00828:  MOVWF  x79
....................             else if(chKeyword[3] == 'S' && chKeyword[4] == 'V')   //GPGSV 
0082A:  BRA    0852
0082C:  MOVF   x80,W
0082E:  SUBLW  53
00830:  BNZ   083E
00832:  MOVF   x81,W
00834:  SUBLW  56
00836:  BNZ   083E
....................                g_nGPSState = GPS_STATE_GPGSV; 
00838:  MOVLW  05
0083A:  MOVWF  x79
....................             else if(chKeyword[3] == 'T' && chKeyword[4] == 'G')   //GPVTG 
0083C:  BRA    0852
0083E:  MOVF   x80,W
00840:  SUBLW  54
00842:  BNZ   0850
00844:  MOVF   x81,W
00846:  SUBLW  47
00848:  BNZ   0850
....................                g_nGPSState = GPS_STATE_GPVTG; 
0084A:  MOVLW  06
0084C:  MOVWF  x79
....................             else 
0084E:  BRA    0852
....................                g_nGPSState = GPS_STATE_IDLE;   //Unknown keyword 
00850:  CLRF   x79
....................              
....................             //Initialize GPS sentence variables    
....................             g_nGPSReceived = 0; 
00852:  CLRF   x7A
....................             g_nGPSParamIndex = 0; 
00854:  CLRF   x7B
....................          } 
....................          break; 
00856:  BRA    0E4E
....................       case GPS_STATE_GPGGA: 
....................          if(ch == 0x0A || ch == '*')   //End of sentence 
00858:  MOVLB  A
0085A:  MOVF   x20,W
0085C:  SUBLW  0A
0085E:  BZ    0866
00860:  MOVF   x20,W
00862:  SUBLW  2A
00864:  BNZ   086E
....................             g_nGPSState = GPS_STATE_IDLE; 
00866:  MOVLB  9
00868:  CLRF   x79
....................          else if(ch == ',')   //Next param 
0086A:  BRA    0930
0086C:  MOVLB  A
0086E:  MOVF   x20,W
00870:  SUBLW  2C
00872:  BNZ   0880
....................          { 
....................             g_nGPSParamIndex++; 
00874:  MOVLB  9
00876:  INCF   x7B,F
....................             g_nGPSReceived = 0; 
00878:  CLRF   x7A
....................             g_bGPSNumSign = 0; 
0087A:  CLRF   x7C
....................          } 
....................         else 
0087C:  BRA    0930
0087E:  MOVLB  A
....................          { 
....................             switch(g_nGPSParamIndex)   //Starts from 1 
....................             { 
00880:  MOVLW  01
00882:  MOVLB  9
00884:  SUBWF  x7B,W
00886:  ADDLW  F7
00888:  BC    0930
0088A:  ADDLW  09
0088C:  MOVLB  0
0088E:  GOTO   0E56
....................                case 1:   //time 
....................                   break; 
00892:  MOVLB  9
00894:  BRA    0930
....................                case 2:   //fLatitude 
....................                   break; 
00896:  MOVLB  9
00898:  BRA    0930
....................                case 3:   //N/S 
....................                   break; 
0089A:  MOVLB  9
0089C:  BRA    0930
....................                case 4:   //Longitude 
....................                   break; 
0089E:  MOVLB  9
008A0:  BRA    0930
....................                case 5:   //W/E 
....................                   break; 
008A2:  MOVLB  9
008A4:  BRA    0930
....................                case 6:   //1: Fixed, 0:Fix not avalable 
....................                   //memset(&recGPSData, sizeof(GPSDATA), 0); 
....................                   if(ch == '1') 
008A6:  MOVLB  A
008A8:  MOVF   x20,W
008AA:  SUBLW  31
008AC:  BNZ   08B6
....................                      recGPSData.bFixed = 1; 
008AE:  MOVLW  01
008B0:  MOVLB  9
008B2:  MOVWF  x27
....................                   else 
008B4:  BRA    08BA
....................                      recGPSData.bFixed = 0; 
008B6:  MOVLB  9
008B8:  CLRF   x27
....................                   g_bGPSFixed = recGPSData.bFixed; 
008BA:  BCF    x76.2
008BC:  BTFSC  x27.0
008BE:  BSF    x76.2
....................                   break; 
008C0:  BRA    0930
....................                case 7:   //Number of satellites 
....................                      if(g_nGPSReceived == 0) 
008C2:  MOVLB  9
008C4:  MOVF   x7A,F
008C6:  BNZ   08D4
....................                      { 
....................                         recGPSData.numSat = ch - '0'; 
008C8:  MOVLW  30
008CA:  MOVLB  A
008CC:  SUBWF  x20,W
008CE:  MOVLB  9
008D0:  MOVWF  x4C
....................                   } 
....................                   else 
008D2:  BRA    08E6
....................                   { 
....................                      recGPSData.numSat *= 10; 
008D4:  MOVF   x4C,W
008D6:  MULLW  0A
008D8:  MOVFF  FF3,94C
....................                      recGPSData.numSat += ch - '0'; 
008DC:  MOVLW  30
008DE:  MOVLB  A
008E0:  SUBWF  x20,W
008E2:  MOVLB  9
008E4:  ADDWF  x4C,F
....................                    } 
....................                     
....................                    g_nGPSReceived++; 
008E6:  INCF   x7A,F
....................                   break; 
008E8:  BRA    0930
....................                case 8:    
....................                   break; 
008EA:  MOVLB  9
008EC:  BRA    0930
....................                case 9:   //Altitude 
....................                   if(ch == '-') 
008EE:  MOVLB  A
008F0:  MOVF   x20,W
008F2:  SUBLW  2D
008F4:  BNZ   0900
....................                         g_bGPSNumSign = 1; 
008F6:  MOVLW  01
008F8:  MOVLB  9
008FA:  MOVWF  x7C
....................                   else 
008FC:  BRA    092C
008FE:  MOVLB  A
....................                   { 
....................                      //recGPSData.nAltitude = (recGPSData.nAltitude<<3) + (recGPSData.nAltitude<<1);      //*10 
....................                      if(g_bGPSNumSign) 
00900:  MOVLB  9
00902:  MOVF   x7C,F
00904:  BZ    091A
....................                         recGPSData.nAltitude -= ch - '0'; 
00906:  MOVLW  30
00908:  MOVLB  A
0090A:  SUBWF  x20,W
0090C:  MOVLB  9
0090E:  SUBWF  x4D,F
00910:  MOVLW  00
00912:  SUBWFB x4E,F
00914:  SUBWFB x4F,F
00916:  SUBWFB x50,F
....................                      else 
00918:  BRA    092C
....................                         recGPSData.nAltitude += ch - '0'; 
0091A:  MOVLW  30
0091C:  MOVLB  A
0091E:  SUBWF  x20,W
00920:  MOVLB  9
00922:  ADDWF  x4D,F
00924:  MOVLW  00
00926:  ADDWFC x4E,F
00928:  ADDWFC x4F,F
0092A:  ADDWFC x50,F
....................                   } 
....................                   break; 
0092C:  BRA    0930
0092E:  MOVLB  9
....................             } //switch(g_nGPSParamIndex)                                   
....................          } 
....................         break; 
00930:  BRA    0E4E
....................       case GPS_STATE_GPRMC: 
....................           if(ch == 0x0A || ch == '*')   //End of sentence 
00932:  MOVLB  A
00934:  MOVF   x20,W
00936:  SUBLW  0A
00938:  BZ    0940
0093A:  MOVF   x20,W
0093C:  SUBLW  2A
0093E:  BNZ   0948
....................             g_nGPSState = GPS_STATE_IDLE; 
00940:  MOVLB  9
00942:  CLRF   x79
....................          else if(ch == ',')   //Next param 
00944:  BRA    0CA6
00946:  MOVLB  A
00948:  MOVF   x20,W
0094A:  SUBLW  2C
0094C:  BNZ   095A
....................          { 
....................             g_nGPSParamIndex++; 
0094E:  MOVLB  9
00950:  INCF   x7B,F
....................             g_nGPSReceived = 0; 
00952:  CLRF   x7A
....................             g_bGPSNumSign = 0; 
00954:  CLRF   x7C
....................          } 
....................          else 
00956:  BRA    0CA6
00958:  MOVLB  A
....................          { 
....................             switch(g_nGPSParamIndex)   //Starts from 1 
....................             { 
0095A:  MOVLW  01
0095C:  MOVLB  9
0095E:  SUBWF  x7B,W
00960:  ADDLW  F7
00962:  BTFSC  FD8.0
00964:  BRA    0CA6
00966:  ADDLW  09
00968:  MOVLB  0
0096A:  GOTO   0EE0
....................                case 1:   //time 
....................                     switch(g_nGPSReceived) 
....................                     { 
0096E:  MOVLB  9
00970:  MOVF   x7A,W
00972:  ADDLW  FA
00974:  BC    09E0
00976:  ADDLW  06
00978:  MOVLB  0
0097A:  GOTO   0E88
....................                           case 0:   //Hour 
....................                              recGPSData.time.tm_hour = ch - '0'; 
0097E:  MOVLW  30
00980:  MOVLB  A
00982:  SUBWF  x20,W
00984:  MOVLB  9
00986:  MOVWF  x2D
....................                              recGPSData.time.tm_hour *= 10; 
00988:  MOVF   x2D,W
0098A:  MULLW  0A
0098C:  MOVFF  FF3,92D
....................                              break; 
00990:  BRA    09E0
....................                           case 1: 
....................                              recGPSData.time.tm_hour += ch - '0'; 
00992:  MOVLW  30
00994:  MOVLB  A
00996:  SUBWF  x20,W
00998:  MOVLB  9
0099A:  ADDWF  x2D,F
....................                              break; 
0099C:  BRA    09E0
....................                           case 2: 
....................                              recGPSData.time.tm_min =  ch - '0'; 
0099E:  MOVLW  30
009A0:  MOVLB  A
009A2:  SUBWF  x20,W
009A4:  MOVLB  9
009A6:  MOVWF  x2E
....................                              recGPSData.time.tm_min *= 10; 
009A8:  MOVF   x2E,W
009AA:  MULLW  0A
009AC:  MOVFF  FF3,92E
....................                              break; 
009B0:  BRA    09E0
....................                           case 3: 
....................                              recGPSData.time.tm_min += ch - '0'; 
009B2:  MOVLW  30
009B4:  MOVLB  A
009B6:  SUBWF  x20,W
009B8:  MOVLB  9
009BA:  ADDWF  x2E,F
....................                              break; 
009BC:  BRA    09E0
....................                           case 4: 
....................                              recGPSData.time.tm_sec =  ch - '0'; 
009BE:  MOVLW  30
009C0:  MOVLB  A
009C2:  SUBWF  x20,W
009C4:  MOVLB  9
009C6:  MOVWF  x2F
....................                               recGPSData.time.tm_sec *= 10; 
009C8:  MOVF   x2F,W
009CA:  MULLW  0A
009CC:  MOVFF  FF3,92F
....................                             break; 
009D0:  BRA    09E0
....................                           case 5: 
....................                              recGPSData.time.tm_sec += ch - '0'; 
009D2:  MOVLW  30
009D4:  MOVLB  A
009D6:  SUBWF  x20,W
009D8:  MOVLB  9
009DA:  ADDWF  x2F,F
....................                              break; 
009DC:  BRA    09E0
009DE:  MOVLB  9
....................                        } 
....................                         
....................                        g_nGPSReceived++; 
009E0:  INCF   x7A,F
....................                               
....................                   break; 
009E2:  BRA    0CA6
....................                case 2:   //A=data valid or V=data not valid 
....................                      if(ch != 'A') 
009E4:  MOVLB  A
009E6:  MOVF   x20,W
009E8:  SUBLW  41
009EA:  BZ    09F0
....................                         g_nGPSState = GPS_STATE_IDLE; 
009EC:  MOVLB  9
009EE:  CLRF   x79
....................                recGPSData.nLatitude = 0; 
009F0:  MOVLB  9
009F2:  CLRF   x33
009F4:  CLRF   x32
009F6:  CLRF   x31
009F8:  CLRF   x30
....................                   recGPSData.nLongitude = 0; 
009FA:  CLRF   x3C
009FC:  CLRF   x3B
009FE:  CLRF   x3A
00A00:  CLRF   x39
....................                   recGPSData.nSpeed = 0; 
00A02:  CLRF   x45
00A04:  CLRF   x44
00A06:  CLRF   x43
00A08:  CLRF   x42
....................                  
....................                   break; 
00A0A:  BRA    0CA6
....................                case 3:   //Latitude 
....................                      recGPSData.nLatitude = (recGPSData.nLatitude<<3) + (recGPSData.nLatitude<<1);    //*10 
00A0C:  MOVLB  9
00A0E:  RLCF   x30,W
00A10:  MOVLB  A
00A12:  MOVWF  x22
00A14:  MOVLB  9
00A16:  RLCF   x31,W
00A18:  MOVLB  A
00A1A:  MOVWF  x23
00A1C:  MOVLB  9
00A1E:  RLCF   x32,W
00A20:  MOVLB  A
00A22:  MOVWF  x24
00A24:  MOVLB  9
00A26:  RLCF   x33,W
00A28:  MOVLB  A
00A2A:  MOVWF  x25
00A2C:  RLCF   x22,F
00A2E:  RLCF   x23,F
00A30:  RLCF   x24,F
00A32:  RLCF   x25,F
00A34:  RLCF   x22,F
00A36:  RLCF   x23,F
00A38:  RLCF   x24,F
00A3A:  RLCF   x25,F
00A3C:  MOVLW  F8
00A3E:  ANDWF  x22,F
00A40:  BCF    FD8.0
00A42:  MOVLB  9
00A44:  RLCF   x30,W
00A46:  MOVWF  00
00A48:  RLCF   x31,W
00A4A:  MOVWF  01
00A4C:  RLCF   x32,W
00A4E:  MOVWF  02
00A50:  RLCF   x33,W
00A52:  MOVWF  03
00A54:  MOVF   00,W
00A56:  MOVLB  A
00A58:  ADDWF  x22,W
00A5A:  MOVLB  9
00A5C:  MOVWF  x30
00A5E:  MOVF   01,W
00A60:  MOVLB  A
00A62:  ADDWFC x23,W
00A64:  MOVLB  9
00A66:  MOVWF  x31
00A68:  MOVF   02,W
00A6A:  MOVLB  A
00A6C:  ADDWFC x24,W
00A6E:  MOVLB  9
00A70:  MOVWF  x32
00A72:  MOVF   03,W
00A74:  MOVLB  A
00A76:  ADDWFC x25,W
00A78:  MOVLB  9
00A7A:  MOVWF  x33
....................                      recGPSData.nLatitude += ch - '0'; 
00A7C:  MOVLW  30
00A7E:  MOVLB  A
00A80:  SUBWF  x20,W
00A82:  MOVLB  9
00A84:  ADDWF  x30,F
00A86:  MOVLW  00
00A88:  ADDWFC x31,F
00A8A:  ADDWFC x32,F
00A8C:  ADDWFC x33,F
....................                   break; 
00A8E:  BRA    0CA6
....................                case 4:   //N/S 
....................                      recGPSData.northSouth = ch; 
00A90:  MOVFF  A20,938
....................                      break; 
00A94:  MOVLB  9
00A96:  BRA    0CA6
....................                case 5:   //Longitude 
....................                    recGPSData.nLongitude = (recGPSData.nLongitude<<3) + (recGPSData.nLongitude<<1);    //*10 
00A98:  MOVLB  9
00A9A:  RLCF   x39,W
00A9C:  MOVLB  A
00A9E:  MOVWF  x22
00AA0:  MOVLB  9
00AA2:  RLCF   x3A,W
00AA4:  MOVLB  A
00AA6:  MOVWF  x23
00AA8:  MOVLB  9
00AAA:  RLCF   x3B,W
00AAC:  MOVLB  A
00AAE:  MOVWF  x24
00AB0:  MOVLB  9
00AB2:  RLCF   x3C,W
00AB4:  MOVLB  A
00AB6:  MOVWF  x25
00AB8:  RLCF   x22,F
00ABA:  RLCF   x23,F
00ABC:  RLCF   x24,F
00ABE:  RLCF   x25,F
00AC0:  RLCF   x22,F
00AC2:  RLCF   x23,F
00AC4:  RLCF   x24,F
00AC6:  RLCF   x25,F
00AC8:  MOVLW  F8
00ACA:  ANDWF  x22,F
00ACC:  BCF    FD8.0
00ACE:  MOVLB  9
00AD0:  RLCF   x39,W
00AD2:  MOVWF  00
00AD4:  RLCF   x3A,W
00AD6:  MOVWF  01
00AD8:  RLCF   x3B,W
00ADA:  MOVWF  02
00ADC:  RLCF   x3C,W
00ADE:  MOVWF  03
00AE0:  MOVF   00,W
00AE2:  MOVLB  A
00AE4:  ADDWF  x22,W
00AE6:  MOVLB  9
00AE8:  MOVWF  x39
00AEA:  MOVF   01,W
00AEC:  MOVLB  A
00AEE:  ADDWFC x23,W
00AF0:  MOVLB  9
00AF2:  MOVWF  x3A
00AF4:  MOVF   02,W
00AF6:  MOVLB  A
00AF8:  ADDWFC x24,W
00AFA:  MOVLB  9
00AFC:  MOVWF  x3B
00AFE:  MOVF   03,W
00B00:  MOVLB  A
00B02:  ADDWFC x25,W
00B04:  MOVLB  9
00B06:  MOVWF  x3C
....................                      recGPSData.nLongitude += ch - '0'; 
00B08:  MOVLW  30
00B0A:  MOVLB  A
00B0C:  SUBWF  x20,W
00B0E:  MOVLB  9
00B10:  ADDWF  x39,F
00B12:  MOVLW  00
00B14:  ADDWFC x3A,F
00B16:  ADDWFC x3B,F
00B18:  ADDWFC x3C,F
....................                  break; 
00B1A:  BRA    0CA6
....................                case 6:   //W/E 
....................                      recGPSData.eastWest = ch; 
00B1C:  MOVFF  A20,941
....................                   break; 
00B20:  MOVLB  9
00B22:  BRA    0CA6
....................                case 7:   //Speed 
....................                    recGPSData.nSpeed = (recGPSData.nSpeed<<3) + (recGPSData.nSpeed<<1);    //*10 
00B24:  MOVLB  9
00B26:  RLCF   x42,W
00B28:  MOVLB  A
00B2A:  MOVWF  x22
00B2C:  MOVLB  9
00B2E:  RLCF   x43,W
00B30:  MOVLB  A
00B32:  MOVWF  x23
00B34:  MOVLB  9
00B36:  RLCF   x44,W
00B38:  MOVLB  A
00B3A:  MOVWF  x24
00B3C:  MOVLB  9
00B3E:  RLCF   x45,W
00B40:  MOVLB  A
00B42:  MOVWF  x25
00B44:  RLCF   x22,F
00B46:  RLCF   x23,F
00B48:  RLCF   x24,F
00B4A:  RLCF   x25,F
00B4C:  RLCF   x22,F
00B4E:  RLCF   x23,F
00B50:  RLCF   x24,F
00B52:  RLCF   x25,F
00B54:  MOVLW  F8
00B56:  ANDWF  x22,F
00B58:  BCF    FD8.0
00B5A:  MOVLB  9
00B5C:  RLCF   x42,W
00B5E:  MOVWF  00
00B60:  RLCF   x43,W
00B62:  MOVWF  01
00B64:  RLCF   x44,W
00B66:  MOVWF  02
00B68:  RLCF   x45,W
00B6A:  MOVWF  03
00B6C:  MOVF   00,W
00B6E:  MOVLB  A
00B70:  ADDWF  x22,W
00B72:  MOVLB  9
00B74:  MOVWF  x42
00B76:  MOVF   01,W
00B78:  MOVLB  A
00B7A:  ADDWFC x23,W
00B7C:  MOVLB  9
00B7E:  MOVWF  x43
00B80:  MOVF   02,W
00B82:  MOVLB  A
00B84:  ADDWFC x24,W
00B86:  MOVLB  9
00B88:  MOVWF  x44
00B8A:  MOVF   03,W
00B8C:  MOVLB  A
00B8E:  ADDWFC x25,W
00B90:  MOVLB  9
00B92:  MOVWF  x45
....................                      recGPSData.nSpeed += ch - '0'; 
00B94:  MOVLW  30
00B96:  MOVLB  A
00B98:  SUBWF  x20,W
00B9A:  MOVLB  9
00B9C:  ADDWF  x42,F
00B9E:  MOVLW  00
00BA0:  ADDWFC x43,F
00BA2:  ADDWFC x44,F
00BA4:  ADDWFC x45,F
....................                      break; 
00BA6:  BRA    0CA6
....................                case 8:   //Direction 
....................                      if(ch == '.') 
00BA8:  MOVLB  A
00BAA:  MOVF   x20,W
00BAC:  SUBLW  2E
00BAE:  BNZ   0BB8
....................                         g_nGPSReceived = 4; 
00BB0:  MOVLW  04
00BB2:  MOVLB  9
00BB4:  MOVWF  x7A
....................                      else if(g_nGPSReceived < 3) 
00BB6:  BRA    0C08
00BB8:  MOVLB  9
00BBA:  MOVF   x7A,W
00BBC:  SUBLW  02
00BBE:  BNC   0C08
....................                      { 
....................                        recGPSData.direction = (recGPSData.direction<<3) + (recGPSData.direction<<1);    //*10 
00BC0:  RLCF   x4A,W
00BC2:  MOVLB  A
00BC4:  MOVWF  x21
00BC6:  MOVLB  9
00BC8:  RLCF   x4B,W
00BCA:  MOVLB  A
00BCC:  MOVWF  x22
00BCE:  RLCF   x21,F
00BD0:  RLCF   x22,F
00BD2:  RLCF   x21,F
00BD4:  RLCF   x22,F
00BD6:  MOVLW  F8
00BD8:  ANDWF  x21,F
00BDA:  BCF    FD8.0
00BDC:  MOVLB  9
00BDE:  RLCF   x4A,W
00BE0:  MOVWF  02
00BE2:  RLCF   x4B,W
00BE4:  MOVWF  03
00BE6:  MOVF   02,W
00BE8:  MOVLB  A
00BEA:  ADDWF  x21,W
00BEC:  MOVLB  9
00BEE:  MOVWF  x4A
00BF0:  MOVF   03,W
00BF2:  MOVLB  A
00BF4:  ADDWFC x22,W
00BF6:  MOVLB  9
00BF8:  MOVWF  x4B
....................                         recGPSData.direction += ch - '0';                    
00BFA:  MOVLW  30
00BFC:  MOVLB  A
00BFE:  SUBWF  x20,W
00C00:  MOVLB  9
00C02:  ADDWF  x4A,F
00C04:  MOVLW  00
00C06:  ADDWFC x4B,F
....................                      } 
....................                      g_nGPSReceived++; 
00C08:  INCF   x7A,F
....................                      break; 
00C0A:  BRA    0CA6
....................                   case 9:   //Date: DDMMYY 
....................                      switch(g_nGPSReceived) 
....................                      { 
00C0C:  MOVLB  9
00C0E:  MOVF   x7A,W
00C10:  ADDLW  FA
00C12:  BC    0CA2
00C14:  ADDLW  06
00C16:  MOVLB  0
00C18:  GOTO   0EB4
....................                         case 0: 
....................                            recGPSData.time.tm_day = ch - '0'; 
00C1C:  MOVLW  30
00C1E:  MOVLB  A
00C20:  SUBWF  x20,W
00C22:  MOVLB  9
00C24:  MOVWF  x2B
....................                           recGPSData.time.tm_day *= 10; 
00C26:  MOVF   x2B,W
00C28:  MULLW  0A
00C2A:  MOVFF  FF3,92B
....................                            break; 
00C2E:  BRA    0CA2
....................                        case 1: 
....................                           recGPSData.time.tm_day += ch - '0'; 
00C30:  MOVLW  30
00C32:  MOVLB  A
00C34:  SUBWF  x20,W
00C36:  MOVLB  9
00C38:  ADDWF  x2B,F
....................                           break; 
00C3A:  BRA    0CA2
....................                         case 2: 
....................                           recGPSData.time.tm_mon = ch - '0'; 
00C3C:  MOVLW  30
00C3E:  MOVLB  A
00C40:  SUBWF  x20,W
00C42:  MOVLB  9
00C44:  MOVWF  x2A
....................                           recGPSData.time.tm_mon *= 10; 
00C46:  MOVF   x2A,W
00C48:  MULLW  0A
00C4A:  MOVFF  FF3,92A
....................                           break; 
00C4E:  BRA    0CA2
....................                         case 3: 
....................                           recGPSData.time.tm_mon += ch - '0'; 
00C50:  MOVLW  30
00C52:  MOVLB  A
00C54:  SUBWF  x20,W
00C56:  MOVLB  9
00C58:  ADDWF  x2A,F
....................                           break; 
00C5A:  BRA    0CA2
....................                         case 4: 
....................                           recGPSData.time.tm_year = ch - '0'; 
00C5C:  MOVLW  30
00C5E:  MOVLB  A
00C60:  SUBWF  x20,W
00C62:  MOVLB  9
00C64:  MOVWF  x28
00C66:  CLRF   x29
....................                           recGPSData.time.tm_year *= 10; 
00C68:  MOVFF  929,A22
00C6C:  MOVFF  928,A21
00C70:  MOVLB  A
00C72:  CLRF   x24
00C74:  MOVLW  0A
00C76:  MOVWF  x23
00C78:  MOVLB  0
00C7A:  RCALL  074C
00C7C:  MOVFF  02,929
00C80:  MOVFF  01,928
....................                           break; 
00C84:  MOVLB  9
00C86:  BRA    0CA2
....................                         case 5: 
....................                           recGPSData.time.tm_year += ch - '0'; 
00C88:  MOVLW  30
00C8A:  MOVLB  A
00C8C:  SUBWF  x20,W
00C8E:  MOVLB  9
00C90:  ADDWF  x28,F
00C92:  MOVLW  00
00C94:  ADDWFC x29,F
....................                           recGPSData.time.tm_year += 2000; 
00C96:  MOVLW  D0
00C98:  ADDWF  x28,F
00C9A:  MOVLW  07
00C9C:  ADDWFC x29,F
....................                           break; 
00C9E:  BRA    0CA2
00CA0:  MOVLB  9
....................                     } 
....................                      break; 
00CA2:  BRA    0CA6
00CA4:  MOVLB  9
....................             } //switch(g_nGPSParamIndex)                                   
....................          } 
....................          break; 
00CA6:  BRA    0E4E
....................       case GPS_STATE_GPGSA: 
....................           if(ch == 0x0A || ch == '*')   //End of sentence 
00CA8:  MOVLB  A
00CAA:  MOVF   x20,W
00CAC:  SUBLW  0A
00CAE:  BZ    0CB6
00CB0:  MOVF   x20,W
00CB2:  SUBLW  2A
00CB4:  BNZ   0CBE
....................             g_nGPSState = GPS_STATE_IDLE; 
00CB6:  MOVLB  9
00CB8:  CLRF   x79
....................          else if(ch == ',')   //Next param 
00CBA:  BRA    0D42
00CBC:  MOVLB  A
00CBE:  MOVF   x20,W
00CC0:  SUBLW  2C
00CC2:  BNZ   0CD0
....................          { 
....................             g_nGPSParamIndex++; 
00CC4:  MOVLB  9
00CC6:  INCF   x7B,F
....................             g_nGPSReceived = 0; 
00CC8:  CLRF   x7A
....................             g_bGPSNumSign = 0; 
00CCA:  CLRF   x7C
....................          } 
....................          else 
00CCC:  BRA    0D42
00CCE:  MOVLB  A
....................          { 
....................             switch(g_nGPSParamIndex)   //Starts from 1 
....................             { 
00CD0:  MOVLW  01
00CD2:  MOVLB  9
00CD4:  SUBWF  x7B,W
00CD6:  ADDLW  F2
00CD8:  BC    0D42
00CDA:  ADDLW  0E
00CDC:  MOVLB  0
00CDE:  GOTO   0F12
....................                case 1:   //Mode 1 
....................                   gps_ResetSatelliteSignal(); 
00CE2:  BRA    076E
....................                   break; 
....................                case 2:   //GPS Fix Type - 1:Fix not available, 2:2D, 3:3D 
....................                      recGPSData.fixType = ch - '0'; 
00CE4:  MOVLW  30
00CE6:  MOVLB  A
00CE8:  SUBWF  x20,W
00CEA:  MOVLB  9
00CEC:  MOVWF  x55
....................                   break; 
00CEE:  BRA    0D42
....................              case 3:   //Sat in used in channel 1 
....................                case 4:   //Channel 2 
....................                case 5:   //Channel 3 
....................                case 6:   //ch 4 
....................                case 7:   //ch 4 
....................                case 8:   //ch 6 
....................                case 9:   //ch7 
....................                case 10:   //ch8 
....................                case 11:   //ch 9 
....................                case 12:   //ch10 
....................                case 13:   //ch11 
....................                case 14:   //ch12 
....................                if(g_nGPSReceived == 0) 
00CF0:  MOVLB  9
00CF2:  MOVF   x7A,F
00CF4:  BNZ   0D02
....................                   satData.nSatID = ch - '0'; 
00CF6:  MOVLW  30
00CF8:  MOVLB  A
00CFA:  SUBWF  x20,W
00CFC:  MOVLB  9
00CFE:  MOVWF  x21
....................                else if(g_nGPSReceived == 1) 
00D00:  BRA    0D3C
00D02:  DECFSZ x7A,W
00D04:  BRA    0D3C
....................                { 
....................                   satData.nSatID *= 10; 
00D06:  MOVF   x21,W
00D08:  MULLW  0A
00D0A:  MOVFF  FF3,921
....................                   satData.nSatID += ch - '0'; 
00D0E:  MOVLW  30
00D10:  MOVLB  A
00D12:  SUBWF  x20,W
00D14:  MOVLB  9
00D16:  ADDWF  x21,F
....................                   if(satData.nSatID <= 32) 
00D18:  MOVF   x21,W
00D1A:  SUBLW  20
00D1C:  BNC   0D3C
....................                      recGPSData.satSNR[satData.nSatID-1] = 0x80; 
00D1E:  MOVLW  01
00D20:  SUBWF  x21,W
00D22:  CLRF   03
00D24:  ADDLW  2F
00D26:  MOVWF  01
00D28:  MOVLW  00
00D2A:  ADDWFC 03,F
00D2C:  MOVF   01,W
00D2E:  ADDLW  27
00D30:  MOVWF  FE9
00D32:  MOVLW  09
00D34:  ADDWFC 03,W
00D36:  MOVWF  FEA
00D38:  MOVLW  80
00D3A:  MOVWF  FEF
....................                } 
....................                 
....................                g_nGPSReceived++; 
00D3C:  INCF   x7A,F
....................                      break; 
00D3E:  BRA    0D42
00D40:  MOVLB  9
....................             
....................             } //switch(g_nGPSParamIndex)                                   
....................          } 
....................          break; 
00D42:  BRA    0E4E
....................       case GPS_STATE_GPGSV: 
....................           if(ch == 0x0A || ch == '*')   //End of sentence 
00D44:  MOVLB  A
00D46:  MOVF   x20,W
00D48:  SUBLW  0A
00D4A:  BZ    0D52
00D4C:  MOVF   x20,W
00D4E:  SUBLW  2A
00D50:  BNZ   0D5A
....................             g_nGPSState = GPS_STATE_IDLE; 
00D52:  MOVLB  9
00D54:  CLRF   x79
....................          else if(ch == ',')   //Next param 
00D56:  BRA    0E42
00D58:  MOVLB  A
00D5A:  MOVF   x20,W
00D5C:  SUBLW  2C
00D5E:  BNZ   0D6C
....................          { 
....................             g_nGPSParamIndex++; 
00D60:  MOVLB  9
00D62:  INCF   x7B,F
....................             g_nGPSReceived = 0; 
00D64:  CLRF   x7A
....................             g_bGPSNumSign = 0; 
00D66:  CLRF   x7C
....................          } 
....................          else 
00D68:  BRA    0E42
00D6A:  MOVLB  A
....................          { 
....................             switch(g_nGPSParamIndex)   //Starts from 1 
....................             { 
00D6C:  MOVLW  01
00D6E:  MOVLB  9
00D70:  SUBWF  x7B,W
00D72:  ADDLW  ED
00D74:  BC    0E42
00D76:  ADDLW  13
00D78:  MOVLB  0
00D7A:  GOTO   0F4E
....................                case 1:   //Number of GPGSV message 
....................                   satData.nSatID = 0; 
00D7E:  MOVLB  9
00D80:  CLRF   x21
....................                   satData.nSatSNR = 0;    
00D82:  CLRF   x22
....................                   break; 
00D84:  BRA    0E42
....................                case 2:   //Current GPGSV message number 
....................                   break; 
00D86:  MOVLB  9
00D88:  BRA    0E42
....................                case 3:   //Number of sat 
....................                   break; 
00D8A:  MOVLB  9
00D8C:  BRA    0E42
....................                case 4:   // Sat index 
....................                case 8: 
....................                case 12: 
....................                case 16: 
....................                      if(g_nGPSReceived == 0) 
00D8E:  MOVLB  9
00D90:  MOVF   x7A,F
00D92:  BNZ   0DA2
....................                      { 
....................                         satData.nSatID = ch - '0'; 
00D94:  MOVLW  30
00D96:  MOVLB  A
00D98:  SUBWF  x20,W
00D9A:  MOVLB  9
00D9C:  MOVWF  x21
....................                         satData.nSatSNR = 0;    
00D9E:  CLRF   x22
....................                      } 
....................                      else if(g_nGPSReceived == 1) 
00DA0:  BRA    0DE0
00DA2:  DECFSZ x7A,W
00DA4:  BRA    0DE0
....................                      { 
....................                         satData.nSatID *= 10; 
00DA6:  MOVF   x21,W
00DA8:  MULLW  0A
00DAA:  MOVFF  FF3,921
....................                         satData.nSatID += ch - '0'; 
00DAE:  MOVLW  30
00DB0:  MOVLB  A
00DB2:  SUBWF  x20,W
00DB4:  MOVLB  9
00DB6:  ADDWF  x21,F
....................                          if(satData.nSatID <= 32 && satData.nSatID > 0) 
00DB8:  MOVF   x21,W
00DBA:  SUBLW  20
00DBC:  BNC   0DE0
00DBE:  MOVF   x21,F
00DC0:  BZ    0DE0
....................                            recGPSData.satSNR[satData.nSatID-1] = satData.nSatSNR; 
00DC2:  MOVLW  01
00DC4:  SUBWF  x21,W
00DC6:  CLRF   03
00DC8:  ADDLW  2F
00DCA:  MOVWF  01
00DCC:  MOVLW  00
00DCE:  ADDWFC 03,F
00DD0:  MOVF   01,W
00DD2:  ADDLW  27
00DD4:  MOVWF  FE9
00DD6:  MOVLW  09
00DD8:  ADDWFC 03,W
00DDA:  MOVWF  FEA
00DDC:  MOVFF  922,FEF
....................                     } 
....................                      g_nGPSReceived++; 
00DE0:  INCF   x7A,F
....................                     break; 
00DE2:  BRA    0E42
....................                case 5:   // 
....................                case 9: 
....................                case 13: 
....................                case 17: 
....................                  break; 
00DE4:  MOVLB  9
00DE6:  BRA    0E42
....................                case 6:   // 
....................                case 10: 
....................                case 14: 
....................                case 18: 
....................                    break; 
00DE8:  MOVLB  9
00DEA:  BRA    0E42
....................                case 7:   //SNR 
....................                case 11: 
....................                case 15: 
....................                case 19: 
....................                      if(g_nGPSReceived == 0) 
00DEC:  MOVLB  9
00DEE:  MOVF   x7A,F
00DF0:  BNZ   0DFE
....................                          satData.nSatSNR = ch - '0'; 
00DF2:  MOVLW  30
00DF4:  MOVLB  A
00DF6:  SUBWF  x20,W
00DF8:  MOVLB  9
00DFA:  MOVWF  x22
....................                     else if(g_nGPSReceived == 1) 
00DFC:  BRA    0E3C
00DFE:  DECFSZ x7A,W
00E00:  BRA    0E3C
....................                     { 
....................                        satData.nSatSNR *= 10; 
00E02:  MOVF   x22,W
00E04:  MULLW  0A
00E06:  MOVFF  FF3,922
....................                          satData.nSatSNR += ch - '0'; 
00E0A:  MOVLW  30
00E0C:  MOVLB  A
00E0E:  SUBWF  x20,W
00E10:  MOVLB  9
00E12:  ADDWF  x22,F
....................                         if(satData.nSatID <= 32 && satData.nSatID > 0) 
00E14:  MOVF   x21,W
00E16:  SUBLW  20
00E18:  BNC   0E3C
00E1A:  MOVF   x21,F
00E1C:  BZ    0E3C
....................                            recGPSData.satSNR[satData.nSatID-1] = satData.nSatSNR; 
00E1E:  MOVLW  01
00E20:  SUBWF  x21,W
00E22:  CLRF   03
00E24:  ADDLW  2F
00E26:  MOVWF  01
00E28:  MOVLW  00
00E2A:  ADDWFC 03,F
00E2C:  MOVF   01,W
00E2E:  ADDLW  27
00E30:  MOVWF  FE9
00E32:  MOVLW  09
00E34:  ADDWFC 03,W
00E36:  MOVWF  FEA
00E38:  MOVFF  922,FEF
....................                } 
....................                      g_nGPSReceived++; 
00E3C:  INCF   x7A,F
....................                      break; 
00E3E:  BRA    0E42
00E40:  MOVLB  9
....................              
....................             } //switch(g_nGPSParamIndex)                                   
....................          } 
....................          break; 
00E42:  BRA    0E4E
....................       case GPS_STATE_GPVTG: 
....................             g_bGPSDataReady = 1; 
00E44:  MOVLB  9
00E46:  BSF    x76.3
....................             g_nGPSState = GPS_STATE_IDLE; 
00E48:  CLRF   x79
....................          break; 
00E4A:  BRA    0E4E
00E4C:  MOVLB  9
....................    }   //switch(g_nGPSState) 
....................  
.................... } 
....................  
00E4E:  BCF    F9E.5
00E50:  MOVLB  0
00E52:  GOTO   0148
.................... void RDA_isr() 
.................... { 
....................    int ch; 
....................     
....................    if(g_nGPSBufferWritePtr ==0)   //new sentence sec 
....................          g_nTickNewData = g_nTimerTick; 
....................           
....................    ch = fgetc(GPS); 
....................     
....................    if(g_bGPStoBT) 
....................       fputc(ch, BT_232); 
....................     
....................    if(ch == 0xD)   //Ignore LF 
....................       return; 
....................        
....................    GPSBuffer[g_nGPSBufferWritePtr] = ch; 
....................    if(ch == 0xA)   //Received one whole sentence 
....................    { 
....................          g_bGPSNewSentence = true; 
....................       g_nGPSSentences++; 
....................       g_nGPSBufferEOLPtr = g_nGPSBufferReadPtr; 
....................    }    
....................  
....................    GPS_INC_WRITEPTR(1); 
....................    if(g_nGPSBufferWritePtr == g_nGPSBufferReadPtr)   //Overlapped? 
....................    { 
....................          GPS_INC_READPTR(1); 
....................          g_bGPSOverlapped = 1; 
....................          g_nGPSOverlapped ++; 
....................    } 
....................     
....................  
....................  
.................... } 
....................  
....................  
.................... float gps_strtof() 
.................... { 
....................    float fResult, fTemp, fDiv; 
....................    int bMinus; 
....................  
....................    bMinus = 0; 
....................    fResult = 0; 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr] == '-') 
....................    { 
....................       bMinus = 1; 
....................       GPS_INC_READPTR(1); 
....................    } 
....................    else if(GPSBuffer[g_nGPSBufferReadPtr] == '+') 
....................    { 
....................       GPS_INC_READPTR(1); 
....................    } 
....................  
....................    while(GPSBuffer[g_nGPSBufferReadPtr] >= '0' && GPSBuffer[g_nGPSBufferReadPtr] <= '9') 
....................    { 
....................       fResult *= 10; 
....................       fTemp = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................       fResult += fTemp; 
....................       GPS_INC_READPTR(1); 
....................    } 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr] == '.') 
....................    { 
....................       GPS_INC_READPTR(1); 
....................       fDiv = 10; 
....................       while(GPSBuffer[g_nGPSBufferReadPtr] >= '0' && GPSBuffer[g_nGPSBufferReadPtr] <= '9') 
....................       { 
....................          fTemp = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................          fResult += fTemp/fDiv; 
....................          fDiv *= 10; 
....................          GPS_INC_READPTR(1); 
....................       } 
....................    } 
....................  
....................    if(bMinus) 
....................       fResult *= -1; 
....................  
....................    return fResult;    
.................... } 
....................  
.................... long gps_strtoul() 
.................... { 
....................    long lResult, lTemp; 
....................    int nLen; 
....................  
....................    nLen = 0; 
....................  
....................    lResult = 0; 
....................  
....................    while(GPSBuffer[g_nGPSBufferReadPtr] >= '0' && GPSBuffer[g_nGPSBufferReadPtr] <= '9') 
....................    { 
....................       lResult *= 10; 
....................       lTemp = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................       lResult += lTemp; 
....................       GPS_INC_READPTR(1); 
....................        
....................       if(++nLen > 5)   //Max 65535 
....................          break; 
....................    } 
....................     
....................    return lResult; 
.................... } 
....................  
.................... signed long gps_strtol() 
.................... { 
....................    signed long lResult, lTemp; 
....................    char bMinus; 
....................    int nLen; 
....................     
....................    nLen = 0; 
....................    lResult = 0; 
....................    bMinus=0; 
....................     
....................    if(GPSBuffer[g_nGPSBufferReadPtr] == '-') 
....................    { 
....................       bMinus = 1; 
....................        
....................       GPS_INC_READPTR(1); 
....................    } 
....................    else if(GPSBuffer[g_nGPSBufferReadPtr] == '+') 
....................    { 
....................        
....................       GPS_INC_READPTR(1); 
....................    } 
....................  
....................    while(GPSBuffer[g_nGPSBufferReadPtr] >= '0' && GPSBuffer[g_nGPSBufferReadPtr] <= '9') 
....................    { 
....................       lResult *= 10; 
....................       lTemp = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................       lResult += lTemp; 
....................       GPS_INC_READPTR(1); 
....................        
....................       if(++nLen > 6)   //Max 65535 
....................          break; 
....................    } 
....................  
....................    if(bMinus) 
....................       lResult *= -1; 
....................    return lResult; 
.................... } 
....................  
.................... //$GPGGA,070102.000,4911.1179,N,12247.2601,W,1,09,0.9,81.8,M,-16.7,M,,0000*52 
.................... //Get GPS sentence from GPSBuffer[g_nGPSBufferReadPtr] 
.................... int parseGPGGA() 
.................... { 
....................    int nComma, nLen; 
....................    float fTemp; 
....................    int bFixed; 
....................  
....................    nLen = 0; 
....................    nComma = 0; 
....................    bFixed = 0; 
....................  
....................    recGPSData.numSat = 0; 
....................    recGPSData.fAltitude = 0; 
....................  
....................    //Skip unused items 
....................    while(g_nGPSBufferReadPtr != g_nGPSBufferWritePtr && nComma < 6) 
....................    { 
....................       if(GPSBuffer[g_nGPSBufferReadPtr] == ',') 
....................          nComma ++; 
....................       GPS_INC_READPTR(1); 
....................    } 
....................  
....................    if(nComma < 6) 
....................       return FALSE; 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr] == '1') 
....................    { 
....................       bFixed = 1; 
....................  
....................       GPS_INC_READPTR(2); 
....................  
....................       recGPSData.numSat = gps_strtoul(); 
....................       GPS_INC_READPTR(1); 
....................  
....................       fTemp = gps_strtof(); 
....................       GPS_INC_READPTR(1); 
....................  
....................       recGPSData.fAltitude = gps_strtof(); 
....................    } 
....................  
....................    return bFixed; 
....................     
.................... } 
....................  
.................... //$GPRMC,052457.000,A,4911.1152,N,12247.2628,W,0.00,16.90,290406,,,A*4C 
.................... int parseGPRMC() 
.................... { 
....................    GPS_INC_READPTR(1);   //Skip first comma 
....................  
....................    recGPSData.time.tm_hour = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_hour *= 10; 
....................    recGPSData.time.tm_hour += GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.time.tm_min = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_min *= 10; 
....................    recGPSData.time.tm_min += GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.time.tm_sec = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_sec *= 10; 
....................    recGPSData.time.tm_sec += GPSBuffer[g_nGPSBufferReadPtr] - '0';    
....................    GPS_INC_READPTR(1); 
....................  
....................    //Convert to local time 
....................    recGPSData.time.tm_hour += 24; 
.................... //   recGPSData.time.tm_hour += gSettings.nTimeZone; 
....................    recGPSData.time.tm_hour %= 24; 
....................  
....................    while(GPSBuffer[g_nGPSBufferReadPtr] != ',') 
....................       GPS_INC_READPTR(1);   //move to next comma 
....................  
....................    GPS_INC_READPTR(1);   //Skip comma 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr] != 'A') 
....................       return FALSE; 
....................  
....................    GPS_INC_READPTR(1);   //Skip A/V 
....................  
....................    GPS_INC_READPTR(1);   //skip ',' 
....................  
....................    recGPSData.fLatitude = 0; 
....................    recGPSData.fLongitude = 0; 
....................    recGPSData.fSpeed = 0.0; 
....................  
....................    recGPSData.fLatitude = gps_strtof(); 
....................    GPS_INC_READPTR(1); 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr]) 
....................    { 
....................       recGPSData.northSouth = GPSBuffer[g_nGPSBufferReadPtr];   //North/South 
....................       GPS_INC_READPTR(1); 
....................       GPS_INC_READPTR(1); 
....................    } 
....................    else 
....................       return FALSE; 
....................  
....................    recGPSData.fLongitude = gps_strtof(); 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.eastWest = GPSBuffer[g_nGPSBufferReadPtr];    
....................    GPS_INC_READPTR(1); 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.fSpeed = gps_strtof(); 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.direction = (int16)gps_strtof(); 
....................    GPS_INC_READPTR(1); 
....................     
....................  
....................    recGPSData.time.tm_day = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_day *= 10; 
....................    recGPSData.time.tm_day += GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.time.tm_mon = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_mon *= 10; 
....................    recGPSData.time.tm_mon += GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................  
....................    recGPSData.time.tm_year = GPSBuffer[g_nGPSBufferReadPtr] - '0'; 
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_year *= 10; 
....................    recGPSData.time.tm_year += GPSBuffer[g_nGPSBufferReadPtr] - '0';    
....................    GPS_INC_READPTR(1); 
....................    recGPSData.time.tm_year += 2000;    
....................     
....................    myrec.tm_year = recGPSData.time.tm_year; 
....................    myrec.tm_mon = recGPSData.time.tm_mon; 
....................    myrec.tm_day = recGPSData.time.tm_day; 
....................    myrec.tm_mday = recGPSData.time.tm_day; 
....................    myrec.tm_hour = recGPSData.time.tm_hour; 
....................    myrec.tm_min = recGPSData.time.tm_min; 
....................    myrec.tm_sec = recGPSData.time.tm_sec; 
....................  
....................    recGPSData.fSpeed *= 1.852; 
....................  
....................    return TRUE; 
....................     
.................... } 
....................  
.................... //$GPGSV,3,1,12,20,00,000,,10,00,000,,25,00,000,,27,00,000,*79 
.................... //$GPGSV,3,2,12,22,00,000,,07,00,000,,21,00,000,,24,00,000,*79 
.................... //$GPGSV,3,3,12,16,00,000,,28,00,000,,26,00,000,,29,00,000,*78 
.................... //Get GPS sentence from GPSBuffer[g_nGPSBufferReadPtr] 
.................... int parseGPGSV() 
.................... { 
....................    int nComma; 
....................    int nNumMsg, nMsgID, nNumSat; 
....................    int nSatID, nSatElevation, nSatSNR; 
....................    long nSatAzimuth; 
....................  
....................    nComma = 0; 
....................    nNumMsg = 0; 
....................    nMsgID = 0; 
....................    nNumSat = 0; 
....................  
....................    GPS_INC_READPTR(1);   //Skip first comma 
....................  
....................    nNumMsg = (int)gps_strtoul();   //Get total number of message 
....................    GPS_INC_READPTR(1);   //Skip comma 
....................     
....................    nMsgID = (int)gps_strtoul();   //Get current message number 
....................    GPS_INC_READPTR(1);   //Skip comma 
....................     
....................    nNumSat = (int)gps_strtoul();   //Get total number of satellite in sky 
....................    GPS_INC_READPTR(1);   //Skip comma 
....................  
....................    while(GPSBuffer[g_nGPSBufferReadPtr] != '*') 
....................    { 
....................       nSatID = (int)gps_strtof() -1; 
....................       GPS_INC_READPTR(1);   //Skip comma 
....................       nSatElevation = (int)gps_strtoul(); 
....................       GPS_INC_READPTR(1);   //Skip comma 
....................       nSatAzimuth = gps_strtoul(); 
....................       GPS_INC_READPTR(1);   //Skip comma 
....................       if(GPSBuffer[g_nGPSBufferReadPtr] == '*') 
....................          break; 
....................       nSatSNR = (int)gps_strtof(); 
....................       GPS_INC_READPTR(1);   //Skip comma 
....................        
....................       if(nSatID < 32) 
....................       { 
....................          if(recGPSData.satSNR[nSatID] == 0x80)   //Fixed 
....................             recGPSData.satSNR[nSatID] += nSatSNR; 
....................          else 
....................             recGPSData.satSNR[nSatID] = nSatSNR; 
....................              
....................       } 
....................    } 
....................  
....................    return 1; 
....................     
.................... } 
....................  
.................... //$GPGSA,A,3,07,02,26,27,09,04,15, , , , , ,1.8,1.0,1.5*33 
.................... void parse_GPGSA() 
.................... { 
....................    int nSatID; 
....................    GPS_INC_READPTR(1);   //Skip comma 
....................  
....................    GPS_INC_READPTR(2);   //Skip mode 1 
....................  
....................    recGPSData.fixType = (int)gps_strtoul();   //Get fix mode - 1:Fix not available, 2:2D, 3:3D 
....................    GPS_INC_READPTR(1);   //Skip comma 
....................     
....................    while(GPSBuffer[g_nGPSBufferReadPtr] != ',' && GPSBuffer[g_nGPSBufferReadPtr] != ' ') 
....................    { 
....................       nSatID = (int)gps_strtoul() -1; 
....................       recGPSData.satSNR[nSatID] = 0x80;    
....................       GPS_INC_READPTR(1);   //Skip comma 
....................    } 
....................  
.................... } 
....................  
.................... void gps_ResetSatelliteSignal() 
.................... { 
....................    int i; 
....................    for(i=0; i<32; i++) 
*
0076E:  MOVLB  A
00770:  CLRF   x21
00772:  MOVF   x21,W
00774:  SUBLW  1F
00776:  BNC   0798
....................    { 
....................       recGPSData.satSNR[i] = 0xFF; 
00778:  CLRF   03
0077A:  MOVF   x21,W
0077C:  ADDLW  2F
0077E:  MOVWF  01
00780:  MOVLW  00
00782:  ADDWFC 03,F
00784:  MOVF   01,W
00786:  ADDLW  27
00788:  MOVWF  FE9
0078A:  MOVLW  09
0078C:  ADDWFC 03,W
0078E:  MOVWF  FEA
00790:  MOVLW  FF
00792:  MOVWF  FEF
....................    } 
00794:  INCF   x21,F
00796:  BRA    0772
.................... } 
00798:  MOVLB  9
0079A:  GOTO   0D42 (RETURN)
....................  
.................... int16 g_nTickStart, g_nTickEnd; 
....................  
.................... void GPSParser() 
.................... { 
....................    char sName[3]; 
....................  
....................          LCD_Gotoxy(0,16); 
....................            printf(LCD_PutChar, "%2d-%3ld-%3ld ", g_nGPSSentences, g_nGPSBufferReadPtr,g_nGPSBufferWritePtr); 
....................              if(g_bGPSOverlapped) 
....................            { 
....................               printf(LCD_PutChar, "0 %c%c%c",  
....................                  GPSBuffer[g_nGPSBufferReadPtr+3], GPSBuffer[g_nGPSBufferReadPtr+4], GPSBuffer[g_nGPSBufferReadPtr+5]); 
....................             g_bGPSOverlapped = 0; 
....................            } 
....................            else 
....................               printf(LCD_PutChar, " %c%c%c %d ",  
....................                  GPSBuffer[g_nGPSBufferReadPtr+3], GPSBuffer[g_nGPSBufferReadPtr+4], GPSBuffer[g_nGPSBufferReadPtr+5], g_nGPSOverlapped); 
....................  
....................    if(GPSBuffer[g_nGPSBufferReadPtr] == '$')   //Valid GPS sentece? 
....................    { 
....................       GPS_INC_READPTR(1);   //Skip '$' 
....................        
....................       if(GPSBuffer[g_nGPSBufferReadPtr] == 'G') 
....................       { 
....................          GPS_INC_READPTR(1);   //Skip 'G' 
....................           
....................          if(GPSBuffer[g_nGPSBufferReadPtr] == 'P') 
....................          { 
....................             GPS_INC_READPTR(1);   //Skip 'P' 
....................     
....................             sName[0] = GPSBuffer[g_nGPSBufferReadPtr]; 
....................             GPS_INC_READPTR(1); 
....................             sName[1] = GPSBuffer[g_nGPSBufferReadPtr]; 
....................             GPS_INC_READPTR(1); 
....................             sName[2] = GPSBuffer[g_nGPSBufferReadPtr]; 
....................             GPS_INC_READPTR(1); 
....................              
....................             if(sName[0] == 'G' && sName[1] == 'G' && sName[2] == 'A')   //Begin of sentece, every second 
....................             { 
....................                g_nTickStart = g_nTimerTick; 
....................                g_bGPSDataReady = 0; 
....................                g_bGPSFixed = parseGPGGA(); 
....................             } 
....................             else if(sName[0] == 'R' && sName[1] == 'M' && sName[2] == 'C')   //every second 
....................             { 
....................                parseGPRMC(); 
....................             } 
....................             else if(sName[0] == 'G' && sName[1] == 'S' && sName[2] == 'A')   //Accompany with GPGSV, very 3 seconds (GR86 default) 
....................             { 
....................                gps_ResetSatelliteSignal(); 
....................             } 
....................             else if(sName[0] == 'G' && sName[1] == 'S' && sName[2] == 'V')   //Satellite infomation, every 3 seconds (GR86 default) 
....................             { 
....................                parseGPGSV(); 
....................             } 
....................             else if(sName[0] == 'V' && sName[1] == 'T' && sName[2] == 'G')   //Last sentence received 
....................             { 
....................                g_bGPSDataReady = 1; 
....................                g_nGPSBufferWritePtr = 0; 
....................                g_nGPSBufferReadPtr = g_nGPSBufferWritePtr; 
....................                g_nTickEnd = g_nTimerTick; 
....................                  printf(LCD_PutChar, "%ld %ld ", g_nTickEnd -g_nTickStart, g_nTickEnd - g_nTickNewData); 
....................             } 
....................          } 
....................       } 
....................    } 
....................        
....................        
....................    //Set read pointer to next sentence 
....................    while(g_nGPSBufferReadPtr != g_nGPSBufferWritePtr && GPSBuffer[g_nGPSBufferReadPtr] != 0x0A) 
....................    { 
....................       GPS_INC_READPTR(1);   //Skip CR 
....................    } 
....................  
....................    if(g_nGPSBufferReadPtr != g_nGPSBufferWritePtr && GPSBuffer[g_nGPSBufferReadPtr] == 0x0A) 
....................       GPS_INC_READPTR(1);   //Skip CR 
....................     
.................... } 
....................  
.................... /* 
.................... $GPGGA,000327.049,0000.0000,N,00000.0000,E,0,00,,0.0,M,0.0,M,,0000*48 
.................... $GPRMC,000327.049,V,0000.0000,N,00000.0000,E,,,160406,,,N*78 
.................... $GPVTG,,T,,M,,N,,K,N*2C 
.................... $GPGGA,000328.051,0000.0000,N,00000.0000,E,0,00,,0.0,M,0.0,M,,0000*4E 
.................... $GPRMC,000328.051,V,0000.0000,N,00000.0000,E,,,160406,,,N*7E 
.................... $GPVTG,,T,,M,,N,,K,N*2C 
.................... $GPGGA,000329.056,0000.0000,N,00000.0000,E,0,00,,0.0,M,0.0,M,,0000*48 
.................... $GPGSA,A,1,,,,,,,,,,,,,,,*1E 
.................... $GPGSV,3,1,12,20,00,000,,10,00,000,,25,00,000,,27,00,000,*79 
.................... $GPGSV,3,2,12,22,00,000,,07,00,000,,21,00,000,,24,00,000,*79 
.................... $GPGSV,3,3,12,16,00,000,,28,00,000,,26,00,000,,29,00,000,*78 
.................... $GPRMC,000329.056,V,0000.0000,N,00000.0000,E,,,160406,,,N*78 
.................... $GPVTG,,T,,M,,N,,K,N*2C 
.................... $GPGGA,000330.049,0000.0000,N,00000.0000,E,0,00,,0.0,M,0.0,M,,0000*4E 
.................... $GPRMC,000330.049,V,0000.0000,N,00000.0000,E,,,160406,,,N*7E 
.................... $GPVTG,,T,,M,,N,,K,N*2C 
.................... */ 
....................  
....................  
.................... void realtimeProcess(); 
....................  
.................... #INT_EXT 
.................... void EXT_isr() 
.................... { 
....................    g_nKeyNewState = input_b(); 
*
00FC2:  MOVLW  FF
00FC4:  MOVWF  F93
00FC6:  MOVFF  F81,70B
....................    output_high(LCD_BKLT); 
00FCA:  BCF    F98.0
00FCC:  BSF    F8F.0
....................    nLEDTimer = 500; 
00FCE:  MOVLW  01
00FD0:  MOVLB  7
00FD2:  MOVWF  x0E
00FD4:  MOVLW  F4
00FD6:  MOVWF  x0D
....................    clear_interrupt(INT_EXT); 
00FD8:  BCF    FF2.1
.................... } 
....................  
00FDA:  BCF    FF2.1
00FDC:  MOVLB  0
00FDE:  GOTO   0148
.................... #INT_EXT1 
.................... void EXT1_isr() 
.................... { 
....................    g_nKeyNewState = input_b(); 
00FE2:  MOVLW  FF
00FE4:  MOVWF  F93
00FE6:  MOVFF  F81,70B
....................    output_high(LCD_BKLT); 
00FEA:  BCF    F98.0
00FEC:  BSF    F8F.0
....................    nLEDTimer = 500; 
00FEE:  MOVLW  01
00FF0:  MOVLB  7
00FF2:  MOVWF  x0E
00FF4:  MOVLW  F4
00FF6:  MOVWF  x0D
....................    clear_interrupt(INT_EXT1); 
00FF8:  BCF    FF0.0
.................... } 
....................  
00FFA:  BCF    FF0.0
00FFC:  MOVLB  0
00FFE:  GOTO   009C
.................... #INT_EXT2 
.................... void EXT2_isr() 
.................... { 
....................    g_nKeyNewState = input_b(); 
01002:  MOVLW  FF
01004:  MOVWF  F93
01006:  MOVFF  F81,70B
....................    output_high(LCD_BKLT); 
0100A:  BCF    F98.0
0100C:  BSF    F8F.0
....................    nLEDTimer = 500; 
0100E:  MOVLW  01
01010:  MOVLB  7
01012:  MOVWF  x0E
01014:  MOVLW  F4
01016:  MOVWF  x0D
....................    clear_interrupt(INT_EXT2); 
01018:  BCF    FF0.1
.................... } 
....................  
0101A:  BCF    FF0.1
0101C:  MOVLB  0
0101E:  GOTO   009C
.................... #INT_EXT3 
.................... void EXT3_isr() 
.................... { 
....................    g_nKeyNewState = input_b(); 
01022:  MOVLW  FF
01024:  MOVWF  F93
01026:  MOVFF  F81,70B
....................    output_high(LCD_BKLT); 
0102A:  BCF    F98.0
0102C:  BSF    F8F.0
....................    nLEDTimer = 500; 
0102E:  MOVLW  01
01030:  MOVLB  7
01032:  MOVWF  x0E
01034:  MOVLW  F4
01036:  MOVWF  x0D
....................    clear_interrupt(INT_EXT3); 
01038:  BCF    FF0.2
.................... } 
....................  
0103A:  BCF    FF0.2
0103C:  MOVLB  0
0103E:  GOTO   0148
.................... #int_RB 
.................... void RB_isr()  
.................... { 
....................    g_nKeyNewState = input_b(); 
01042:  MOVLW  FF
01044:  MOVWF  F93
01046:  MOVFF  F81,70B
....................    output_high(LCD_BKLT); 
0104A:  BCF    F98.0
0104C:  BSF    F8F.0
....................    nLEDTimer = 500; 
0104E:  MOVLW  01
01050:  MOVLB  7
01052:  MOVWF  x0E
01054:  MOVLW  F4
01056:  MOVWF  x0D
....................     
....................   if(!(g_nKeyNewState&KB_POWER)) 
01058:  BTFSC  x0B.0
0105A:  BRA    1068
....................    { 
....................       g_bBKLight = !g_bBKLight; 
0105C:  MOVF   x0C,F
0105E:  BZ    1064
01060:  MOVLW  00
01062:  BRA    1066
01064:  MOVLW  01
01066:  MOVWF  x0C
....................    } 
....................  
.................... } 
....................  
01068:  BCF    FF2.0
0106A:  MOVLB  0
0106C:  GOTO   009C
.................... const char sCmdBTLNM[]="AT+BTLNM=\"TOM\"\r\n";  //Set BT name 
.................... const char sCmdBTSRV[]="AT+BTSRV=1,\"GPS\"\r\n";   //Turn on SPP protocol (RF and discoverable) 
.................... const char sCmdBTAUT[]="AT+BTAUT=1,1\r\n";   //Automatically connect (not return to command mode) 
....................  
....................  
.................... int16 nReceived2=0; 
.................... char sBTBuffer[64]= "\x0"; 
.................... int nBTBufferLen=0; 
....................  
.................... #int_RDA2 
.................... void RDA2_isr() 
.................... { 
....................    int ch; 
....................  
....................    ch = fgetc(BT_232); 
01070:  BTFSS  FA4.5
01072:  BRA    1070
01074:  MOVFF  FAA,A1C
01078:  MOVLB  A
....................     
....................    //putc(ch); 
....................     
....................     nReceived2++; 
0107A:  MOVLB  9
0107C:  INCF   x86,F
0107E:  BTFSC  FD8.2
01080:  INCF   x87,F
....................      
....................   
....................        
....................    if(ch != '\r' && ch != '\n') 
01082:  MOVLB  A
01084:  MOVF   x1C,W
01086:  SUBLW  0D
01088:  BZ    10C2
0108A:  MOVF   x1C,W
0108C:  SUBLW  0A
0108E:  BZ    10C2
....................    { 
....................       sBTBuffer[nBTBufferLen++] = ch; 
01090:  MOVLB  9
01092:  MOVF   xC8,W
01094:  INCF   xC8,F
01096:  CLRF   03
01098:  ADDLW  88
0109A:  MOVWF  FE9
0109C:  MOVLW  09
0109E:  ADDWFC 03,W
010A0:  MOVWF  FEA
010A2:  MOVFF  A1C,FEF
....................     
....................       if(nBTBufferLen > 26) 
010A6:  MOVF   xC8,W
010A8:  SUBLW  1A
010AA:  BC    10AE
....................          nBTBufferLen = 0; 
010AC:  CLRF   xC8
....................        
....................       sBTBuffer[nBTBufferLen] = '*'; 
010AE:  CLRF   03
010B0:  MOVF   xC8,W
010B2:  ADDLW  88
010B4:  MOVWF  FE9
010B6:  MOVLW  09
010B8:  ADDWFC 03,W
010BA:  MOVWF  FEA
010BC:  MOVLW  2A
010BE:  MOVWF  FEF
010C0:  MOVLB  A
....................    } 
....................     
....................  
.................... } 
....................  
.................... //10ms interrupt 
010C2:  BCF    FA4.5
010C4:  MOVLB  0
010C6:  GOTO   009C
.................... #int_TIMER0 
.................... void TIMER0_isr()  
.................... { 
....................       set_timer0(5560);   //10ms 
010CA:  MOVLW  15
010CC:  MOVWF  FD7
010CE:  MOVLW  B8
010D0:  MOVWF  FD6
.................... //   set_timer3(Config.nTimerBase);    //1ms interrupt 
....................  
....................    if(nLEDTimer) 
010D2:  MOVLB  7
010D4:  MOVF   x0D,W
010D6:  IORWF  x0E,W
010D8:  BZ    10E2
....................       nLEDTimer--; 
010DA:  MOVF   x0D,W
010DC:  BTFSC  FD8.2
010DE:  DECF   x0E,F
010E0:  DECF   x0D,F
....................  
....................    if(nSampleTimer) 
010E2:  MOVF   x0F,F
010E4:  BZ    10E8
....................    { 
....................       nSampleTimer--; 
010E6:  DECF   x0F,F
....................    } 
....................    g_nTimerTick++; 
010E8:  INCF   x10,F
010EA:  BTFSC  FD8.2
010EC:  INCF   x11,F
....................     
....................    if(input(KEY_POWER) == 0)   //Hold Power key 
010EE:  BSF    F93.0
010F0:  BTFSC  F81.0
010F2:  BRA    10FC
....................          g_nPwrBtnHoldTick++; 
010F4:  INCF   x12,F
010F6:  BTFSC  FD8.2
010F8:  INCF   x13,F
....................    else 
010FA:  BRA    1100
....................       g_nPwrBtnHoldTick = 0; 
010FC:  CLRF   x13
010FE:  CLRF   x12
....................  
.................... } 
....................  
01100:  BCF    FF2.2
01102:  MOVLB  0
01104:  GOTO   009C
.................... #BYTE CCP1CON=0xFBD 
.................... #BYTE UCFG=0xF6F 
.................... #BIT UPUEN=UCFG.4 
.................... #BIT FSEN=UCFG.2 
....................  
.................... #BYTE OSCTUNE=0xF9B 
.................... #BIT PLLEN=OSCTUNE.6 
....................  
.................... int16 nHMCA, nHMCB; 
....................  
.................... void senseBattery(); 
.................... void ReadSensors() 
.................... { 
....................    //Turn on sensors power 
....................    output_low(SENSOR_ENX); 
*
01770:  BCF    F97.7
01772:  BCF    F8E.7
....................    delay_ms(10); 
01774:  MOVLW  0A
01776:  MOVLB  9
01778:  MOVWF  xF5
0177A:  MOVLB  0
0177C:  RCALL  1108
....................     
....................    SenseBattery(); 
0177E:  BRA    1690
....................     
....................    output_high(HMC_RESET); //Set HMC1052 
01780:  BCF    F97.5
01782:  BSF    F8E.5
....................    delay_ms(3); 
01784:  MOVLW  03
01786:  MOVLB  9
01788:  MOVWF  xF5
0178A:  MOVLB  0
0178C:  RCALL  1108
....................  
....................    set_adc_channel(ADCCH_HMCA); 
0178E:  MOVLW  04
01790:  MOVWF  01
01792:  MOVF   FC2,W
01794:  ANDLW  C3
01796:  IORWF  01,W
01798:  MOVWF  FC2
....................    delay_ms(10); 
0179A:  MOVLW  0A
0179C:  MOVLB  9
0179E:  MOVWF  xF5
017A0:  MOVLB  0
017A2:  RCALL  1108
....................    nHMCA = read_adc(); 
017A4:  BSF    FC2.1
017A6:  BTFSC  FC2.1
017A8:  BRA    17A6
017AA:  MOVFF  FC4,9CA
017AE:  MOVLB  9
017B0:  MOVFF  FC3,9C9
....................    nHMCA >>= 6; 
017B4:  RRCF   xCA,F
017B6:  RRCF   xC9,F
017B8:  RRCF   xCA,F
017BA:  RRCF   xC9,F
017BC:  RRCF   xCA,F
017BE:  RRCF   xC9,F
017C0:  RRCF   xCA,F
017C2:  RRCF   xC9,F
017C4:  RRCF   xCA,F
017C6:  RRCF   xC9,F
017C8:  RRCF   xCA,F
017CA:  RRCF   xC9,F
017CC:  MOVLW  03
017CE:  ANDWF  xCA,F
....................  
....................    set_adc_channel(ADCCH_HMCB); 
017D0:  MOVLW  08
017D2:  MOVWF  01
017D4:  MOVF   FC2,W
017D6:  ANDLW  C3
017D8:  IORWF  01,W
017DA:  MOVWF  FC2
....................    delay_ms(1); 
017DC:  MOVLW  01
017DE:  MOVWF  xF5
017E0:  MOVLB  0
017E2:  RCALL  1108
....................    nHMCB = read_adc(); 
017E4:  BSF    FC2.1
017E6:  BTFSC  FC2.1
017E8:  BRA    17E6
017EA:  MOVFF  FC4,9CC
017EE:  MOVLB  9
017F0:  MOVFF  FC3,9CB
....................    nHMCB >>= 6; 
017F4:  RRCF   xCC,F
017F6:  RRCF   xCB,F
017F8:  RRCF   xCC,F
017FA:  RRCF   xCB,F
017FC:  RRCF   xCC,F
017FE:  RRCF   xCB,F
01800:  RRCF   xCC,F
01802:  RRCF   xCB,F
01804:  RRCF   xCC,F
01806:  RRCF   xCB,F
01808:  RRCF   xCC,F
0180A:  RRCF   xCB,F
0180C:  MOVLW  03
0180E:  ANDWF  xCC,F
....................        
....................    output_low(HMC_RESET);  //Reset HMC1052 
01810:  BCF    F97.5
01812:  BCF    F8E.5
....................     
....................    //Turn off sensor power 
....................    //output_float(SENSOR_ENX); 
.................... } 
01814:  MOVLB  0
01816:  RETLW  00
....................  
....................  
.................... #define CardInserted PIN_D4 
.................... int gActCard, gPrevCard; 
....................  
....................  
....................  
.................... #include "at26_dataflash.c" 
....................  
.................... #use FAST_IO(C) 
.................... #define AT26ChipSel PIN_F6 
.................... #define AT26ChipClk PIN_C3 
.................... #define AT26ChipDin PIN_C4 
.................... #define AT26ChipDout PIN_C5 
....................  
.................... //Read Commands 
.................... #define AT26CMD_READ_ARRAY      0x0B 
.................... #define AT26CMD_READ_ARRAY_SLOW   0x03 
....................  
.................... //Program and Erase Commands 
.................... #define AT26CMD_ERASE_4KB      0x20 
.................... #define AT26CMD_ERASE_32KB      0x52 
.................... #define AT26CMD_ERASE_64KB      0xD8 
.................... #define AT26CMD_ERASE_CHIP      0x60 
.................... #define AT26CMD_PROGRAM         0x02 
....................  
.................... //Protection Commands 
.................... #define AT26CMD_WRITE_ENABLE   0x06 
.................... #define AT26CMD_WRITE_DISABLE   0x04 
.................... #define AT26CMD_PROTECT_SECTOR   0x36 
.................... #define AT26CMD_UNPROTECT_SECTOR   0x39 
.................... #define AT26CMD_READ_SECTOR_PROTECTION_REGISTERS   0x3C 
....................  
.................... //Status Register Commands 
.................... #define AT26CMD_READ_STATUS_REGISTER   0x05 
.................... #define AT26CMD_WRITE_STATUS_REGISTER   0x01 
....................  
.................... //Miscellaneous Command 
.................... #define AT26CMD_READ_MANUFACTURER_DEVICE_ID   0x9F 
.................... #define AT26CMD_DEEP_POWER_DOWN      0xB9 
.................... #define AT26CMD_RESUME_FROM_DEEP_POWER_DOWN   0xAB 
....................  
.................... int32 AT26_ReadDeviceID() 
.................... { 
....................    byte byRead; 
....................    int32 nResp = 0; 
....................     
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_READ_MANUFACTURER_DEVICE_ID); 
....................     
....................    //Read Manufacturer ID 
....................    byRead = SPI_READ(0); 
....................    nResp = byRead; 
....................    nResp <<= 8; 
....................    //Read Device ID Part I 
....................    byRead = SPI_READ(0); 
....................    nResp += byRead; 
....................    nResp <<= 8; 
....................    //Read Device ID Part II 
....................    byRead = SPI_READ(0); 
....................    nResp += byRead; 
....................    nResp <<= 8; 
....................     
....................    byRead = SPI_READ(0); 
....................    nResp += byRead; 
....................     
....................    output_high(AT26ChipSel); 
....................     
....................    return nResp;    
.................... } 
....................  
.................... byte AT26_ReadStatusRegister() 
.................... { 
....................    byte byRead; 
....................     
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_READ_STATUS_REGISTER); 
....................     byRead = SPI_READ(0); 
....................     //Note: Doesn't work with : byRead = SPI_READ(AT26CMD_READ_STATUS_REGISTER); 
....................    
....................    output_high(AT26ChipSel); 
....................   
....................    return byRead; 
.................... } 
....................  
....................  
.................... void AT26_WriteStatusRegister(int nData) 
.................... { 
....................    
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_WRITE_STATUS_REGISTER); 
....................    SPI_WRITE(nData); 
....................     
....................    output_high(AT26ChipSel); 
....................   
.................... } 
....................  
....................  
.................... void AT26_WriteEnable() 
.................... { 
....................    
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_WRITE_ENABLE); 
....................     
....................    output_high(AT26ChipSel); 
....................   
.................... } 
....................  
.................... void AT26_WriteDiable() 
.................... { 
....................    
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_WRITE_DISABLE); 
....................     
....................    output_high(AT26ChipSel); 
....................   
.................... } 
....................  
.................... byte AT26_ReadSectorProtection(int32 nAddress) 
.................... { 
....................       byte byRead; 
....................     
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_READ_SECTOR_PROTECTION_REGISTERS); 
....................  
....................    SPI_WRITE(make8(nAddress, 2)); 
....................    SPI_WRITE(make8(nAddress, 1)); 
....................    SPI_WRITE(make8(nAddress, 0)); 
....................     
....................    byRead = SPI_READ(0); 
....................     //Note: Doesn't work with : byRead = SPI_READ(AT26CMD_READ_STATUS_REGISTER); 
....................    
....................    output_high(AT26ChipSel); 
....................   
....................    return byRead; 
.................... } 
....................  
.................... void AT26_UnprotectSector(int32 nAddress) 
.................... {   
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_UNPROTECT_SECTOR); 
....................  
....................    SPI_WRITE(make8(nAddress, 2)); 
....................    SPI_WRITE(make8(nAddress, 1)); 
....................    SPI_WRITE(make8(nAddress, 0)); 
....................     
....................    output_high(AT26ChipSel); 
.................... } 
....................  
.................... void AT26_WriteByte(int32 nAddress, byte nData) 
.................... { 
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_PROGRAM); 
....................  
....................    SPI_WRITE(make8(nAddress, 2)); 
....................    SPI_WRITE(make8(nAddress, 1)); 
....................    SPI_WRITE(make8(nAddress, 0)); 
....................   
....................    SPI_WRITE(nData); 
....................     
....................    output_high(AT26ChipSel); 
.................... } 
....................  
.................... byte AT26_ReadByte(int32 nAddress) 
.................... { 
....................    byte byRead; 
....................     
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_READ_ARRAY); 
....................  
....................    SPI_WRITE(make8(nAddress, 2)); 
....................    SPI_WRITE(make8(nAddress, 1)); 
....................    SPI_WRITE(make8(nAddress, 0)); 
....................    SPI_WRITE(0);  //Dummy byte 
....................   
....................    byRead = SPI_READ(0); 
....................     
....................    output_high(AT26ChipSel); 
....................   
....................    return byRead; 
.................... } 
....................  
.................... void AT26_BlockErase4K(int32 nAddress) 
.................... { 
....................    output_low(AT26ChipSel); 
....................     
....................    SPI_WRITE(AT26CMD_ERASE_4KB); 
....................  
....................    SPI_WRITE(make8(nAddress, 2)); 
....................    SPI_WRITE(make8(nAddress, 1)); 
....................    SPI_WRITE(make8(nAddress, 0)); 
....................     
....................    output_high(AT26ChipSel); 
.................... } 
....................  
.................... #include "scp1000.c" 
.................... #ifndef SCP1000_H 
.................... #define SCP1000_H 
....................  
.................... //Address 
.................... #define SCP1000_ADDRESS      0x22 
....................  
.................... //Registers 
.................... #define SCPREG_REVID   0x00 
.................... #define SCPREG_DATAWR   0x01   //Indirect register access data 
.................... #define SCPREG_ADDPTR   0x02   //Indirect register access pointer 
.................... #define SCPREG_OPERATION   0x03   //Operation register 
.................... #define SCPREG_OPSTATUS   0x04   //Operation status 
.................... #define SCPREG_RSTR      0x06   //ASIC software reset 
.................... #define SCPREG_STATUS   0x07   //ASIC top-level status 
.................... #define SCPREG_DATARD8   0x7F   //Pressure output data (MSB) 
.................... #define SCPREG_DATARD16   0x80   //Pressure output data (LSB) 
.................... #define SCPREG_TEMPOUT   0x81   //14bit temperature output data 
....................  
.................... //Operation Code 
.................... #define SCPOP_NOP       0x00  //No operation/cancel current operation/stop continuous sampling 
.................... #define SCPOP_READREG   0x01  //Read indirect access register pointed by ADDPTR. Register contents is available in DATARD16 in bits[7:0] 
.................... #define SCPOP_WRITEREG  0x02  //Write DATAWR contents in to the indirect access register pointed by ADDPTR 
.................... #define SCPOP_READEEPROM   0x05  //Read EEPROM register pointed by ADDPTR. Register contents is available in DATARD8 in bits [7:0] 
.................... #define SCPOP_WRITEEEPROM  0x06  //Write DATAWR contents into the EEPROM register pointed by ADDPTR. 
.................... #define SCPOP_INIT      0x07     //Perform INIT sequence 
.................... #define SCPOP_HSPMODE   0x09     //High speed continuous mode , continuous 
.................... #define SCPOP_HRESMODE  0x0A     //High resolution mode, continuous 
.................... #define SCPOP_UPWRMODE  0x0B     //Utra low power acquisition mode, continuous 
.................... #define SCPOP_TRIG      0x0C     //Low Power acquisition mode. single sample. 
.................... #define SCPOP_SELFTEST  0x0F     //ASIC Self Test 
....................  
.................... int SCP1000_ReadRegister8(int nRegAddr) 
.................... { 
....................    int nResult; 
....................     
....................    i2c_start(); 
....................  
....................    if(i2c_write(SCP1000_ADDRESS))           // Send the address of the device 
....................       return 0xAA;   //NO ACK 
....................  
....................    if(i2c_write(nRegAddr)) 
....................       return 0xAB; 
....................     
....................    i2c_start(); 
....................    if(i2c_write(SCP1000_ADDRESS| 0x01))           // Send the address of the device 
....................       return 0xAC; 
....................     
....................    nResult = i2c_read(0);       
....................  
....................    i2c_stop(); 
....................  
....................    return nResult;    
.................... } 
....................  
.................... int SCP1000_WriteRegister8(int nRegAddr, int nData) 
.................... { 
....................    i2c_start(); 
*
0136C:  BSF    F95.5
0136E:  MOVLW  02
01370:  MOVWF  00
01372:  DECFSZ 00,F
01374:  BRA    1372
01376:  BSF    F95.6
01378:  MOVLW  02
0137A:  MOVWF  00
0137C:  DECFSZ 00,F
0137E:  BRA    137C
01380:  BCF    F8C.5
01382:  BCF    F95.5
01384:  MOVLW  02
01386:  MOVWF  00
01388:  DECFSZ 00,F
0138A:  BRA    1388
0138C:  BCF    F8C.6
0138E:  BCF    F95.6
....................  
....................    if(i2c_write(SCP1000_ADDRESS))           // Send the address of the device 
01390:  MOVLW  22
01392:  MOVLB  9
01394:  MOVWF  xF6
01396:  MOVLB  0
01398:  RCALL  12F6
0139A:  MOVF   01,W
0139C:  BZ    13A4
....................       return 0xAA;   //NO ACK 
0139E:  MOVLW  AA
013A0:  MOVWF  01
013A2:  BRA    13DE
....................  
....................    if(i2c_write(nRegAddr)) 
013A4:  MOVFF  9F4,9F6
013A8:  RCALL  12F6
013AA:  MOVF   01,W
013AC:  BZ    13B4
....................       return 0xAB; 
013AE:  MOVLW  AB
013B0:  MOVWF  01
013B2:  BRA    13DE
....................      
....................    i2c_write(nData);       
013B4:  MOVFF  9F5,9F6
013B8:  RCALL  12F6
....................  
....................    i2c_stop(); 
013BA:  BCF    F95.5
013BC:  NOP   
013BE:  BSF    F95.6
013C0:  BTFSS  F83.6
013C2:  BRA    13C0
013C4:  MOVLW  02
013C6:  MOVWF  00
013C8:  DECFSZ 00,F
013CA:  BRA    13C8
013CC:  BRA    13CE
013CE:  NOP   
013D0:  BSF    F95.5
013D2:  MOVLW  02
013D4:  MOVWF  00
013D6:  DECFSZ 00,F
013D8:  BRA    13D6
....................     
....................    return 0; 
013DA:  MOVLW  00
013DC:  MOVWF  01
.................... } 
013DE:  GOTO   23C6 (RETURN)
....................  
.................... int16 SCP1000_ReadRegister16(int nRegAddr) 
.................... { 
....................    int16 nTemp; 
....................     
....................    i2c_start(); 
....................  
....................    if(i2c_write(SCP1000_ADDRESS))           // Send the address of the device 
....................       return 0xAA;   //No ACK 
....................  
....................    i2c_write(nRegAddr); 
....................     
....................    i2c_start(); 
....................    i2c_write(SCP1000_ADDRESS| 0x01);           // Send the address of the device 
....................     
....................    nTemp = i2c_read(1);      
....................    nTemp <<= 8; 
....................    nTemp += i2c_read(0);      
....................  
....................    i2c_stop(); 
....................  
....................    return nTemp;   
.................... } 
....................  
.................... int   SCP1000_ReadID() 
.................... { 
....................    return SCP1000_ReadRegister8(SCPREG_REVID);   
.................... } 
....................  
.................... int   SCP1000_ReadStatus() 
.................... { 
....................    return SCP1000_ReadRegister8(SCPREG_STATUS);   
....................   
.................... } 
....................  
.................... int16 SCP1000_ReadTemperature() 
.................... { 
....................    return SCP1000_ReadRegister16(SCPREG_TEMPOUT); 
.................... } 
....................  
.................... int16 SCP1000_ReadPressure() 
.................... { 
....................    return SCP1000_ReadRegister16(SCPREG_DATARD16); 
....................  
.................... } 
....................  
.................... void SCP1000_Reset() 
.................... { 
....................    SCP1000_WriteRegister8(SCPREG_RSTR, 0x01);   //Reset software 
.................... } 
....................  
.................... int SCP1000_SelfTest() 
.................... { 
....................    SCP1000_WriteRegister8(SCPREG_OPERATION, SCPOP_SELFTEST); //Self test 
....................    delay_ms(100); 
....................    return SCP1000_ReadRegister8(SCPREG_DATARD8); 
.................... } 
.................... #endif 
....................  
....................  
.................... int nSCPStatus; 
.................... int16 nSCPTemperature, nSCPPressure; 
.................... double fSCPTemperature, fSCPPressure; 
.................... double fSCPAltitude; 
.................... double fBatteryVoltage; 
....................  
.................... void senseBattery() 
.................... { 
....................    long nTemp; 
....................        
....................      //Read battery voltage 
....................      set_adc_channel(ADCCH_BATT); 
*
01690:  MOVLW  00
01692:  MOVWF  01
01694:  MOVF   FC2,W
01696:  ANDLW  C3
01698:  IORWF  01,W
0169A:  MOVWF  FC2
....................      nTemp = 0; 
0169C:  MOVLB  9
0169E:  CLRF   xF5
016A0:  CLRF   xF4
....................      delay_us(10); 
016A2:  MOVLW  27
016A4:  MOVWF  00
016A6:  DECFSZ 00,F
016A8:  BRA    16A6
016AA:  BRA    16AC
....................      nTemp = read_adc(); 
016AC:  BSF    FC2.1
016AE:  BTFSC  FC2.1
016B0:  BRA    16AE
016B2:  MOVFF  FC3,9F4
016B6:  MOVFF  FC4,9F5
....................      fBatteryVoltage = nTemp; 
016BA:  MOVFF  9F5,9F7
016BE:  MOVFF  9F4,9F6
016C2:  MOVLB  0
016C4:  BRA    13E2
016C6:  MOVFF  03,9E3
016CA:  MOVFF  02,9E2
016CE:  MOVFF  01,9E1
016D2:  MOVFF  00,9E0
....................      fBatteryVoltage = fBatteryVoltage*fVLDO*2/65535.0; 
016D6:  MOVFF  9E3,A08
016DA:  MOVFF  9E2,A07
016DE:  MOVFF  9E1,A06
016E2:  MOVFF  9E0,A05
016E6:  MOVFF  706,A0C
016EA:  MOVFF  705,A0B
016EE:  MOVFF  704,A0A
016F2:  MOVFF  703,A09
016F6:  RCALL  141A
016F8:  MOVFF  00,9F6
016FC:  MOVFF  01,9F7
01700:  MOVFF  02,9F8
01704:  MOVFF  03,9F9
01708:  MOVFF  03,A08
0170C:  MOVFF  02,A07
01710:  MOVFF  01,A06
01714:  MOVFF  00,A05
01718:  MOVLB  A
0171A:  CLRF   x0C
0171C:  CLRF   x0B
0171E:  CLRF   x0A
01720:  MOVLW  80
01722:  MOVWF  x09
01724:  MOVLB  0
01726:  RCALL  141A
01728:  MOVFF  00,9FA
0172C:  MOVFF  01,9FB
01730:  MOVFF  02,9FC
01734:  MOVFF  03,9FD
01738:  MOVFF  03,A01
0173C:  MOVFF  02,A00
01740:  MOVFF  01,9FF
01744:  MOVFF  00,9FE
01748:  MOVLB  A
0174A:  CLRF   x05
0174C:  MOVLW  FF
0174E:  MOVWF  x04
01750:  MOVLW  7F
01752:  MOVWF  x03
01754:  MOVLW  8E
01756:  MOVWF  x02
01758:  MOVLB  0
0175A:  BRA    1510
0175C:  MOVFF  03,9E3
01760:  MOVFF  02,9E2
01764:  MOVFF  01,9E1
01768:  MOVFF  00,9E0
.................... } 
0176C:  GOTO   1780 (RETURN)
....................  
.................... void displayGPSSNRBar(int x, int y, int nSat) 
.................... { 
....................    int nSNR, nOrgSNR; 
....................    int16 nSNRColor; 
....................    nSNRColor = 0xF800;   //Blue 
*
01D84:  MOVLW  F8
01D86:  MOVLB  9
01D88:  MOVWF  xFE
01D8A:  CLRF   xFD
....................     
....................    nOrgSNR = recGPSData.satSNR[nSat]; 
01D8C:  CLRF   03
01D8E:  MOVF   xFA,W
01D90:  ADDLW  2F
01D92:  MOVWF  01
01D94:  MOVLW  00
01D96:  ADDWFC 03,F
01D98:  MOVF   01,W
01D9A:  ADDLW  27
01D9C:  MOVWF  FE9
01D9E:  MOVLW  09
01DA0:  ADDWFC 03,W
01DA2:  MOVWF  FEA
01DA4:  MOVFF  FEF,9FC
....................     
....................    if(nOrgSNR < 0x80) 
01DA8:  MOVF   xFC,W
01DAA:  SUBLW  7F
01DAC:  BNC   1DB6
....................          nSNRColor = 0xC618; 
01DAE:  MOVLW  C6
01DB0:  MOVWF  xFE
01DB2:  MOVLW  18
01DB4:  MOVWF  xFD
....................           
....................           
....................    nOrgSNR = nOrgSNR&0x7F; 
01DB6:  BCF    xFC.7
....................    nSNR = nOrgSNR; 
01DB8:  MOVFF  9FC,9FB
....................     
....................    if(nSNR > 49) 
01DBC:  MOVF   xFB,W
01DBE:  SUBLW  31
01DC0:  BC    1DC6
....................       nSNR = 50; 
01DC2:  MOVLW  32
01DC4:  MOVWF  xFB
....................    nSNR/=2; 
01DC6:  BCF    FD8.0
01DC8:  RRCF   xFB,F
....................     
....................    
....................    LCD_Gotoxy(x+6,y-14); 
01DCA:  MOVLW  06
01DCC:  ADDWF  xF8,W
01DCE:  MOVWF  xFF
01DD0:  MOVLW  0E
01DD2:  SUBWF  xF9,W
01DD4:  MOVLB  A
01DD6:  MOVWF  x00
01DD8:  MOVFF  9FF,A02
01DDC:  MOVWF  x03
01DDE:  MOVLB  0
01DE0:  RCALL  1818
....................    printf(LCD_PutChar, "%02d", nSat+1); 
01DE2:  MOVLW  01
01DE4:  MOVLB  9
01DE6:  ADDWF  xFA,W
01DE8:  MOVWF  xFF
01DEA:  MOVFF  FE8,A00
01DEE:  MOVLW  01
01DF0:  MOVLB  A
01DF2:  MOVWF  x01
01DF4:  MOVLB  0
01DF6:  RCALL  1984
....................     
....................     gps_FloodFill(x, y-32- 25, x+23, y-16-nSNR-1, bkgColor); 
01DF8:  MOVLW  20
01DFA:  MOVLB  9
01DFC:  SUBWF  xF9,W
01DFE:  ADDLW  E7
01E00:  MOVLB  A
01E02:  MOVWF  x00
01E04:  MOVLW  17
01E06:  MOVLB  9
01E08:  ADDWF  xF8,W
01E0A:  MOVLB  A
01E0C:  MOVWF  x01
01E0E:  MOVLW  10
01E10:  MOVLB  9
01E12:  SUBWF  xF9,W
01E14:  BSF    FD8.0
01E16:  SUBFWB xFB,W
01E18:  ADDLW  FF
01E1A:  MOVLB  A
01E1C:  MOVWF  x04
01E1E:  MOVFF  9F8,A05
01E22:  MOVFF  A00,A06
01E26:  MOVFF  A01,A07
01E2A:  MOVWF  x08
01E2C:  MOVFF  2F,A0A
01E30:  MOVFF  2E,A09
01E34:  MOVLB  0
01E36:  RCALL  1CDE
....................    
....................     gps_FloodFill(x, y-16-nSNR-1, x+23, y-16, nSNRColor); 
01E38:  MOVLW  10
01E3A:  MOVLB  9
01E3C:  SUBWF  xF9,W
01E3E:  BSF    FD8.0
01E40:  SUBFWB xFB,W
01E42:  ADDLW  FF
01E44:  MOVLB  A
01E46:  MOVWF  x01
01E48:  MOVLW  17
01E4A:  MOVLB  9
01E4C:  ADDWF  xF8,W
01E4E:  MOVLB  A
01E50:  MOVWF  x02
01E52:  MOVLW  10
01E54:  MOVLB  9
01E56:  SUBWF  xF9,W
01E58:  MOVLB  A
01E5A:  MOVWF  x03
01E5C:  MOVFF  9F8,A05
01E60:  MOVFF  A01,A06
01E64:  MOVFF  A02,A07
01E68:  MOVWF  x08
01E6A:  MOVFF  9FE,A0A
01E6E:  MOVFF  9FD,A09
01E72:  MOVLB  0
01E74:  RCALL  1CDE
....................  
....................     LCD_Gotoxy(x+6,y-32-nSNR); 
01E76:  MOVLW  06
01E78:  MOVLB  9
01E7A:  ADDWF  xF8,W
01E7C:  MOVWF  xFF
01E7E:  MOVLW  20
01E80:  SUBWF  xF9,W
01E82:  BSF    FD8.0
01E84:  SUBFWB xFB,W
01E86:  MOVLB  A
01E88:  MOVWF  x01
01E8A:  MOVFF  9FF,A02
01E8E:  MOVWF  x03
01E90:  MOVLB  0
01E92:  RCALL  1818
....................    printf(LCD_PutChar, "%02d", nOrgSNR); 
01E94:  MOVFF  9FC,A00
01E98:  MOVLW  01
01E9A:  MOVLB  A
01E9C:  MOVWF  x01
01E9E:  MOVLB  0
01EA0:  RCALL  1984
....................    
.................... } 
01EA2:  GOTO   1FB6 (RETURN)
....................  
.................... void displayGPSSNR() 
.................... { 
....................    int i, nTotalValidSat; 
....................    int x, y; 
....................    nTotalValidSat = 0; 
01EA6:  MOVLB  9
01EA8:  CLRF   xF5
....................     
....................    //Display GPS time 
....................    LCD_Gotoxy(0,0); 
01EAA:  MOVLB  A
01EAC:  CLRF   x02
01EAE:  CLRF   x03
01EB0:  MOVLB  0
01EB2:  RCALL  1818
....................    printf(LCD_PutChar, "%02d:%02d:%02d", recGPSData.time.tm_hour,recGPSData.time.tm_min, recGPSData.time.tm_sec); 
01EB4:  MOVFF  92D,A00
01EB8:  MOVLW  01
01EBA:  MOVLB  A
01EBC:  MOVWF  x01
01EBE:  MOVLB  0
01EC0:  RCALL  1984
01EC2:  MOVLW  3A
01EC4:  MOVLB  A
01EC6:  MOVWF  x06
01EC8:  MOVLB  0
01ECA:  RCALL  1964
01ECC:  MOVFF  92E,A00
01ED0:  MOVLW  01
01ED2:  MOVLB  A
01ED4:  MOVWF  x01
01ED6:  MOVLB  0
01ED8:  RCALL  1984
01EDA:  MOVLW  3A
01EDC:  MOVLB  A
01EDE:  MOVWF  x06
01EE0:  MOVLB  0
01EE2:  RCALL  1964
01EE4:  MOVFF  92F,A00
01EE8:  MOVLW  01
01EEA:  MOVLB  A
01EEC:  MOVWF  x01
01EEE:  MOVLB  0
01EF0:  RCALL  1984
....................  
....................  
....................    printf(LCD_PutChar, " GPS%02d", recGPSData.numSat); 
01EF2:  MOVLB  9
01EF4:  CLRF   xF8
01EF6:  MOVF   xF8,W
01EF8:  MOVLB  0
01EFA:  CALL   0706
01EFE:  MOVLB  9
01F00:  INCF   xF8,F
01F02:  MOVWF  00
01F04:  MOVFF  FE8,A06
01F08:  MOVLB  0
01F0A:  RCALL  1964
01F0C:  MOVLW  04
01F0E:  MOVLB  9
01F10:  SUBWF  xF8,W
01F12:  BNZ   1EF6
01F14:  MOVFF  94C,A00
01F18:  MOVLW  01
01F1A:  MOVLB  A
01F1C:  MOVWF  x01
01F1E:  MOVLB  0
01F20:  RCALL  1984
....................  
....................    //Display battery level 
....................     LCD_Gotoxy(208-32, 0); 
01F22:  MOVLW  B0
01F24:  MOVLB  A
01F26:  MOVWF  x02
01F28:  CLRF   x03
01F2A:  MOVLB  0
01F2C:  RCALL  1818
....................     printf(LCD_PutChar, "%3.1fV", fBatteryVoltage); 
01F2E:  MOVLW  02
01F30:  MOVWF  FE9
01F32:  MOVFF  9E3,9FB
01F36:  MOVFF  9E2,9FA
01F3A:  MOVFF  9E1,9F9
01F3E:  MOVFF  9E0,9F8
01F42:  MOVLW  01
01F44:  MOVLB  9
01F46:  MOVWF  xFC
01F48:  MOVLB  0
01F4A:  BRA    1B26
01F4C:  MOVLW  56
01F4E:  MOVLB  A
01F50:  MOVWF  x06
01F52:  MOVLB  0
01F54:  RCALL  1964
....................      
....................     for(i=0; i<32; i++) 
01F56:  MOVLB  9
01F58:  CLRF   xF4
01F5A:  MOVF   xF4,W
01F5C:  SUBLW  1F
01F5E:  BNC   1FC6
....................     { 
....................        if(recGPSData.satSNR[i] != 0xFF) 
01F60:  CLRF   03
01F62:  MOVF   xF4,W
01F64:  ADDLW  2F
01F66:  MOVWF  01
01F68:  MOVLW  00
01F6A:  ADDWFC 03,F
01F6C:  MOVF   01,W
01F6E:  ADDLW  27
01F70:  MOVWF  FE9
01F72:  MOVLW  09
01F74:  ADDWFC 03,W
01F76:  MOVWF  FEA
01F78:  INCFSZ FEF,W
01F7A:  BRA    1F7E
01F7C:  BRA    1FC2
....................        { 
....................           x = (nTotalValidSat%6)*30 + 18; 
01F7E:  MOVFF  9F5,A06
01F82:  MOVLW  06
01F84:  MOVLB  A
01F86:  MOVWF  x07
01F88:  MOVLB  0
01F8A:  RCALL  1822
01F8C:  MOVF   00,W
01F8E:  MULLW  1E
01F90:  MOVF   FF3,W
01F92:  ADDLW  12
01F94:  MOVLB  9
01F96:  MOVWF  xF6
....................           y= nTotalValidSat>5?174:94; 
01F98:  MOVF   xF5,W
01F9A:  SUBLW  05
01F9C:  BC    1FA2
01F9E:  MOVLW  AE
01FA0:  BRA    1FA4
01FA2:  MOVLW  5E
01FA4:  MOVWF  xF7
....................  
....................           displayGPSSNRBar(x, y, i); 
01FA6:  MOVFF  9F6,9F8
01FAA:  MOVFF  9F7,9F9
01FAE:  MOVFF  9F4,9FA
01FB2:  MOVLB  0
01FB4:  BRA    1D84
....................            
....................           if(++nTotalValidSat > 12)   //Show maximum 12 satellites 
01FB6:  MOVLB  9
01FB8:  INCF   xF5,F
01FBA:  MOVF   xF5,W
01FBC:  SUBLW  0C
01FBE:  BC    1FC2
....................              break;         
01FC0:  BRA    1FC6
....................        } 
....................         
....................       //realtimeProcess(); 
....................        
....................     } 
01FC2:  INCF   xF4,F
01FC4:  BRA    1F5A
....................     
....................     for(i=nTotalValidsat; i<12; i++) 
01FC6:  MOVFF  9F5,9F4
01FCA:  MOVF   xF4,W
01FCC:  SUBLW  0B
01FCE:  BNC   2028
....................     { 
....................         x = (i%6)*30 + 18; 
01FD0:  MOVFF  9F4,A06
01FD4:  MOVLW  06
01FD6:  MOVLB  A
01FD8:  MOVWF  x07
01FDA:  MOVLB  0
01FDC:  RCALL  1822
01FDE:  MOVF   00,W
01FE0:  MULLW  1E
01FE2:  MOVF   FF3,W
01FE4:  ADDLW  12
01FE6:  MOVLB  9
01FE8:  MOVWF  xF6
....................         y= i>5?174:94; 
01FEA:  MOVF   xF4,W
01FEC:  SUBLW  05
01FEE:  BC    1FF4
01FF0:  MOVLW  AE
01FF2:  BRA    1FF6
01FF4:  MOVLW  5E
01FF6:  MOVWF  xF7
....................             gps_FloodFill(x, y-32-25, x+23, y, bkgColor); 
01FF8:  MOVLW  20
01FFA:  SUBWF  xF7,W
01FFC:  ADDLW  E7
01FFE:  MOVWF  xF9
02000:  MOVLW  17
02002:  ADDWF  xF6,W
02004:  MOVWF  xFA
02006:  MOVFF  9F6,A05
0200A:  MOVFF  9F9,A06
0200E:  MOVFF  FE8,A07
02012:  MOVFF  9F7,A08
02016:  MOVFF  2F,A0A
0201A:  MOVFF  2E,A09
0201E:  MOVLB  0
02020:  RCALL  1CDE
....................  
....................     } 
02022:  MOVLB  9
02024:  INCF   xF4,F
02026:  BRA    1FCA
....................    
....................      
.................... } 
02028:  MOVLB  0
0202A:  RETLW  00
....................  
.................... void realtimeProcess() 
.................... { 
.................... //     while(g_nGPSSentences)   //New sentence received,  
.................... //    { 
.................... //         GPSParser(); 
.................... //         g_nGPSSentences--; 
.................... //      } 
.................... } 
....................  
.................... void main() 
.................... { 
*
0214E:  CLRF   FF8
02150:  BCF    FF1.2
02152:  BCF    FF0.6
02154:  BCF    FF0.7
02156:  BCF    FF1.0
02158:  BSF    F9F.5
0215A:  BCF    FA5.5
0215C:  BSF    FD0.7
0215E:  BSF    0D.7
02160:  CLRF   FEA
02162:  CLRF   FE9
02164:  BCF    F7E.3
02166:  MOVLW  4D
02168:  MOVWF  FB0
0216A:  MOVLW  A6
0216C:  MOVWF  FAD
0216E:  MOVLW  90
02170:  MOVWF  FAC
02172:  BCF    F7C.3
02174:  MOVLW  19
02176:  MOVWF  FAB
02178:  MOVLW  A6
0217A:  MOVWF  FA8
0217C:  MOVLW  90
0217E:  MOVWF  F9C
02180:  MOVF   FC1,W
02182:  ANDLW  C0
02184:  MOVWF  FC1
02186:  MOVLW  07
02188:  MOVWF  FB4
0218A:  CLRF   2B
0218C:  CLRF   32
0218E:  CLRF   33
02190:  MOVLW  46
02192:  MOVLB  6
02194:  MOVWF  xC9
02196:  MOVLW  41
02198:  MOVWF  xCA
0219A:  MOVLW  54
0219C:  MOVWF  xCB
0219E:  MOVLW  3F
021A0:  MOVWF  xCC
021A2:  CLRF   xCD
021A4:  CLRF   xCE
021A6:  MOVLW  46
021A8:  MOVWF  xCF
021AA:  MOVLW  41
021AC:  MOVWF  xD0
021AE:  MOVLW  54
021B0:  MOVWF  xD1
021B2:  MOVLW  31
021B4:  MOVWF  xD2
021B6:  MOVLW  32
021B8:  MOVWF  xD3
021BA:  CLRF   xD4
021BC:  MOVLW  46
021BE:  MOVWF  xD5
021C0:  MOVLW  41
021C2:  MOVWF  xD6
021C4:  MOVLW  54
021C6:  MOVWF  xD7
021C8:  MOVLW  31
021CA:  MOVWF  xD8
021CC:  MOVLW  36
021CE:  MOVWF  xD9
021D0:  CLRF   xDA
021D2:  MOVLW  46
021D4:  MOVWF  xDB
021D6:  MOVLW  41
021D8:  MOVWF  xDC
021DA:  MOVLW  54
021DC:  MOVWF  xDD
021DE:  MOVLW  33
021E0:  MOVWF  xDE
021E2:  MOVLW  32
021E4:  MOVWF  xDF
021E6:  CLRF   xE0
021E8:  MOVLW  FF
021EA:  MOVWF  xE2
021EC:  MOVLW  80
021EE:  MOVLB  7
021F0:  MOVWF  x03
021F2:  MOVLW  3E
021F4:  MOVWF  x04
021F6:  MOVLW  EE
021F8:  MOVWF  x05
021FA:  MOVLW  63
021FC:  MOVWF  x06
021FE:  MOVLW  85
02200:  MOVWF  x07
02202:  MOVLW  4B
02204:  MOVWF  x08
02206:  MOVLW  EB
02208:  MOVWF  x09
0220A:  MOVLW  85
0220C:  MOVWF  x0A
0220E:  MOVLW  01
02210:  MOVWF  x0C
02212:  MOVLW  F4
02214:  MOVWF  x0D
02216:  MOVLW  01
02218:  MOVWF  x0E
0221A:  MOVLW  64
0221C:  MOVWF  x0F
0221E:  CLRF   x10
02220:  CLRF   x11
02222:  CLRF   x12
02224:  CLRF   x13
02226:  MOVLB  9
02228:  CLRF   x18
0222A:  CLRF   x19
0222C:  CLRF   x1A
0222E:  CLRF   x1B
02230:  CLRF   x1C
02232:  CLRF   x1D
02234:  CLRF   x1E
02236:  CLRF   x1F
02238:  CLRF   x20
0223A:  CLRF   x23
0223C:  CLRF   x24
0223E:  CLRF   x25
02240:  CLRF   x26
02242:  MOVLW  01
02244:  MOVWF  x76
02246:  CLRF   x77
02248:  CLRF   x78
0224A:  CLRF   x79
0224C:  CLRF   x7A
0224E:  CLRF   x7B
02250:  CLRF   x7C
02252:  CLRF   x7D
02254:  CLRF   x7E
02256:  CLRF   x7F
02258:  CLRF   x80
0225A:  CLRF   x81
0225C:  CLRF   x86
0225E:  CLRF   x87
02260:  CLRF   x88
02262:  CLRF   x89
02264:  CLRF   x8A
02266:  CLRF   x8B
02268:  CLRF   x8C
0226A:  CLRF   x8D
0226C:  CLRF   x8E
0226E:  CLRF   x8F
02270:  CLRF   x90
02272:  CLRF   x91
02274:  CLRF   x92
02276:  CLRF   x93
02278:  CLRF   x94
0227A:  CLRF   x95
0227C:  CLRF   x96
0227E:  CLRF   x97
02280:  CLRF   x98
02282:  CLRF   x99
02284:  CLRF   x9A
02286:  CLRF   x9B
02288:  CLRF   x9C
0228A:  CLRF   x9D
0228C:  CLRF   x9E
0228E:  CLRF   x9F
02290:  CLRF   xA0
02292:  CLRF   xA1
02294:  CLRF   xA2
02296:  CLRF   xA3
02298:  CLRF   xA4
0229A:  CLRF   xA5
0229C:  CLRF   xA6
0229E:  CLRF   xA7
022A0:  CLRF   xA8
022A2:  CLRF   xA9
022A4:  CLRF   xAA
022A6:  CLRF   xAB
022A8:  CLRF   xAC
022AA:  CLRF   xAD
022AC:  CLRF   xAE
022AE:  CLRF   xAF
022B0:  CLRF   xB0
022B2:  CLRF   xB1
022B4:  CLRF   xB2
022B6:  CLRF   xB3
022B8:  CLRF   xB4
022BA:  CLRF   xB5
022BC:  CLRF   xB6
022BE:  CLRF   xB7
022C0:  CLRF   xB8
022C2:  CLRF   xB9
022C4:  CLRF   xBA
022C6:  CLRF   xBB
022C8:  CLRF   xBC
022CA:  CLRF   xBD
022CC:  CLRF   xBE
022CE:  CLRF   xBF
022D0:  CLRF   xC0
022D2:  CLRF   xC1
022D4:  CLRF   xC2
022D6:  CLRF   xC3
022D8:  CLRF   xC4
022DA:  CLRF   xC5
022DC:  CLRF   xC6
022DE:  CLRF   xC7
022E0:  CLRF   xC8
....................    int32 i=0; 
022E2:  CLRF   xE4
022E4:  CLRF   xE5
022E6:  CLRF   xE6
022E8:  CLRF   xE7
....................    int16 nTemp; 
....................    int16 nPressure; 
....................    float fTemp; 
....................    int16 nTick=0; 
022EA:  CLRF   xF0
022EC:  CLRF   xF1
....................    char bSDReady=0; 
022EE:  CLRF   xF2
....................    int error; 
....................     
....................     
....................  
....................    //delay_ms(2000); 
....................    //output_high(LCD_BKLT); 
....................    //while(input(KEY_POWER) == 0); 
....................     
....................    output_high(POWER_OFF); 
022F0:  BCF    F97.2
022F2:  BSF    F8E.2
....................  
....................    PLLEN=1; //Enable 48MHz PLL 
022F4:  BSF    F9B.6
....................    RBPU = 0; 
022F6:  BCF    FF1.7
....................     
....................    setup_adc_ports(AN0_TO_AN3|VSS_VDD); 
022F8:  MOVF   FC1,W
022FA:  ANDLW  C0
022FC:  IORLW  0B
022FE:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32); 
02300:  MOVF   FC0,W
02302:  ANDLW  C0
02304:  IORLW  02
02306:  MOVWF  FC0
02308:  BSF    FC0.7
0230A:  BSF    FC2.0
0230C:  BSF    FC2.7
0230E:  BSF    FC2.1
02310:  BTFSC  FC2.1
02312:  BRA    2310
02314:  BCF    FC2.7
....................    setup_psp(PSP_DISABLED); 
02316:  BCF    FB0.4
....................    set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
02318:  MOVLW  93
0231A:  MOVWF  F94
....................    SPEN1=1; 
0231C:  BSF    FAC.7
....................    SPEN2=1; 
0231E:  BSF    F9C.7
....................    SETUP_SPI(SPI_MASTER | SPI_CLK_DIV_4 | SPI_H_TO_L |SPI_XMIT_L_TO_H ); 
02320:  BCF    FC6.5
02322:  MOVLW  30
02324:  MOVWF  FC6
02326:  MOVLW  00
02328:  MOVWF  FC7
....................  
....................    setup_wdt(WDT_OFF); 
0232A:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
0232C:  MOVLW  80
0232E:  MOVWF  FD5
....................    setup_timer_2(T2_DIV_BY_1,255,1); 
02330:  MOVLW  00
02332:  IORLW  04
02334:  MOVWF  FCA
02336:  MOVLW  FF
02338:  MOVWF  FCB
....................    //setup_timer_2(T2_DISABLED,0,1); 
....................    setup_timer_3(T3_INTERNAL|T3_DIV_BY_2); 
0233A:  MOVF   FB1,W
0233C:  ANDLW  48
0233E:  IORLW  95
02340:  MOVWF  FB1
....................    setup_timer_4(T4_DISABLED,0,1); 
02342:  MOVLW  00
02344:  MOVWF  F76
02346:  MOVLW  00
02348:  MOVWF  F77
....................    setup_comparator(NC_NC_NC_NC); 
0234A:  MOVLW  07
0234C:  MOVWF  FB4
0234E:  MOVF   F97,W
02350:  MOVLW  27
02352:  MOVWF  00
02354:  DECFSZ 00,F
02356:  BRA    2354
02358:  BRA    235A
0235A:  MOVF   FB4,W
0235C:  BCF    FA1.6
....................    setup_vref(FALSE); 
0235E:  CLRF   FB5
....................  
....................    set_timer0(5560);    //10ms interrupt 
02360:  MOVLW  15
02362:  MOVWF  FD7
02364:  MOVLW  B8
02366:  MOVWF  FD6
....................    //set_timer3(59543);    //1ms interrupt 
....................  
....................    enable_interrupts(INT_RDA); 
02368:  BSF    F9D.5
....................    enable_interrupts(INT_RDA2); 
0236A:  BSF    FA3.5
....................    enable_interrupts(INT_EXT); 
0236C:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
0236E:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
02370:  BSF    FF0.4
....................    enable_interrupts(INT_EXT3); 
02372:  BSF    FF0.5
....................    enable_interrupts(INT_RB); 
02374:  BSF    FF2.3
....................    enable_interrupts(INT_TIMER0); 
02376:  BSF    FF2.5
....................    enable_interrupts(GLOBAL); 
02378:  MOVLW  C0
0237A:  IORWF  FF2,F
....................  
....................    output_high(PIN_F3); //Debug TX 
0237C:  BCF    F97.3
0237E:  BSF    F8E.3
....................     
....................    output_low(SD_PWR);  //Turn on SD card power 
02380:  BCF    F8C.7
....................    gPrevCard = 1; 
02382:  MOVLW  01
02384:  MOVWF  xCE
....................     
....................  
....................    //Reset Bluetooth BGB203 
....................    output_low(BT_RST); 
02386:  BCF    F98.4
02388:  BCF    F8F.4
....................    delay_ms(2); 
0238A:  MOVLW  02
0238C:  MOVWF  xF5
0238E:  MOVLB  0
02390:  CALL   1108
....................    output_float(BT_RST); 
02394:  BSF    F98.4
....................    delay_ms(50); 
02396:  MOVLW  32
02398:  MOVLB  9
0239A:  MOVWF  xF5
0239C:  MOVLB  0
0239E:  CALL   1108
....................     
....................    //Initialize LCD 
....................    LCD_Init(); 
023A2:  GOTO   1156
....................    LCD_ClearScreen(); 
023A6:  GOTO   12A6
....................     
....................  
....................   
....................      
....................     delay_ms(100); 
023AA:  MOVLW  64
023AC:  MOVLB  9
023AE:  MOVWF  xF5
023B0:  MOVLB  0
023B2:  CALL   1108
.................... /*    SCP1000_WriteRegister8(SCPREG_RSTR, 0x01);   //Reset software 
....................    delay_ms(100); 
....................    SCP1000_WriteRegister8(0x03, 0x0F); //Self test 
....................    delay_ms(100); 
....................    if((SCP1000_ReadRegister8(SCPREG_DATARD8) == 0x01)) 
....................    { 
....................       LCD_gotoxy(0, 10*14); 
....................       printf(LCD_PutChar, "SCP: SelfTest failed."); 
....................       delay_ms(1000); 
....................    } 
....................    else 
....................    { 
....................       LCD_gotoxy(0, 10*14); 
....................       printf(LCD_PutChar, "SCP: SelfTest passed ."); 
....................    } 
....................    SCP1000_WriteRegister8(0x03, 0x07); 
.................... */ 
....................     
....................  
....................    //SCP1000_WriteRegister8(0x03, 0x0A);   //09: High speed mode, 0A: High resolution mode 
....................    SCP1000_WriteRegister8(SCPREG_OPERATION, SCPOP_TRIG);   
023B6:  MOVLW  03
023B8:  MOVLB  9
023BA:  MOVWF  xF4
023BC:  MOVLW  0C
023BE:  MOVWF  xF5
023C0:  MOVLB  0
023C2:  GOTO   136C
....................     
....................    nLEDTimer = 1500; 
023C6:  MOVLW  05
023C8:  MOVLB  7
023CA:  MOVWF  x0E
023CC:  MOVLW  DC
023CE:  MOVWF  x0D
....................     
....................    ReadSensors(); 
023D0:  MOVLB  0
023D2:  CALL   1770
....................  
....................    //Turn on GPS  
....................    output_high(GPS_EN); 
023D6:  BCF    F92.4
023D8:  BSF    F89.4
....................     
....................    while(1) 
....................    { 
....................    /*   
....................          if(g_nPwrBtnHoldTick > 300)   //Hold Power key for more than 3 seconds 
....................          { 
....................             output_low(GPS_EN);   //Turn off GPS 
....................             output_high(SD_PWR);   //Turn off SD Card 
....................           output_low(BT_RST);      //Turn off BT 
....................            LCD_Shutdown(); 
....................             delay_ms(200); 
....................             output_low(LCD_BKLT); 
....................             output_low(POWER_OFF); 
....................          } 
.................... */ 
....................       //if(nLEDTimer == 0) 
....................        //  output_low(LCD_BKLT); 
....................  
....................       //realtimeProcess(); 
....................            
....................         if(g_bGPSDataReady)   //All sentence parsed, we can display or save GPS data now 
023DA:  MOVLB  9
023DC:  BTFSS  x76.3
023DE:  BRA    23E8
....................         { 
....................            //LCD_ClearScreen(); 
....................            displayGPSSNR(); 
023E0:  MOVLB  0
023E2:  RCALL  1EA6
....................            g_bGPSDataReady = 0; 
023E4:  MOVLB  9
023E6:  BCF    x76.3
....................            
....................         } 
....................          
....................         if(nSampleTimer) 
023E8:  MOVLB  7
023EA:  MOVF   x0F,F
023EC:  BZ    23F6
....................          continue; 
023EE:  MOVLB  0
023F0:  BRA    23DA
....................       else 
023F2:  BRA    2400
023F4:  MOVLB  7
....................       { 
....................          nSampleTimer = 100; 
023F6:  MOVLW  64
023F8:  MOVWF  x0F
....................          ReadSensors(); 
023FA:  MOVLB  0
023FC:  CALL   1770
....................       } 
....................        
....................     displayGPSSNR(); 
02400:  RCALL  1EA6
.................... 	LCD_Gotoxy(0, 160); 
02402:  MOVLB  A
02404:  CLRF   x02
02406:  MOVLW  A0
02408:  MOVWF  x03
0240A:  MOVLB  0
0240C:  CALL   1818
....................     printf(LCD_PutChar, "%04ld", i++); 
02410:  MOVLB  9
02412:  MOVFF  9E7,03
02416:  MOVFF  9E6,02
0241A:  MOVFF  9E5,01
0241E:  MOVFF  9E4,00
02422:  MOVLW  01
02424:  ADDWF  xE4,F
02426:  BTFSC  FD8.0
02428:  INCF   xE5,F
0242A:  BTFSC  FD8.2
0242C:  INCF   xE6,F
0242E:  BTFSC  FD8.2
02430:  INCF   xE7,F
02432:  MOVFF  03,9F7
02436:  MOVFF  02,9F6
0243A:  MOVFF  01,9F5
0243E:  MOVFF  00,9F4
02442:  MOVLW  44
02444:  MOVWF  FE9
02446:  MOVFF  03,9FB
0244A:  MOVFF  02,9FA
0244E:  MOVFF  01,9F9
02452:  MOVFF  00,9F8
02456:  MOVLB  0
02458:  BRA    202C
.................... 	} 
0245A:  BRA    23DA
.................... } 
.................... /* 
....................         
....................        if(input(CHARGE_IND) == 0) 
....................          printf(LCD_PutChar, "-->>"); 
....................        else 
....................          printf(LCD_PutChar, "    "); 
....................         
....................           
....................        LCD_Gotoxy(0, 3*14); 
....................        printf(LCD_PutChar, "HMC1052: X=%lu, Y=%lu ", nHMCA, nHMCB); 
....................         
....................        LCD_Gotoxy(0, 4*14); 
....................        printf(LCD_PutChar, "GPS:"); 
....................        printf(LCD_PutChar, "%lu bytes received", g_nGPSBufferWritePtr); 
....................   
....................         LCD_Gotoxy(0, 5*14); 
....................        printf(LCD_PutChar, "BGB203:"); 
....................        printf(LCD_PutChar, "%lu bytes received", nReceived2); 
....................        LCD_Gotoxy(0, 6*14); 
....................           if(nTick == 2) 
....................             fprintf(BT_232, "+++\r\n"); 
....................          else if(nTick == 3) 
....................             fprintf(BT_232, sCmdBTLNM); 
....................          else if(nTick == 4) 
....................             fprintf(BT_232, sCmdBTAUT); 
....................          else if(nTick == 5) 
....................            fprintf(BT_232, sCmdBTSRV); 
....................          else if(nTick == 6) 
....................             g_bGPStoBT = 1; 
....................          
....................        if(nReceived2 > 0) 
....................        { 
....................          printf(LCD_PutChar, "%s", sBTBuffer); 
....................        } 
....................         
....................        LCD_Gotoxy(0, 7*14); 
....................        printf(LCD_PutChar, "Key:"); 
....................         
....................        //g_nKeyNewState = input_b(); 
....................       LCD_Gotoxy(4*8, 7*14); 
....................       printf(LCD_PutChar, "0x%02x", g_nKeyNewState); 
....................        
....................       //SD test 
....................       gActCard = input(CardInserted);  
....................  
....................       if(gActCard)    
....................       { 
....................          if(gPrevCard == 0 && hFile != 0xFF)   //Card will be pulled out while a file is still open 
....................          { 
....................             fclose(hFile); 
....................             hFile = 0xFF; 
....................          } 
....................          bSDReady = 0; 
....................           LCD_Gotoxy(0, 8*14); 
....................          printf(LCD_PutChar, "SD: No SD.     "); 
....................      } 
....................  
....................  
....................       if (gActCard == 0 && gPrevCard != 0)  // card was pulled out then pushed back now  
....................       { 
....................          bSDReady = 0; 
....................          error  = 1; 
....................  
....................          //SaveConfig(); 
....................  
....................          set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
....................          SETUP_SPI(SPI_MASTER | SPI_CLK_DIV_4 | SPI_H_TO_L |SPI_XMIT_L_TO_H ); 
....................  
....................  
....................          LCD_Gotoxy(0, 8*14); 
....................          printf(LCD_PutChar, "SD: Inserted."); 
....................  
....................          delay_ms(50);  
....................          for(i=0; i<10&&error; i++) 
....................          { 
....................            LCD_Gotoxy(0, 8*14); 
....................            printf(LCD_PutChar, "SD: Init... "); 
....................             error = init_mmc(10); 
....................             delay_ms(50);  
....................          }   
....................  
....................          LCD_Gotoxy(0, 8*14); 
....................          if(!error) 
....................          { 
....................             printf(LCD_PutChar, "SD: Init OK."); 
....................          } 
....................          else 
....................              printf(LCD_PutChar, "SD: Init Failed."); 
....................  
....................          if(InitFAT() != MMC_NO_ERR) 
....................          { 
....................              LCD_Gotoxy(0, 8*14); 
....................             printf(LCD_PutChar, "SD: FAT faile: 0x%02X.", gFATErrCode); 
....................          } 
....................  
....................  
....................          if(!error) 
....................          {    
....................             hFile = 0xFF; 
....................             bSDReady = 1; 
....................             LCD_Gotoxy(0, 8*14); 
....................             printf(LCD_PutChar, "SD: ");  
....................             printf(LCD_PutChar, "%s ", sFATName[gFATType]); 
....................             printf(LCD_PutChar, "%luMB", DiskInfo.TotSec16!=0?DiskInfo.TotSec16/2000:DiskInfo.TotSec32/2000); 
....................         }                
....................  
....................       } //Card inserted 
....................        
....................       gPrevCard = gActCard; 
....................         
....................       LCD_Gotoxy(0, 9*14); 
....................      //SETUP_SPI(SPI_MASTER | SPI_CLK_DIV_4 | SPI_H_TO_L |SPI_XMIT_L_TO_H ); 
....................      setup_spi(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_4|SPI_SAMPLE_AT_END); 
....................      i = AT26_ReadDeviceID(); 
....................      //error = AT26_ReadSectorProtection(0x30000); 
....................      AT26_WriteEnable(); 
....................       
....................      if(nTick == 1) 
....................          AT26_UnprotectSector(0); 
....................      if(nTick == 2) 
....................      { 
....................          AT26_WriteStatusRegister(0x00); //Global unprotect 
....................          AT26_BlockErase4K(0); 
....................      } 
....................      if(nTick == 5) 
....................          AT26_WriteByte(0, 'W'); 
....................      else if(nTick == 9) 
....................          AT26_WriteByte(1, 'F'); 
....................           
....................       nTemp = AT26_ReadByte(0); 
....................      
....................       error = AT26_ReadStatusRegister(); 
....................      printf(LCD_PutChar, "FLASH:0x%02X,0x%02X,%08lX", error, (int)nTemp, i);  
....................        
....................       //SCP1000 
....................       LCD_Gotoxy(0, 1*14); 
....................      nTemp = SCP1000_ReadID(); 
....................       nSCPStatus = SCP1000_ReadStatus(); 
....................       if(nSCPStatus & 0x20)   //data ready 
....................       { 
....................          nSCPTemperature = SCP1000_ReadTemperature(); 
....................           nPressure = SCP1000_ReadRegister8(SCPREG_DATARD8); 
....................           nPressure &= 0x07; 
....................         nSCPPressure = SCP1000_ReadPressure(); 
....................         fSCPTemperature = nSCPTemperature; 
....................         fSCPTemperature = fSCPTemperature/20; 
....................         fSCPPressure = nPressure; 
....................         fSCPPressure *= 0x10000; 
....................         fSCPPressure += nSCPPressure; 
....................         fSCPPressure *= 0.25; 
....................         fSCPPressure /= 1000; 
....................         //fSCPAltitude = -(log(fSCPPressure/fStandardPressure)*(273.2+fSCPTemperature)*287.1/9.80665); 
....................         fSCPAltitude = 44330*(1-pow((fSCPPressure/fStandardPressure),0.19)); 
....................          
....................          printf(LCD_PutChar, "SCP:%02X,%4.1fC, %8.4fkpa", nSCPStatus, fSCPTemperature, fSCPPressure); 
....................          LCD_Gotoxy(0, 2*14); 
....................          printf(LCD_PutChar, "SCP:%5.1fM ", fSCPAltitude); 
....................        
....................         
....................          SCP1000_WriteRegister8(SCPREG_OPERATION, SCPOP_TRIG);   
....................       } 
....................       else 
....................       { 
....................          printf(LCD_PutChar, "SCP:%02X          ", nSCPStatus); 
....................       } 
....................  
....................          LCD_Gotoxy(0, 160); 
....................          printf(LCD_PutChar, "%04ld %d %ld %ld ", nTick++, nSampleTimer, get_timer3(), get_timer0()); 
....................      
.................... //      delay_ms(1000); 
....................    } 
....................    Sleep(); 
.................... } 
....................  
....................  
.................... */ 
0245C:  SLEEP 

Configuration Fuses:
   Word  1: F7AE   PLL_DIV1 EXT_CPU NODEBUG NOEXTCPU STVREN NOWDT NOPROTECT RESERVED CPUDIV1
   Word  2: FFC5   WDT32768 FCMEN IESO PRIMARY RESERVED HSPLLUSBHSPLL
   Word  3: F3F8   CCP2C1 RESERVED
