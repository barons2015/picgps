CCS PCH C Compiler, Version 4.057, 32216               30-May-08 21:59

               Filename: sdloader.lst

               ROM used: 20226 bytes (15%)
                         Largest free fragment is 65528
               RAM used: 2796 (73%) at main() level
                         2920 (76%) worst case
               Stack:    12 worst case (8 in main + 4 for interrupts)

*
00000:  GOTO   4B38
.................... /* 
.................... 	Program memory orgnization 
.................... 	0x000000~0x0003FF		Reserved for interrupt vector only. (minimum erase block is 1024 byte) 
.................... 	0x000400~0x004FFF	Reserved for MMC bootloader 
.................... 	0x005000~		User application 
.................... */ 
....................  
.................... #include "gpsLOADER.h" 
.................... #include <18F67J10.h> 
.................... //////// Standard Header file for the PIC18F67J10 device //////////////// 
.................... #device PIC18F67J10 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... //#define 4XCLOCK 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
....................  
.................... #ifdef 4XCLOCK 
.................... #FUSES H4_SW   
.................... #else 
.................... #FUSES HS                    	//High speed Osc (> 4mhz) 
.................... #endif 
....................  
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOIESO                	//Internal External Switch Over mode disabled 
.................... //#FUSES PRIMARY               	//Primary clock is system clock when scs=00 
....................  
.................... #ifdef 4XCLOCK 
.................... #use delay(clock=32000000) 
.................... #else 
.................... #use delay(clock=8000000) 
*
00584:  MOVLW  0B
00586:  MOVWF  FEA
00588:  MOVLW  60
0058A:  MOVWF  FE9
0058C:  MOVF   FEF,W
0058E:  BZ    05AA
00590:  MOVLW  02
00592:  MOVWF  01
00594:  CLRF   00
00596:  DECFSZ 00,F
00598:  BRA    0596
0059A:  DECFSZ 01,F
0059C:  BRA    0594
0059E:  MOVLW  97
005A0:  MOVWF  00
005A2:  DECFSZ 00,F
005A4:  BRA    05A2
005A6:  DECFSZ FEF,F
005A8:  BRA    0590
005AA:  RETLW  00
.................... #endif 
....................  
.................... #use rs232(baud=38400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use rs232(baud=38400,parity=N,xmit=PIN_G1,rcv=PIN_G2,bits=8, stream=debug) 
.................... #use i2c(master, sda=PIN_D6, scl=PIN_D5) 
....................  
.................... #byte OSCTUNE=0xF9B 
.................... #byte INTCON2=0xFF1 
.................... #bit RBPU=INTCON2.7 
....................  
.................... //#define _DEBUG 
.................... #ifdef _DEBUG 
.................... #define TRACE0(format)	fprintf(debug, format) 
.................... #define TRACE1(format, arg1)	fprintf(debug, format, arg1) 
.................... #define TRACE2(format, arg1, arg2)	fprintf(debug, format, arg1, arg2) 
.................... #define TRACE3(format, arg1, arg2, arg3)	fprintf(debug, format, arg1, arg2, arg3) 
.................... #define TRACE4(format, arg1, arg2, arg3, arg4)	fprintf(debug, format, arg1, arg2, arg3, arg4) 
.................... #else  
.................... #define TRACE0(format)	 
.................... #define TRACE1(format, arg1) 
.................... #define TRACE2(format, arg1, arg2) 
.................... #define TRACE3(format, arg1, arg2, arg3) 
.................... #define TRACE4(format, arg1, arg2, arg3, arg4) 
.................... #endif 
....................  
....................  
.................... #define _BOOTLOADER 
.................... #include "..\share\bootloader.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END and LOADER_SIZE may need to be adjusted for a         //// 
.................... ////  specific chip and bootloader.                                    //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... // Some defines for my bootloader.  
.................... //  
.................... // Include this file from the bootloader with MY_BOOTLOADER defined.  
.................... // Include this file from the applicatio with MY_BOOTLOADER not defined.  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RESET_VECTOR            0x0000      // Defined by hardware  
.................... #define HIGH_INT_VECTOR         0x0008      // Defined by hardware  
.................... #define NORMAL_INT_VECTOR       0x0018      // Defined by hardware  
.................... #define INTERRUPT_REMAP_END     HIGH_INT_VECTOR + 0x1B // End of the remap code  
....................  
.................... #define LOADER_START            INTERRUPT_REMAP_END+1 + 2 
.................... #define LOADER_END              0x04FFF        // Defined by size of the bootloader code and/or protection fuses  
.................... #define LOADER_RESET            RESET_VECTOR  
.................... #define LOADER_HIGH_INT         LOADER_START  
.................... #define LOADER_NORMAL_INT       LOADER_HIGH_INT + 0x10  
....................  
.................... #define APPLICATION_START       LOADER_END + 2  
.................... #define APPLICATION_RESET       APPLICATION_START + RESET_VECTOR  
.................... #define APPLICATION_HIGH_INT    APPLICATION_START + HIGH_INT_VECTOR  
.................... #define APPLICATION_NORMAL_INT  APPLICATION_START + NORMAL_INT_VECTOR  
....................  
.................... #ifdef _BOOTLOADER  
....................   #build(reset=LOADER_RESET, interrupt=LOADER_HIGH_INT)           // Move the reset and interrupt vectors  
.................... #else  
....................   #build(reset=APPLICATION_RESET, interrupt=APPLICATION_HIGH_INT) // Move the reset and interrupt vectors  
....................   #org 0, LOADER_END {}   // Reserve the bootloader memory area  
.................... #endif  
....................  
.................... // A global flag indicating the bootloader is active or not.  
.................... // This flag must be present in both the bootloader and application at the same  
.................... // address, that's why we place it here in the bootloader.h with a #locate  
.................... // instruction to fixed address 0x10. Address 0x10 was choosen arbitrarily in  
.................... // the start of memory above the CCS scratch register area (0x00 to 0x??).  
.................... int8 BootloaderActive;  
.................... #locate BootloaderActive=10  
....................  
....................  
.................... /* 
.................... #define LOADER_END   0x22FF 
.................... #define LOADER_SIZE	0x21FF 
....................  
.................... #define APP_START	LOADER_END+2 
.................... #define APP_RESET	APP_START 
.................... #define APP_INT	APP_START+8 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=APP_RESET, interrupt=APP_INT) 
.................... #org 0,LOADER_END {} 
.................... #else 
.................... #org LOADER_END+0x10, 0x7FFF {} 
.................... #endif 
.................... */ 
....................  
.................... #define BOOTLOADER_CFG_ADDR	255 
....................  
.................... #org HIGH_INT_VECTOR, INTERRUPT_REMAP_END  
.................... void isr_relocate(void)  
.................... {  
.................... #asm  
....................   // Address 0x0008 is the hardware High priority interrupt  
....................   TSTFSZ BootloaderActive       // if bootloader active  
*
00008:  TSTFSZ 0A
....................   goto  LOADER_HIGH_INT         // then jump to bootloader ISR  
0000A:  GOTO   0026
....................   GOTO  APPLICATION_HIGH_INT    // else jump to application ISR  
0000E:  GOTO   5008
....................   NOP 
00012:  NOP   
....................   NOP 
00014:  NOP   
....................   NOP                           // Just filling memory  
00016:  NOP   
....................  
....................   // Address 0x0018 is the hardware Low priority interrupt  
....................   TSTFSZ BootloaderActive       // if bootloader active  
00018:  TSTFSZ 0A
....................   goto   LOADER_NORMAL_INT      // then jump to bootloader ISR  
0001A:  GOTO   0036
....................   GOTO   APPLICATION_NORMAL_INT // else jump to application ISR  
0001E:  GOTO   5018
.................... #endasm  
.................... } 
00022:  RETLW  00
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
010DC:  MOVLB  B
010DE:  MOVFF  B31,FE9
010E2:  MOVFF  B32,FEA
010E6:  MOVFF  FEF,B35
010EA:  MOVFF  B34,03
010EE:  MOVFF  B33,FE9
010F2:  MOVFF  B34,FEA
010F6:  MOVF   FEF,W
010F8:  SUBWF  x35,W
010FA:  BNZ   1126
....................       if (*s1 == '\0') 
010FC:  MOVFF  B32,03
01100:  MOVFF  B31,FE9
01104:  MOVFF  03,FEA
01108:  MOVF   FEF,F
0110A:  BNZ   1112
....................          return(0); 
0110C:  MOVLW  00
0110E:  MOVWF  01
01110:  BRA    1150
01112:  MOVFF  B32,03
01116:  MOVF   x31,W
01118:  INCF   x31,F
0111A:  BTFSC  FD8.2
0111C:  INCF   x32,F
0111E:  INCF   x33,F
01120:  BTFSC  FD8.2
01122:  INCF   x34,F
01124:  BRA    10DE
....................    return((*s1 < *s2) ? -1: 1); 
01126:  MOVFF  B32,03
0112A:  MOVFF  B31,FE9
0112E:  MOVFF  B32,FEA
01132:  MOVFF  FEF,B35
01136:  MOVFF  B34,03
0113A:  MOVFF  B33,FE9
0113E:  MOVFF  B34,FEA
01142:  MOVF   FEF,W
01144:  SUBWF  x35,W
01146:  BC    114C
01148:  MOVLW  FF
0114A:  BRA    114E
0114C:  MOVLW  01
0114E:  MOVWF  01
.................... } 
01150:  MOVLB  0
01152:  GOTO   170C (RETURN)
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
00FAA:  MOVFF  B19,B1B
00FAE:  MOVFF  B18,B1A
00FB2:  MOVFF  B1B,03
00FB6:  MOVLB  B
00FB8:  MOVFF  B1A,FE9
00FBC:  MOVFF  B1B,FEA
00FC0:  MOVF   FEF,F
00FC2:  BZ    0FD0
00FC4:  INCF   x1A,F
00FC6:  BTFSC  FD8.2
00FC8:  INCF   x1B,F
00FCA:  MOVLB  0
00FCC:  BRA    0FB2
00FCE:  MOVLB  B
....................    return(sc - s); 
00FD0:  MOVF   x18,W
00FD2:  SUBWF  x1A,W
00FD4:  MOVWF  00
00FD6:  MOVF   x19,W
00FD8:  SUBWFB x1B,W
00FDA:  MOVWF  03
00FDC:  MOVFF  00,01
00FE0:  MOVWF  02
.................... } 
00FE2:  MOVLB  0
00FE4:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "2402.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC02B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    256 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
....................    ack = i2c_write(0xa0);  // then the device is ready. 
....................    i2c_stop(); 
....................    return !ack; 
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
....................  
....................  
.................... #ORG default 
.................... typedef struct  { 
.................... 	unsigned long    tm_year; 
.................... 	char            tm_mon; 
.................... 	char            tm_day; 
.................... 	char            tm_mday; 
.................... 	char            tm_hour; 
.................... 	char            tm_min; 
.................... 	char            tm_sec; 
.................... } TimeRecord; 
....................  
.................... TimeRecord myrec; 
....................  
.................... #define CardInserted PIN_B0 
.................... int gActCard, gPrevCard; 
....................  
.................... #include "MyMMCFat32.h" 
.................... #define MAXFILES 1  
.................... typedef struct _diskinforec  
.................... {  
.................... 	char   	JumpCode[3]; 	//0xEB??90 or 0xE9???? 
.................... 	char  	OEMName[8];  
.................... 	int16   BytsPerSec; 	//512, 1024 or 4096. Only 512 supported 
.................... 	char   	SecPerClus; 	//1~128 
.................... 	int16 	RsvdSecCnt; 	//Number of reserved sectors 
.................... 	char   	NumFATs; 	//Number of FAT data structure 
.................... 	int16 	RootEntCnt; 	//FAT12, FAT16: Number of root dir. FAT32: 0 
.................... 	int16 	TotSec16; 	//Total sectors. If 0 check TotalSectors32 
.................... 	char   	Media; 		//Media 
.................... 	int16 	FATSz16; 	//For FAT12/FAT16, Sectors per FAT. FAT32: 0 
.................... 	int16 	SecPerTrk; 	// 
.................... 	int16 	NumHeads; 	//Number of heads 
.................... 	int32   HiddSec; 	//Hidden sectors 
....................  
.................... 	int32   TotSec32; 	//If nSectors is 0, this is the total number of sectors 
....................  
.................... 	int32 	FATSz32;  
.................... 	int16 	ExtFlags;  
.................... 	int16 	FSVer;  
.................... 	int32 	RootClus;  
.................... } diskinforec;  
....................  
.................... typedef struct _direntry  
.................... {  
.................... 	char   sName[8];  
.................... 	char   sExt[3];  
.................... 	char   bAttr;  
.................... 	char   bReserved[8];  
.................... 	int16 	hClusterH;  
.................... 	int16   hTime;  
.................... 	int16   hDate;  
.................... 	int16   hCluster;  
.................... 	int32   wSize;  
.................... } DIR;  
....................  
.................... typedef struct  
.................... {  
.................... 	char	IOpuffer[512]; 		//Data buffer 
.................... 	DIR	DirEntry; 		//DIR entry 
.................... 	int32	CurrentCluster; 	//Current data cluster# 
.................... 	int	SecInCluster;		//Current sector# in cluster (0~DiskInfo.SecPerClus-1) 
.................... 	int16	posinsector; 		//Byte index in current sector (0~511) 
.................... 	int32   wFileSize; 		//Byte index in whole file 
.................... 	int32	dirSector; 		//DIR entry sector# 
.................... 	int16	dirIdx; 		//DIR entry index in sector 
.................... 	char	mode; 			//'a' append, 'w' over write, 'r' read only 
.................... 	char	Free;  
.................... }FILE;  
....................  
.................... typedef struct  
.................... {  
.................... 	int32 MMCAddress;  
.................... 	int32 FATstartidx;  
.................... 	int32 gStartSector;  
.................... 	int32 gFirstDataSector;  
.................... 	int16 gDirEntryIdx;  
.................... 	int32 gDirEntrySector;  
.................... 	int16 gFirstEmptyDirEntry;  
.................... 	int32 gFirstDirEntryCluster;  
.................... 	int32 nRootDirSectors; 
.................... 	int32 nFatSize; 
.................... 	int   bFATModified; 
.................... } FAT32Vars;  
....................  
.................... #define HANDLE	char 
....................  
.................... int InitFAT();  
.................... char FindDirEntry(char *fname, HANDLE hFile);  
....................  
.................... char fopen(char *fname, char mode);  
.................... void fclose(HANDLE hFile);  
.................... void fflush(HANDLE hFile);  
.................... char cwd(char *fname, HANDLE hFile);  
.................... void fputch(char ch, HANDLE hFile);  
.................... void fputchar(char ch){fputch(ch, 0);} 
.................... char fgetch(char *ch, HANDLE hFile);  
.................... void fputstring(char *str, HANDLE hFile); // fputs is reserved in CCS C  
.................... int16 fread(char *buffer, int16 leng, HANDLE hFile);  
.................... void fwrite(char *buffer, int16 leng, HANDLE hFile);  
.................... char remove(char *fname);  
.................... char getfsize(char *fname, int32 *fsiz);  
....................  
.................... #include "MyMMCFat32.c" 
.................... union 
.................... { 
.................... 	int32 FAT32[128]; 
.................... 	int16 FAT16[256]; 
.................... }FATTable; 
....................  
.................... int32 gFirstEmptyCluster; 
....................  
.................... FAT32Vars gFAT32Vars; 
.................... diskinforec DiskInfo; 
.................... FILE gFiles[MAXFILES]; 
.................... int gFATErrCode; 
....................  
.................... #byte MMCAddressL = gFAT32Vars 
.................... #byte MMCAddressH = gFAT32Vars+1 
.................... #byte MMCAddressHL = gFAT32Vars+2 
.................... #byte MMCAddressHH = gFAT32Vars+3 
.................... #byte gStartSectorL = gFAT32Vars+8 
.................... #byte gStartSectorH = gFAT32Vars+9 
.................... #byte gStartSectorHL = gFAT32Vars+10 
.................... /* 
.................... #locate FATTable.FAT32 = 0x0600 
.................... #locate gFiles = 0x0800 
.................... #locate gFAT32Vars = 0x0C70 
.................... #locate DiskInfo = 0x0C90 
.................... */ 
.................... enum{ 
.................... 	FAT_UNKNOWN = 0, 
.................... 	FAT12, 
.................... 	FAT16, 
.................... 	FAT32 
.................... }; 
....................  
.................... char sFATName[4][6]={"FAT?", "FAT12", "FAT16", "FAT32"}; 
.................... int gFATType; 
....................  
.................... #include "MMC.h" 
.................... #define MMC_NO_ERR	0 
.................... #define MMC_READ_GEN_ERR	0x10 
.................... #define MMC_READ_INVALID_ERR	0x11	//Invalid sector address 
.................... #define MMC_READ_TOKEN_ERR	0x12	 
.................... #define MMC_WRITE_GEN_ERR	0x20 
.................... #define MMC_WRITE_SEC0_ERR	0x21	//Attempt to write sector #0 
.................... #define MMC_WRITE_INVALID_ERR	0x22	//Invalid sector address 
.................... #define MMC_INIT_RESET_ERR	0x30 
.................... #define MMC_INIT_IDLE_ERR	0x31 
....................  
.................... char Init_MMC(int max_tries);  
.................... int ReadSector(int32 sector, char *buff);	//Read 512 bytes to buff 
.................... int WriteSector(int32 sector, char *buff);	//Write 512 bytes from buff 
....................  
.................... #include "MMC.c" 
....................  
.................... #use FAST_IO(C) 
.................... #define ChipSel pin_c2 
.................... #define ChipClk pin_c3 
.................... #define ChipDin pin_c5 
....................  
.................... //#define TRACE 
.................... //#define TRACE_READ_SECTOR 
.................... //#define TRACE_WRITE_SECTOR 
....................  
....................  
.................... #define NO_MMC_CARD	input(CardInserted) 
....................  
....................  
.................... int mmc_cmd(int8 cmd,int32 address,int8 tries,int8 valid,int8 invalid) 
.................... { 
.................... 	int i,r1; 
.................... 	for( i=0;i<16;i++)  
*
00662:  MOVLB  B
00664:  CLRF   x5E
00666:  MOVF   x5E,W
00668:  SUBLW  0F
0066A:  BNC   067A
.................... 		SPI_READ(0xFF);// digest prior operation 
0066C:  MOVF   FC9,W
0066E:  MOVLW  FF
00670:  MOVWF  FC9
00672:  BTFSS  FC7.0
00674:  BRA    0672
00676:  INCF   x5E,F
00678:  BRA    0666
.................... 	// commands 
.................... 	// 7 6 5 4 3 2 1 0 
.................... 	// 0 1 b b b b b b    bbbbbb=cmd 
.................... 	// 16=0x50 set blocklength 
.................... 	// 17=0x51 read block 
.................... 	// 24=0x58 write block 
.................... #ifdef TRACE 
.................... //	TRACE2("\r\ncmd=%2X, address=%lu",cmd, address); 
.................... #endif 
....................  
.................... 	SPI_READ(cmd); 
0067A:  MOVF   FC9,W
0067C:  MOVFF  B56,FC9
00680:  BTFSS  FC7.0
00682:  BRA    0680
.................... 	SPI_READ(MAKE8(address,3)); 
00684:  MOVFF  B5A,B60
00688:  MOVF   FC9,W
0068A:  MOVFF  B5A,FC9
0068E:  BTFSS  FC7.0
00690:  BRA    068E
.................... 	SPI_READ(MAKE8(address,2)); 
00692:  MOVFF  B59,B60
00696:  MOVF   FC9,W
00698:  MOVFF  B59,FC9
0069C:  BTFSS  FC7.0
0069E:  BRA    069C
.................... 	SPI_READ(MAKE8(address,1)); 
006A0:  MOVFF  B58,B60
006A4:  MOVF   FC9,W
006A6:  MOVFF  B58,FC9
006AA:  BTFSS  FC7.0
006AC:  BRA    06AA
.................... 	SPI_READ(MAKE8(address,0)); 
006AE:  MOVFF  B57,B60
006B2:  MOVF   FC9,W
006B4:  MOVFF  B57,FC9
006B8:  BTFSS  FC7.0
006BA:  BRA    06B8
.................... 	SPI_READ(0x95); 
006BC:  MOVF   FC9,W
006BE:  MOVLW  95
006C0:  MOVWF  FC9
006C2:  BTFSS  FC7.0
006C4:  BRA    06C2
.................... 	// card comes up in MMC mode and requires a valid MMC cmd to switch to SPI mode 
.................... 	// valid crc for MMC 0x40 cmd only 
.................... 	// spi mode doesn't require the CRC to be correct just there 
....................  
.................... 	for(i=0;i< tries;i++)  
006C6:  CLRF   x5E
006C8:  MOVF   x5B,W
006CA:  SUBWF  x5E,W
006CC:  BC    06F0
.................... 	{ 
.................... 		r1=SPI_READ(0xFF); 
006CE:  MOVF   FC9,W
006D0:  MOVLW  FF
006D2:  MOVWF  FC9
006D4:  BTFSS  FC7.0
006D6:  BRA    06D4
006D8:  MOVFF  FC9,B5F
.................... 		if (r1==valid)  break; 
006DC:  MOVF   x5C,W
006DE:  SUBWF  x5F,W
006E0:  BNZ   06E4
006E2:  BRA    06F0
.................... 		if (r1==invalid)  break; 
006E4:  MOVF   x5D,W
006E6:  SUBWF  x5F,W
006E8:  BNZ   06EC
006EA:  BRA    06F0
.................... 	} 
006EC:  INCF   x5E,F
006EE:  BRA    06C8
....................  
.................... 	return(r1); 
006F0:  MOVFF  B5F,01
.................... } 
006F4:  MOVLB  0
006F6:  RETLW  00
....................  
.................... int init_MMC(int max_tries) 
.................... { 
.................... 	int i,tries,c; 
.................... 	tries=0; 
006F8:  MOVLB  A
006FA:  CLRF   xED
.................... 		 
.................... 	output_low(ChipSel);   /// reset chip hardware !!! required 
006FC:  BCF    F8B.2
.................... 	delay_ms(100); 
006FE:  MOVLW  64
00700:  MOVLB  B
00702:  MOVWF  x60
00704:  MOVLB  0
00706:  RCALL  0584
....................  
.................... 	for(tries=0; tries < max_tries; tries++) 
00708:  MOVLB  A
0070A:  CLRF   xED
0070C:  MOVF   xEB,W
0070E:  SUBWF  xED,W
00710:  BC    0770
.................... 	{ 
.................... 		output_high(ChipSel);   /// reset chip hardware !!! required 
00712:  BSF    F8B.2
.................... 		delay_ms(20); 
00714:  MOVLW  14
00716:  MOVLB  B
00718:  MOVWF  x60
0071A:  MOVLB  0
0071C:  RCALL  0584
.................... 		for(i=0;i<20;i++)  
0071E:  MOVLB  A
00720:  CLRF   xEC
00722:  MOVF   xEC,W
00724:  SUBLW  13
00726:  BNC   0736
.................... 			SPI_READ(0xFF); // min 80 clocks to get MMC ready 
00728:  MOVF   FC9,W
0072A:  MOVLW  FF
0072C:  MOVWF  FC9
0072E:  BTFSS  FC7.0
00730:  BRA    072E
00732:  INCF   xEC,F
00734:  BRA    0722
....................  
.................... 		output_low(ChipSel);   ///                      !!! required 
00736:  BCF    F8B.2
.................... 	 
.................... 		delay_ms(20); 
00738:  MOVLW  14
0073A:  MOVLB  B
0073C:  MOVWF  x60
0073E:  MOVLB  0
00740:  RCALL  0584
....................  
.................... 		c=mmc_cmd(0x40,0x00000000,128,0x01,0x99); 
00742:  MOVLW  40
00744:  MOVLB  B
00746:  MOVWF  x56
00748:  CLRF   x5A
0074A:  CLRF   x59
0074C:  CLRF   x58
0074E:  CLRF   x57
00750:  MOVLW  80
00752:  MOVWF  x5B
00754:  MOVLW  01
00756:  MOVWF  x5C
00758:  MOVLW  99
0075A:  MOVWF  x5D
0075C:  MOVLB  0
0075E:  RCALL  0662
00760:  MOVFF  01,AEE
....................  
.................... 		if (c==0x01)  
00764:  MOVLB  A
00766:  DECFSZ xEE,W
00768:  BRA    076C
.................... 			break; 
0076A:  BRA    0770
.................... 	} 
0076C:  INCF   xED,F
0076E:  BRA    070C
.................... 	 
.................... 	if(tries >= max_tries) 
00770:  MOVF   xEB,W
00772:  SUBWF  xED,W
00774:  BNC   077E
.................... 	{ 
.................... 		output_high(ChipSel); 
00776:  BSF    F8B.2
.................... 		return MMC_INIT_RESET_ERR; 
00778:  MOVLW  30
0077A:  MOVWF  01
0077C:  BRA    07C4
.................... 	} 
....................  
.................... 	/// now try  to switch to idle mode 
.................... 	/// Note: cmd1(idle) is the only command allowed after a cmd0(reset) 
....................  
.................... 	for(tries=0; tries < max_tries; tries++) 
0077E:  CLRF   xED
00780:  MOVF   xEB,W
00782:  SUBWF  xED,W
00784:  BC    07B2
.................... 	{ 
.................... 		c=mmc_cmd(0x41,0x00000000,128,0x00,0x99); 
00786:  MOVLW  41
00788:  MOVLB  B
0078A:  MOVWF  x56
0078C:  CLRF   x5A
0078E:  CLRF   x59
00790:  CLRF   x58
00792:  CLRF   x57
00794:  MOVLW  80
00796:  MOVWF  x5B
00798:  CLRF   x5C
0079A:  MOVLW  99
0079C:  MOVWF  x5D
0079E:  MOVLB  0
007A0:  RCALL  0662
007A2:  MOVFF  01,AEE
.................... 		if (c==0x00)  
007A6:  MOVLB  A
007A8:  MOVF   xEE,F
007AA:  BNZ   07AE
.................... 			break; 
007AC:  BRA    07B2
.................... 	} 
007AE:  INCF   xED,F
007B0:  BRA    0780
....................  
.................... 	output_high(ChipSel); 
007B2:  BSF    F8B.2
.................... 	 
.................... 	if(tries >= max_tries) 
007B4:  MOVF   xEB,W
007B6:  SUBWF  xED,W
007B8:  BNC   07C0
.................... 		return MMC_INIT_IDLE_ERR; 
007BA:  MOVLW  31
007BC:  MOVWF  01
007BE:  BRA    07C4
.................... 		 
.................... 	return MMC_NO_ERR; 
007C0:  MOVLW  00
007C2:  MOVWF  01
....................  
.................... } 
007C4:  MOVLB  0
007C6:  GOTO   4D1C (RETURN)
....................  
.................... int mmc_response(unsigned char response) 
.................... { 
.................... 	unsigned long count = 0xFFFF;           // 16bit repeat, it may be possible to shrink this to 8 bit but there is not much point 
....................  
.................... 	while(SPI_READ(0xFF) != response && --count > 0); 
....................  
.................... 	if(count==0)  
.................... 		return 1;                  // loop was exited due to timeout 
.................... 	else  
.................... 		return 0;                          // loop was exited before timeout 
.................... } 
....................  
....................  
.................... int ReadSector( int32 sector, char *buff) 
.................... { 
.................... 	int r1; 
.................... 	long i,iw; /// allows large gt 255 buff size addressing 
....................  
.................... 	output_low(ChipSel);    
007CA:  BCF    F8B.2
.................... 	delay_ms(1); 
007CC:  MOVLW  01
007CE:  MOVLB  B
007D0:  MOVWF  x60
007D2:  MOVLB  0
007D4:  RCALL  0584
.................... 	 
.................... 	TRACE1("\r\nRead sector# %lu.", sector); 
.................... 	 
.................... 	r1=mmc_cmd(0x51,sector<<9,16,0x00,0x40); 
007D6:  BCF    FD8.0
007D8:  MOVLB  B
007DA:  CLRF   x50
007DC:  RLCF   x44,W
007DE:  MOVWF  x51
007E0:  RLCF   x45,W
007E2:  MOVWF  x52
007E4:  RLCF   x46,W
007E6:  MOVWF  x53
007E8:  MOVLW  51
007EA:  MOVWF  x56
007EC:  MOVFF  B53,B5A
007F0:  MOVFF  B52,B59
007F4:  MOVFF  B51,B58
007F8:  MOVFF  B50,B57
007FC:  MOVLW  10
007FE:  MOVWF  x5B
00800:  CLRF   x5C
00802:  MOVLW  40
00804:  MOVWF  x5D
00806:  MOVLB  0
00808:  RCALL  0662
0080A:  MOVFF  01,B4A
....................  
.................... 	if(r1 == 0x40) 
0080E:  MOVLB  B
00810:  MOVF   x4A,W
00812:  SUBLW  40
00814:  BNZ   0820
.................... 	{ 
.................... 		output_high(ChipSel); 
00816:  BSF    F8B.2
.................... 		return MMC_READ_INVALID_ERR; 
00818:  MOVLW  11
0081A:  MOVWF  01
0081C:  BRA    08A8
.................... 	} 
.................... 	else if(r1 != 0x00) 
0081E:  BRA    082C
00820:  MOVF   x4A,F
00822:  BZ    082C
.................... 	{ 
.................... 		output_high(ChipSel); 
00824:  BSF    F8B.2
.................... 		return MMC_READ_GEN_ERR; 
00826:  MOVLW  10
00828:  MOVWF  01
0082A:  BRA    08A8
.................... 	} 
.................... 	 
.................... 	//Get token 
.................... 	for(iw=0;iw<1024;iw++) 
0082C:  CLRF   x4E
0082E:  CLRF   x4D
00830:  MOVF   x4E,W
00832:  SUBLW  03
00834:  BNC   0854
.................... 	{ 
.................... 		r1=SPI_READ(0xFF); 
00836:  MOVF   FC9,W
00838:  MOVLW  FF
0083A:  MOVWF  FC9
0083C:  BTFSS  FC7.0
0083E:  BRA    083C
00840:  MOVFF  FC9,B4A
.................... 		if (r1==0xFE)  
00844:  MOVF   x4A,W
00846:  SUBLW  FE
00848:  BNZ   084C
.................... 			break; 
0084A:  BRA    0854
.................... 	} 
0084C:  INCF   x4D,F
0084E:  BTFSC  FD8.2
00850:  INCF   x4E,F
00852:  BRA    0830
.................... 	 
.................... 	//Get token error. It may be caused by improper MMC reset 
.................... 	if(r1 != 0xFE) 
00854:  MOVF   x4A,W
00856:  SUBLW  FE
00858:  BZ    0862
.................... 	{ 
.................... 		output_high(ChipSel); 
0085A:  BSF    F8B.2
.................... 		return MMC_READ_TOKEN_ERR; 
0085C:  MOVLW  12
0085E:  MOVWF  01
00860:  BRA    08A8
.................... 	} 
....................  
.................... 	//Read the whole sector (512 bytes) 
.................... 	for (i=0;i<512;i++)  
00862:  CLRF   x4C
00864:  CLRF   x4B
00866:  MOVF   x4C,W
00868:  SUBLW  01
0086A:  BNC   088E
.................... 		buff[i]=SPI_READ(0xFF); 
0086C:  MOVF   x48,W
0086E:  ADDWF  x4B,W
00870:  MOVWF  FE9
00872:  MOVF   x49,W
00874:  ADDWFC x4C,W
00876:  MOVWF  FEA
00878:  MOVF   FC9,W
0087A:  MOVLW  FF
0087C:  MOVWF  FC9
0087E:  BTFSS  FC7.0
00880:  BRA    087E
00882:  MOVFF  FC9,FEF
00886:  INCF   x4B,F
00888:  BTFSC  FD8.2
0088A:  INCF   x4C,F
0088C:  BRA    0866
....................  
.................... 	SPI_READ(0xFF); // read crc 
0088E:  MOVF   FC9,W
00890:  MOVLW  FF
00892:  MOVWF  FC9
00894:  BTFSS  FC7.0
00896:  BRA    0894
.................... 	SPI_READ(0xFF); 
00898:  MOVF   FC9,W
0089A:  MOVLW  FF
0089C:  MOVWF  FC9
0089E:  BTFSS  FC7.0
008A0:  BRA    089E
....................  
.................... #ifdef TRACE_READ_SECTOR 
.................... 	fprintf(debug, "\r\nRead sector #%lu:", sector); 
....................  
.................... 	for(i = 0; i<512; i++) 
.................... 	{ 
.................... 		if(i%16 == 0) 
.................... 			fprintf(debug, "\r\n%04LX - ", i); 
.................... 		r1 = *buff; 
.................... 		if(r1 < ' ' || r1 > 'z') 
.................... 			r1 = '.'; 
.................... 		fprintf(debug, "%02X%c ", *buff++, r1); 
....................  
.................... 	} 
.................... #endif 
....................  
.................... 	output_high(ChipSel); 
008A2:  BSF    F8B.2
.................... 	return MMC_NO_ERR; 
008A4:  MOVLW  00
008A6:  MOVWF  01
.................... } 
008A8:  MOVLB  0
008AA:  RETLW  00
....................  
.................... int WriteSector(int32 sector, char *buff) 
....................  
.................... { 
.................... 	int r1; 
.................... 	int16 i; 
....................  
....................  
.................... 	TRACE1("\r\nWriteSector(%lu).", sector); 
....................  
.................... 	if(sector == 0)	//never write sector 0 
*
01156:  MOVLB  B
01158:  MOVF   x48,F
0115A:  BNZ   116E
0115C:  MOVF   x49,F
0115E:  BNZ   116E
01160:  MOVF   x4A,F
01162:  BNZ   116E
01164:  MOVF   x4B,F
01166:  BNZ   116E
.................... 		return MMC_WRITE_SEC0_ERR; 
01168:  MOVLW  21
0116A:  MOVWF  01
0116C:  BRA    125E
....................  
.................... 	output_low(ChipSel); 
0116E:  BCF    F8B.2
.................... 	delay_ms(1); 
01170:  MOVLW  01
01172:  MOVWF  x60
01174:  MOVLB  0
01176:  CALL   0584
.................... 	 
.................... 	r1=mmc_cmd(0x58,sector<<9,16,0x00,0x40); 
0117A:  BCF    FD8.0
0117C:  MOVLB  B
0117E:  CLRF   x52
01180:  RLCF   x48,W
01182:  MOVWF  x53
01184:  RLCF   x49,W
01186:  MOVWF  x54
01188:  RLCF   x4A,W
0118A:  MOVWF  x55
0118C:  MOVLW  58
0118E:  MOVWF  x56
01190:  MOVFF  B55,B5A
01194:  MOVFF  B54,B59
01198:  MOVFF  B53,B58
0119C:  MOVFF  B52,B57
011A0:  MOVLW  10
011A2:  MOVWF  x5B
011A4:  CLRF   x5C
011A6:  MOVLW  40
011A8:  MOVWF  x5D
011AA:  MOVLB  0
011AC:  CALL   0662
011B0:  MOVFF  01,B4E
....................  
....................  
.................... 	if(r1 == 0x40) 
011B4:  MOVLB  B
011B6:  MOVF   x4E,W
011B8:  SUBLW  40
011BA:  BNZ   11C6
.................... 	{ 
.................... 		output_high(ChipSel);	 
011BC:  BSF    F8B.2
.................... 		return MMC_WRITE_INVALID_ERR; 
011BE:  MOVLW  22
011C0:  MOVWF  01
011C2:  BRA    125E
.................... 	} 
.................... 	else if(r1 != 0x00) 
011C4:  BRA    11D2
011C6:  MOVF   x4E,F
011C8:  BZ    11D2
.................... 	{ 
.................... 		output_high(ChipSel); 
011CA:  BSF    F8B.2
.................... 		return MMC_WRITE_GEN_ERR; 
011CC:  MOVLW  20
011CE:  MOVWF  01
011D0:  BRA    125E
.................... 	} 
....................  
.................... 	SPI_READ(0xFE); 
011D2:  MOVF   FC9,W
011D4:  MOVLW  FE
011D6:  MOVWF  FC9
011D8:  BTFSS  FC7.0
011DA:  BRA    11D8
....................  
.................... 	for (i=0;i < 512;i++)  
011DC:  CLRF   x50
011DE:  CLRF   x4F
011E0:  MOVF   x50,W
011E2:  SUBLW  01
011E4:  BNC   1208
.................... 	{ 
.................... 		SPI_READ(buff[i]);  /// send payload 
011E6:  MOVF   x4C,W
011E8:  ADDWF  x4F,W
011EA:  MOVWF  FE9
011EC:  MOVF   x4D,W
011EE:  ADDWFC x50,W
011F0:  MOVWF  FEA
011F2:  MOVFF  FEF,B51
011F6:  MOVF   FC9,W
011F8:  MOVFF  B51,FC9
011FC:  BTFSS  FC7.0
011FE:  BRA    11FC
.................... 	} 
01200:  INCF   x4F,F
01202:  BTFSC  FD8.2
01204:  INCF   x50,F
01206:  BRA    11E0
....................  
....................  
.................... 	SPI_READ(0xFF); // send dummy chcksum 
01208:  MOVF   FC9,W
0120A:  MOVLW  FF
0120C:  MOVWF  FC9
0120E:  BTFSS  FC7.0
01210:  BRA    120E
.................... 	SPI_READ(0xFF); 
01212:  MOVF   FC9,W
01214:  MOVLW  FF
01216:  MOVWF  FC9
01218:  BTFSS  FC7.0
0121A:  BRA    1218
.................... 	r1=SPI_READ(0xFF); 
0121C:  MOVF   FC9,W
0121E:  MOVLW  FF
01220:  MOVWF  FC9
01222:  BTFSS  FC7.0
01224:  BRA    1222
01226:  MOVFF  FC9,B4E
.................... 	for( i=0;i<0x0fff;i++)  
0122A:  CLRF   x50
0122C:  CLRF   x4F
0122E:  MOVF   x50,W
01230:  SUBLW  0F
01232:  BNC   1258
01234:  BNZ   123C
01236:  MOVF   x4F,W
01238:  SUBLW  FE
0123A:  BNC   1258
.................... 	{ 
.................... 		r1=SPI_READ(0xFF);// digest prior operation 
0123C:  MOVF   FC9,W
0123E:  MOVLW  FF
01240:  MOVWF  FC9
01242:  BTFSS  FC7.0
01244:  BRA    1242
01246:  MOVFF  FC9,B4E
.................... 		if (r1!=0x00)  
0124A:  MOVF   x4E,F
0124C:  BZ    1250
.................... 			break; 
0124E:  BRA    1258
.................... 	} 
01250:  INCF   x4F,F
01252:  BTFSC  FD8.2
01254:  INCF   x50,F
01256:  BRA    122E
....................  
.................... #ifdef TRACE_WRITE_SECTOR 
.................... 	fprintf(debug, "\r\nWrite sector #%lu:", sector); 
....................  
.................... 	for(i = 0; i<512; i++) 
.................... 	{ 
.................... 		if(i%16 == 0) 
.................... 			fprintf(debug, "\r\n%04LX - ", i); 
.................... 		r1 = *buff; 
.................... 		if(r1 < ' ' || r1 > 'z') 
.................... 			r1 = '.'; 
.................... 		fprintf(debug, "%02X%c ", *buff++, r1); 
....................  
.................... 	} 
....................  
.................... #endif 
....................  
.................... 	output_high(ChipSel); 
01258:  BSF    F8B.2
.................... 	return MMC_NO_ERR; 
0125A:  MOVLW  00
0125C:  MOVWF  01
.................... } 
0125E:  MOVLB  0
01260:  RETLW  00
....................  
....................  
....................  
.................... char IsSelfDir(char *ch) 
.................... { 
.................... 	if (ch[0] == '.' && ch[1] == '.') return 0xFF; 
*
00FE6:  MOVLB  B
00FE8:  MOVFF  B10,FE9
00FEC:  MOVFF  B11,FEA
00FF0:  MOVF   FEF,W
00FF2:  SUBLW  2E
00FF4:  BNZ   1010
00FF6:  MOVLW  01
00FF8:  ADDWF  x10,W
00FFA:  MOVWF  FE9
00FFC:  MOVLW  00
00FFE:  ADDWFC x11,W
01000:  MOVWF  FEA
01002:  MOVF   FEF,W
01004:  SUBLW  2E
01006:  BNZ   1010
01008:  MOVLW  FF
0100A:  MOVWF  01
0100C:  BRA    1016
.................... 	else return 0; 
0100E:  BRA    1016
01010:  MOVLW  00
01012:  MOVWF  01
01014:  BRA    1016
.................... } 
01016:  MOVLB  0
01018:  GOTO   1D4A (RETURN)
....................  
....................  
.................... int16 GetCurrentDOSDate() 
.................... { 
.................... 	int16 retval; 
....................  
.................... 	retval = myrec.tm_year - 1980; 
*
02700:  MOVLW  BC
02702:  SUBWF  0F,W
02704:  MOVLB  B
02706:  MOVWF  x11
02708:  MOVLW  07
0270A:  SUBWFB 10,W
0270C:  MOVWF  x12
.................... 	retval <<= 9; 
0270E:  BCF    FD8.0
02710:  MOVFF  B11,B12
02714:  CLRF   x11
02716:  RLCF   x12,F
.................... 	retval |= ((int16)myrec.tm_mon << 5); 
02718:  CLRF   x14
0271A:  RLCF   11,W
0271C:  MOVWF  02
0271E:  RLCF   x14,W
02720:  MOVWF  03
02722:  RLCF   02,F
02724:  RLCF   03,F
02726:  RLCF   02,F
02728:  RLCF   03,F
0272A:  RLCF   02,F
0272C:  RLCF   03,F
0272E:  RLCF   02,F
02730:  RLCF   03,F
02732:  MOVLW  E0
02734:  ANDWF  02,F
02736:  MOVF   02,W
02738:  IORWF  x11,F
0273A:  MOVF   03,W
0273C:  IORWF  x12,F
.................... 	retval |= (int16)myrec.tm_mday; 
0273E:  CLRF   03
02740:  MOVF   13,W
02742:  IORWF  x11,F
02744:  MOVF   03,W
02746:  IORWF  x12,F
.................... 	return retval; 
02748:  MOVFF  B11,01
0274C:  MOVFF  B12,02
.................... } 
02750:  MOVLB  0
02752:  RETLW  00
....................  
.................... int16 GetCurrentDOSTime() 
.................... { 
.................... 	int16 retval; 
....................  
.................... 	retval = myrec.tm_hour; 
02754:  MOVLB  B
02756:  CLRF   x12
02758:  MOVFF  14,B11
.................... 	retval <<= 11; 
0275C:  MOVFF  B11,B12
02760:  CLRF   x11
02762:  RLCF   x12,F
02764:  RLCF   x12,F
02766:  RLCF   x12,F
02768:  MOVLW  F8
0276A:  ANDWF  x12,F
.................... 	retval |= ((int16)myrec.tm_min << 5); 
0276C:  CLRF   x14
0276E:  RLCF   15,W
02770:  MOVWF  02
02772:  RLCF   x14,W
02774:  MOVWF  03
02776:  RLCF   02,F
02778:  RLCF   03,F
0277A:  RLCF   02,F
0277C:  RLCF   03,F
0277E:  RLCF   02,F
02780:  RLCF   03,F
02782:  RLCF   02,F
02784:  RLCF   03,F
02786:  MOVLW  E0
02788:  ANDWF  02,F
0278A:  MOVF   02,W
0278C:  IORWF  x11,F
0278E:  MOVF   03,W
02790:  IORWF  x12,F
.................... 	retval |= (int16)myrec.tm_sec >> 1; 
02792:  CLRF   x14
02794:  BCF    FD8.0
02796:  RRCF   x14,W
02798:  MOVWF  03
0279A:  RRCF   16,W
0279C:  IORWF  x11,F
0279E:  MOVF   03,W
027A0:  IORWF  x12,F
.................... 	return retval; 
027A2:  MOVFF  B11,01
027A6:  MOVFF  B12,02
.................... } 
027AA:  MOVLB  0
027AC:  RETLW  00
....................  
.................... int InitFAT() 
.................... { 
.................... 	int32 actsector; 
.................... 	int32 nTotalSec, nDataSec, nCountofClusters; 
.................... 	char i; 
....................  
.................... 	gFirstEmptyCluster = 0; 
*
009D0:  MOVLB  2
009D2:  CLRF   x1A
009D4:  CLRF   x19
009D6:  CLRF   x18
009D8:  CLRF   x17
.................... 	gFAT32Vars.gStartSector = 0; 
009DA:  CLRF   x26
009DC:  CLRF   x25
009DE:  CLRF   x24
009E0:  CLRF   x23
.................... 	gFAT32Vars.bFATModified = 0; 
009E2:  CLRF   x3F
.................... 	gFATType = FAT_UNKNOWN; 
009E4:  MOVLB  4
009E6:  CLRF   xBB
....................  
.................... 	//Read start sector to temp buffer 
.................... 	//fprintf(debug, "\r\nRead start sector "); 
.................... 	gFATErrCode = ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IOpuffer); 
009E8:  MOVFF  226,B47
009EC:  MOVFF  225,B46
009F0:  MOVFF  224,B45
009F4:  MOVFF  223,B44
009F8:  MOVLW  02
009FA:  MOVLB  B
009FC:  MOVWF  x49
009FE:  MOVLW  70
00A00:  MOVWF  x48
00A02:  MOVLB  0
00A04:  RCALL  07CA
00A06:  MOVFF  01,09
.................... 	 
.................... 	if(gFATErrCode != MMC_NO_ERR) 
00A0A:  MOVF   09,F
00A0C:  BZ    0A14
.................... 		return  gFATErrCode; 
00A0E:  MOVFF  09,01
00A12:  BRA    0D72
....................  
.................... 	if (gFiles[MAXFILES-1].IOpuffer[0] != 0xEB)  
00A14:  MOVLB  2
00A16:  MOVF   x70,W
00A18:  SUBLW  EB
00A1A:  BZ    0A56
.................... 	{ 
.................... 		gStartSectorL = gFiles[MAXFILES-1].IOpuffer[0x1C6]; 
00A1C:  MOVFF  436,223
.................... 		gStartSectorH = gFiles[MAXFILES-1].IOpuffer[0x1C7]; 
00A20:  MOVFF  437,224
.................... 		gStartSectorHL = gFiles[MAXFILES-1].IOpuffer[0x1C8]; 
00A24:  MOVFF  438,225
....................  
.................... 		//fprintf(debug, "\r\nRead start sector"); 
.................... 		gFATErrCode = ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IOpuffer); 
00A28:  MOVFF  226,B47
00A2C:  MOVFF  225,B46
00A30:  MOVFF  224,B45
00A34:  MOVFF  223,B44
00A38:  MOVLW  02
00A3A:  MOVLB  B
00A3C:  MOVWF  x49
00A3E:  MOVLW  70
00A40:  MOVWF  x48
00A42:  MOVLB  0
00A44:  RCALL  07CA
00A46:  MOVFF  01,09
.................... 		if(gFATErrCode != MMC_NO_ERR) 
00A4A:  MOVF   09,F
00A4C:  BZ    0A54
.................... 			return  gFATErrCode; 
00A4E:  MOVFF  09,01
00A52:  BRA    0D72
00A54:  MOVLB  2
.................... 	} 
.................... 	 
.................... 	memcpy(&DiskInfo,gFiles[MAXFILES-1].IOpuffer,sizeof(DiskInfo)); 
00A56:  MOVLW  02
00A58:  MOVWF  FEA
00A5A:  MOVLW  40
00A5C:  MOVWF  FE9
00A5E:  MOVLW  02
00A60:  MOVWF  FE2
00A62:  MOVLW  70
00A64:  MOVWF  FE1
00A66:  MOVLW  30
00A68:  MOVWF  01
00A6A:  MOVFF  FE6,FEE
00A6E:  DECFSZ 01,F
00A70:  BRA    0A6A
....................  
.................... 	//Check FAT type 
.................... 	gFAT32Vars.nRootDirSectors = (DiskInfo.RootEntCnt*32 + (DiskInfo.BytsPerSec - 1))/DiskInfo.BytsPerSec; 
00A72:  RLCF   x51,W
00A74:  MOVLB  A
00A76:  MOVWF  xFC
00A78:  MOVLB  2
00A7A:  RLCF   x52,W
00A7C:  MOVLB  A
00A7E:  MOVWF  xFD
00A80:  RLCF   xFC,F
00A82:  RLCF   xFD,F
00A84:  RLCF   xFC,F
00A86:  RLCF   xFD,F
00A88:  RLCF   xFC,F
00A8A:  RLCF   xFD,F
00A8C:  RLCF   xFC,F
00A8E:  RLCF   xFD,F
00A90:  MOVLW  E0
00A92:  ANDWF  xFC,F
00A94:  MOVLW  01
00A96:  MOVLB  2
00A98:  SUBWF  x4B,W
00A9A:  MOVWF  00
00A9C:  MOVLW  00
00A9E:  SUBWFB x4C,W
00AA0:  MOVWF  03
00AA2:  MOVF   00,W
00AA4:  MOVLB  A
00AA6:  ADDWF  xFC,W
00AA8:  MOVWF  xFE
00AAA:  MOVF   03,W
00AAC:  ADDWFC xFD,W
00AAE:  MOVWF  xFF
00AB0:  MOVFF  FE8,B01
00AB4:  MOVFF  AFE,B00
00AB8:  MOVFF  24C,B03
00ABC:  MOVFF  24B,B02
00AC0:  MOVLB  0
00AC2:  BRA    08AC
00AC4:  MOVLB  2
00AC6:  CLRF   x3A
00AC8:  CLRF   x39
00ACA:  MOVFF  02,238
00ACE:  MOVFF  01,237
....................  
.................... 	gFAT32Vars.nFatSize = DiskInfo.FATSz16; 
00AD2:  CLRF   x3E
00AD4:  CLRF   x3D
00AD6:  MOVFF  257,23C
00ADA:  MOVFF  256,23B
.................... 	if(gFAT32Vars.nFatSize == 0) 
00ADE:  MOVF   x3B,F
00AE0:  BNZ   0AFE
00AE2:  MOVF   x3C,F
00AE4:  BNZ   0AFE
00AE6:  MOVF   x3D,F
00AE8:  BNZ   0AFE
00AEA:  MOVF   x3E,F
00AEC:  BNZ   0AFE
.................... 		gFAT32Vars.nFatSize = DiskInfo.FATSz32; 
00AEE:  MOVFF  267,23E
00AF2:  MOVFF  266,23D
00AF6:  MOVFF  265,23C
00AFA:  MOVFF  264,23B
....................  
.................... 	nTotalSec = DiskInfo.TotSec16; 
00AFE:  MOVLB  A
00B00:  CLRF   xF2
00B02:  CLRF   xF1
00B04:  MOVFF  254,AF0
00B08:  MOVFF  253,AEF
.................... 	if(nTotalSec == 0) 
00B0C:  MOVF   xEF,F
00B0E:  BNZ   0B2C
00B10:  MOVF   xF0,F
00B12:  BNZ   0B2C
00B14:  MOVF   xF1,F
00B16:  BNZ   0B2C
00B18:  MOVF   xF2,F
00B1A:  BNZ   0B2C
.................... 		nTotalSec = DiskInfo.TotSec32; 
00B1C:  MOVFF  263,AF2
00B20:  MOVFF  262,AF1
00B24:  MOVFF  261,AF0
00B28:  MOVFF  260,AEF
....................  
.................... 	nDataSec = nTotalSec - (DiskInfo.RsvdSecCnt + DiskInfo.NumFATs*gFAT32Vars.nFatSize) + gFAT32Vars.nRootDirSectors; 
00B2C:  MOVLB  B
00B2E:  CLRF   x3C
00B30:  CLRF   x3B
00B32:  CLRF   x3A
00B34:  MOVFF  250,B39
00B38:  MOVFF  23E,B40
00B3C:  MOVFF  23D,B3F
00B40:  MOVFF  23C,B3E
00B44:  MOVFF  23B,B3D
00B48:  MOVLB  0
00B4A:  RCALL  08F4
00B4C:  MOVLB  2
00B4E:  MOVF   x4E,W
00B50:  ADDWF  00,F
00B52:  MOVF   x4F,W
00B54:  ADDWFC 01,F
00B56:  MOVLW  00
00B58:  ADDWFC 02,F
00B5A:  ADDWFC 03,F
00B5C:  MOVF   00,W
00B5E:  MOVLB  A
00B60:  SUBWF  xEF,W
00B62:  MOVWF  xFC
00B64:  MOVF   01,W
00B66:  SUBWFB xF0,W
00B68:  MOVWF  xFD
00B6A:  MOVF   02,W
00B6C:  SUBWFB xF1,W
00B6E:  MOVWF  xFE
00B70:  MOVF   03,W
00B72:  SUBWFB xF2,W
00B74:  MOVWF  xFF
00B76:  MOVLB  2
00B78:  MOVF   x37,W
00B7A:  MOVLB  A
00B7C:  ADDWF  xFC,W
00B7E:  MOVWF  xF3
00B80:  MOVLB  2
00B82:  MOVF   x38,W
00B84:  MOVLB  A
00B86:  ADDWFC xFD,W
00B88:  MOVWF  xF4
00B8A:  MOVLB  2
00B8C:  MOVF   x39,W
00B8E:  MOVLB  A
00B90:  ADDWFC xFE,W
00B92:  MOVWF  xF5
00B94:  MOVLB  2
00B96:  MOVF   x3A,W
00B98:  MOVLB  A
00B9A:  ADDWFC xFF,W
00B9C:  MOVWF  xF6
....................  
.................... 	nCountofClusters = nDataSec/DiskInfo.SecPerClus; 
00B9E:  MOVFF  AF6,B12
00BA2:  MOVFF  AF5,B11
00BA6:  MOVFF  AF4,B10
00BAA:  MOVFF  AF3,B0F
00BAE:  MOVLB  B
00BB0:  CLRF   x16
00BB2:  CLRF   x15
00BB4:  CLRF   x14
00BB6:  MOVFF  24D,B13
00BBA:  MOVLB  0
00BBC:  RCALL  0950
00BBE:  MOVFF  03,AFA
00BC2:  MOVFF  02,AF9
00BC6:  MOVFF  01,AF8
00BCA:  MOVFF  00,AF7
....................  
.................... 	//fprintf(debug, "\r\nFatSize=%lu, TotalSec=%lu, CountofClusters=%lu", 
.................... 	//	gFAT32Vars.nFatSize, nTotalSec, nCountofClusters); 
....................  
.................... 	if(nCountofClusters < 4085) 
00BCE:  MOVLB  A
00BD0:  MOVF   xFA,F
00BD2:  BNZ   0BF0
00BD4:  MOVF   xF9,F
00BD6:  BNZ   0BF0
00BD8:  MOVF   xF8,W
00BDA:  SUBLW  0F
00BDC:  BNC   0BF0
00BDE:  BNZ   0BE6
00BE0:  MOVF   xF7,W
00BE2:  SUBLW  F4
00BE4:  BNC   0BF0
.................... 		gFATType = FAT12; 
00BE6:  MOVLW  01
00BE8:  MOVLB  4
00BEA:  MOVWF  xBB
.................... 	else if(nCountofClusters < 65525) 
00BEC:  BRA    0C14
00BEE:  MOVLB  A
00BF0:  MOVF   xFA,F
00BF2:  BNZ   0C0E
00BF4:  MOVF   xF9,F
00BF6:  BNZ   0C0E
00BF8:  MOVF   xF8,W
00BFA:  SUBLW  FF
00BFC:  BNC   0C0E
00BFE:  BNZ   0C06
00C00:  MOVF   xF7,W
00C02:  SUBLW  F4
00C04:  BNC   0C0E
.................... 		gFATType = FAT16; 
00C06:  MOVLW  02
00C08:  MOVLB  4
00C0A:  MOVWF  xBB
.................... 	else 
00C0C:  BRA    0C14
.................... 		gFATType = FAT32; 
00C0E:  MOVLW  03
00C10:  MOVLB  4
00C12:  MOVWF  xBB
....................  
.................... 	actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt; 
00C14:  MOVLB  2
00C16:  MOVF   x4E,W
00C18:  ADDWF  x23,W
00C1A:  MOVLB  A
00C1C:  MOVWF  xEB
00C1E:  MOVLB  2
00C20:  MOVF   x4F,W
00C22:  ADDWFC x24,W
00C24:  MOVLB  A
00C26:  MOVWF  xEC
00C28:  MOVLW  00
00C2A:  MOVLB  2
00C2C:  ADDWFC x25,W
00C2E:  MOVLB  A
00C30:  MOVWF  xED
00C32:  MOVLW  00
00C34:  MOVLB  2
00C36:  ADDWFC x26,W
00C38:  MOVLB  A
00C3A:  MOVWF  xEE
....................  
.................... 	//Read FAT table 
.................... 	//fprintf(debug, "\r\nRead FAT table "); 
.................... 	gFATErrCode = ReadSector(actsector,FATTable.FAT32); 
00C3C:  MOVFF  AEE,B47
00C40:  MOVFF  AED,B46
00C44:  MOVFF  AEC,B45
00C48:  MOVFF  AEB,B44
00C4C:  MOVLB  B
00C4E:  CLRF   x49
00C50:  MOVLW  17
00C52:  MOVWF  x48
00C54:  MOVLB  0
00C56:  RCALL  07CA
00C58:  MOVFF  01,09
....................  
.................... 	gFAT32Vars.FATstartidx = 0; 
00C5C:  MOVLB  2
00C5E:  CLRF   x22
00C60:  CLRF   x21
00C62:  CLRF   x20
00C64:  CLRF   x1F
....................  
.................... 	gFAT32Vars.gFirstDataSector = gFAT32Vars.gStartSector  
.................... 		+ DiskInfo.NumFATs*gFAT32Vars.nFatSize 
.................... 		+ gFAT32Vars.nRootDirSEctors  
.................... 		+ DiskInfo.RsvdSecCnt - 2*DiskInfo.SecPerClus; 
00C66:  MOVLB  B
00C68:  CLRF   x3C
00C6A:  CLRF   x3B
00C6C:  CLRF   x3A
00C6E:  MOVFF  250,B39
00C72:  MOVFF  23E,B40
00C76:  MOVFF  23D,B3F
00C7A:  MOVFF  23C,B3E
00C7E:  MOVFF  23B,B3D
00C82:  MOVLB  0
00C84:  RCALL  08F4
00C86:  MOVF   00,W
00C88:  MOVLB  2
00C8A:  ADDWF  x23,W
00C8C:  MOVLB  A
00C8E:  MOVWF  xFC
00C90:  MOVF   01,W
00C92:  MOVLB  2
00C94:  ADDWFC x24,W
00C96:  MOVLB  A
00C98:  MOVWF  xFD
00C9A:  MOVF   02,W
00C9C:  MOVLB  2
00C9E:  ADDWFC x25,W
00CA0:  MOVLB  A
00CA2:  MOVWF  xFE
00CA4:  MOVF   03,W
00CA6:  MOVLB  2
00CA8:  ADDWFC x26,W
00CAA:  MOVLB  A
00CAC:  MOVWF  xFF
00CAE:  MOVLB  2
00CB0:  MOVF   x37,W
00CB2:  MOVLB  A
00CB4:  ADDWF  xFC,W
00CB6:  MOVLB  B
00CB8:  MOVWF  x00
00CBA:  MOVLB  2
00CBC:  MOVF   x38,W
00CBE:  MOVLB  A
00CC0:  ADDWFC xFD,W
00CC2:  MOVLB  B
00CC4:  MOVWF  x01
00CC6:  MOVLB  2
00CC8:  MOVF   x39,W
00CCA:  MOVLB  A
00CCC:  ADDWFC xFE,W
00CCE:  MOVLB  B
00CD0:  MOVWF  x02
00CD2:  MOVLB  2
00CD4:  MOVF   x3A,W
00CD6:  MOVLB  A
00CD8:  ADDWFC xFF,W
00CDA:  MOVLB  B
00CDC:  MOVWF  x03
00CDE:  MOVLB  2
00CE0:  MOVF   x4E,W
00CE2:  MOVLB  B
00CE4:  ADDWF  x00,W
00CE6:  MOVWF  x04
00CE8:  MOVLB  2
00CEA:  MOVF   x4F,W
00CEC:  MOVLB  B
00CEE:  ADDWFC x01,W
00CF0:  MOVWF  x05
00CF2:  MOVLW  00
00CF4:  ADDWFC x02,W
00CF6:  MOVWF  x06
00CF8:  MOVLW  00
00CFA:  ADDWFC x03,W
00CFC:  MOVWF  x07
00CFE:  BCF    FD8.0
00D00:  MOVLB  2
00D02:  RLCF   x4D,W
00D04:  MOVLB  B
00D06:  SUBWF  x04,W
00D08:  MOVLB  2
00D0A:  MOVWF  x27
00D0C:  MOVLW  00
00D0E:  MOVLB  B
00D10:  SUBWFB x05,W
00D12:  MOVLB  2
00D14:  MOVWF  x28
00D16:  MOVLW  00
00D18:  MOVLB  B
00D1A:  SUBWFB x06,W
00D1C:  MOVLB  2
00D1E:  MOVWF  x29
00D20:  MOVLW  00
00D22:  MOVLB  B
00D24:  SUBWFB x07,W
00D26:  MOVLB  2
00D28:  MOVWF  x2A
.................... 	 
.................... 	for (i=0;i<MAXFILES;i++) 
00D2A:  MOVLB  A
00D2C:  CLRF   xFB
00D2E:  MOVF   xFB,F
00D30:  BNZ   0D6E
.................... 		gFiles[i].Free = TRUE; 
00D32:  MOVLB  B
00D34:  CLRF   x62
00D36:  MOVFF  AFB,B61
00D3A:  MOVLW  02
00D3C:  MOVWF  x64
00D3E:  MOVLW  33
00D40:  MOVWF  x63
00D42:  MOVLB  0
00D44:  CALL   039E
00D48:  MOVFF  01,AFC
00D4C:  MOVLW  32
00D4E:  MOVLB  A
00D50:  ADDWF  01,W
00D52:  MOVWF  01
00D54:  MOVLW  02
00D56:  ADDWFC 02,W
00D58:  MOVWF  03
00D5A:  MOVF   01,W
00D5C:  ADDLW  70
00D5E:  MOVWF  FE9
00D60:  MOVLW  02
00D62:  ADDWFC 03,W
00D64:  MOVWF  FEA
00D66:  MOVLW  01
00D68:  MOVWF  FEF
00D6A:  INCF   xFB,F
00D6C:  BRA    0D2E
.................... 		 
.................... 	return  gFATErrCode; 
00D6E:  MOVFF  09,01
00D72:  MOVLB  0
....................  
.................... } 
00D74:  GOTO   4D3C (RETURN)
.................... void SaveFATTable() 
.................... { 
.................... 	int32 actsector; 
.................... 	actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
*
01262:  MOVLB  2
01264:  MOVF   x4E,W
01266:  ADDWF  x23,W
01268:  MOVLB  B
0126A:  MOVWF  x48
0126C:  MOVLB  2
0126E:  MOVF   x4F,W
01270:  ADDWFC x24,W
01272:  MOVLB  B
01274:  MOVWF  x49
01276:  MOVLW  00
01278:  MOVLB  2
0127A:  ADDWFC x25,W
0127C:  MOVLB  B
0127E:  MOVWF  x4A
01280:  MOVLW  00
01282:  MOVLB  2
01284:  ADDWFC x26,W
01286:  MOVLB  B
01288:  MOVWF  x4B
0128A:  MOVLB  2
0128C:  MOVF   x1F,W
0128E:  MOVLB  B
01290:  ADDWF  x48,W
01292:  MOVWF  x44
01294:  MOVLB  2
01296:  MOVF   x20,W
01298:  MOVLB  B
0129A:  ADDWFC x49,W
0129C:  MOVWF  x45
0129E:  MOVLB  2
012A0:  MOVF   x21,W
012A2:  MOVLB  B
012A4:  ADDWFC x4A,W
012A6:  MOVWF  x46
012A8:  MOVLB  2
012AA:  MOVF   x22,W
012AC:  MOVLB  B
012AE:  ADDWFC x4B,W
012B0:  MOVWF  x47
.................... 	gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
012B2:  MOVFF  B47,B4B
012B6:  MOVFF  B46,B4A
012BA:  MOVFF  B45,B49
012BE:  MOVFF  B44,B48
012C2:  CLRF   x4D
012C4:  MOVLW  17
012C6:  MOVWF  x4C
012C8:  MOVLB  0
012CA:  RCALL  1156
012CC:  MOVFF  01,09
.................... 	actsector += gFAT32Vars.nFatSize; 
012D0:  MOVLB  2
012D2:  MOVF   x3B,W
012D4:  MOVLB  B
012D6:  ADDWF  x44,F
012D8:  MOVLB  2
012DA:  MOVF   x3C,W
012DC:  MOVLB  B
012DE:  ADDWFC x45,F
012E0:  MOVLB  2
012E2:  MOVF   x3D,W
012E4:  MOVLB  B
012E6:  ADDWFC x46,F
012E8:  MOVLB  2
012EA:  MOVF   x3E,W
012EC:  MOVLB  B
012EE:  ADDWFC x47,F
.................... 	gFATErrCode = WriteSector(actsector,FATTable.FAT32);	 
012F0:  MOVFF  B47,B4B
012F4:  MOVFF  B46,B4A
012F8:  MOVFF  B45,B49
012FC:  MOVFF  B44,B48
01300:  CLRF   x4D
01302:  MOVLW  17
01304:  MOVWF  x4C
01306:  MOVLB  0
01308:  RCALL  1156
0130A:  MOVFF  01,09
.................... 	gFAT32Vars.bFATModified = 0; 
0130E:  MOVLB  2
01310:  CLRF   x3F
.................... } 
01312:  MOVLB  0
01314:  RETLW  00
....................  
.................... int32 GetNextCluster(int32 curcluster) 
.................... { 
.................... 	int32 actsector; 
.................... 	int32 clpage; 
.................... 	char clpos; 
....................  
.................... #ifdef TRACE 
.................... 	TRACE1("\r\nGetNextCluster(%lu)", curcluster);	 
.................... #endif 
.................... 	if(gFATType == FAT32) 
01316:  MOVLB  4
01318:  MOVF   xBB,W
0131A:  SUBLW  03
0131C:  BTFSS  FD8.2
0131E:  BRA    1444
.................... 	{ 
.................... 		clpage = curcluster >> 7; 
01320:  MOVLB  B
01322:  RRCF   x3A,W
01324:  MOVWF  x42
01326:  RRCF   x39,W
01328:  MOVWF  x41
0132A:  RRCF   x38,W
0132C:  MOVWF  x40
0132E:  RRCF   x37,W
01330:  MOVWF  x3F
01332:  RRCF   x42,F
01334:  RRCF   x41,F
01336:  RRCF   x40,F
01338:  RRCF   x3F,F
0133A:  RRCF   x42,F
0133C:  RRCF   x41,F
0133E:  RRCF   x40,F
01340:  RRCF   x3F,F
01342:  RRCF   x42,F
01344:  RRCF   x41,F
01346:  RRCF   x40,F
01348:  RRCF   x3F,F
0134A:  RRCF   x42,F
0134C:  RRCF   x41,F
0134E:  RRCF   x40,F
01350:  RRCF   x3F,F
01352:  RRCF   x42,F
01354:  RRCF   x41,F
01356:  RRCF   x40,F
01358:  RRCF   x3F,F
0135A:  RRCF   x42,F
0135C:  RRCF   x41,F
0135E:  RRCF   x40,F
01360:  RRCF   x3F,F
01362:  MOVLW  01
01364:  ANDWF  x42,F
.................... 		clpos = curcluster & 0x7F; 
01366:  MOVF   x37,W
01368:  ANDLW  7F
0136A:  MOVWF  x43
.................... 		if (clpage != gFAT32Vars.FATstartidx) // read in the requested page 
0136C:  MOVLB  2
0136E:  MOVF   x1F,W
01370:  MOVLB  B
01372:  SUBWF  x3F,W
01374:  BNZ   1394
01376:  MOVLB  2
01378:  MOVF   x20,W
0137A:  MOVLB  B
0137C:  SUBWF  x40,W
0137E:  BNZ   1394
01380:  MOVLB  2
01382:  MOVF   x21,W
01384:  MOVLB  B
01386:  SUBWF  x41,W
01388:  BNZ   1394
0138A:  MOVLB  2
0138C:  MOVF   x22,W
0138E:  MOVLB  B
01390:  SUBWF  x42,W
01392:  BZ    140C
.................... 		{  
.................... 			if(gFAT32Vars.bFATModified) 
01394:  MOVLB  2
01396:  MOVF   x3F,F
01398:  BZ    13A0
.................... 				SaveFATTable();			 
0139A:  MOVLB  0
0139C:  RCALL  1262
0139E:  MOVLB  2
.................... 			actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
013A0:  MOVF   x4E,W
013A2:  ADDWF  x23,W
013A4:  MOVLB  B
013A6:  MOVWF  x44
013A8:  MOVLB  2
013AA:  MOVF   x4F,W
013AC:  ADDWFC x24,W
013AE:  MOVLB  B
013B0:  MOVWF  x45
013B2:  MOVLW  00
013B4:  MOVLB  2
013B6:  ADDWFC x25,W
013B8:  MOVLB  B
013BA:  MOVWF  x46
013BC:  MOVLW  00
013BE:  MOVLB  2
013C0:  ADDWFC x26,W
013C2:  MOVLB  B
013C4:  MOVWF  x47
013C6:  MOVF   x3F,W
013C8:  ADDWF  x44,W
013CA:  MOVWF  x3B
013CC:  MOVF   x40,W
013CE:  ADDWFC x45,W
013D0:  MOVWF  x3C
013D2:  MOVF   x41,W
013D4:  ADDWFC x46,W
013D6:  MOVWF  x3D
013D8:  MOVF   x42,W
013DA:  ADDWFC x47,W
013DC:  MOVWF  x3E
.................... 			ReadSector(actsector,FATTable.FAT32); 
013DE:  MOVFF  B3E,B47
013E2:  MOVFF  B3D,B46
013E6:  MOVFF  B3C,B45
013EA:  MOVFF  B3B,B44
013EE:  CLRF   x49
013F0:  MOVLW  17
013F2:  MOVWF  x48
013F4:  MOVLB  0
013F6:  CALL   07CA
.................... 			gFAT32Vars.FATstartidx = clpage; 
013FA:  MOVFF  B42,222
013FE:  MOVFF  B41,221
01402:  MOVFF  B40,220
01406:  MOVFF  B3F,21F
0140A:  MOVLB  B
.................... 		} 
.................... 		return (FATTable.FAT32[clpos]); 
0140C:  CLRF   x62
0140E:  MOVFF  B43,B61
01412:  CLRF   x64
01414:  MOVLW  04
01416:  MOVWF  x63
01418:  MOVLB  0
0141A:  CALL   039E
0141E:  MOVFF  02,03
01422:  MOVF   01,W
01424:  ADDLW  17
01426:  MOVWF  FE9
01428:  MOVLW  00
0142A:  ADDWFC 02,W
0142C:  MOVWF  FEA
0142E:  MOVFF  FEF,00
01432:  MOVFF  FEC,01
01436:  MOVFF  FEC,02
0143A:  MOVFF  FEC,03
0143E:  BRA    1586
.................... 	} 
.................... 	else	//FAT16 
01440:  BRA    1586
01442:  MOVLB  4
.................... 	{ 
.................... 		clpage = curcluster >> 8; 
01444:  MOVFF  B38,B3F
01448:  MOVFF  B39,B40
0144C:  MOVFF  B3A,B41
01450:  MOVLB  B
01452:  CLRF   x42
.................... 		clpos = curcluster & 0xFF;		 
01454:  MOVFF  B37,B43
.................... 		if (clpage != gFAT32Vars.FATstartidx) // read in the requested page 
01458:  MOVLB  2
0145A:  MOVF   x1F,W
0145C:  MOVLB  B
0145E:  SUBWF  x3F,W
01460:  BNZ   1480
01462:  MOVLB  2
01464:  MOVF   x20,W
01466:  MOVLB  B
01468:  SUBWF  x40,W
0146A:  BNZ   1480
0146C:  MOVLB  2
0146E:  MOVF   x21,W
01470:  MOVLB  B
01472:  SUBWF  x41,W
01474:  BNZ   1480
01476:  MOVLB  2
01478:  MOVF   x22,W
0147A:  MOVLB  B
0147C:  SUBWF  x42,W
0147E:  BZ    14F8
.................... 		{  
.................... 			if(gFAT32Vars.bFATModified) 
01480:  MOVLB  2
01482:  MOVF   x3F,F
01484:  BZ    148C
.................... 				SaveFATTable(); 
01486:  MOVLB  0
01488:  RCALL  1262
0148A:  MOVLB  2
.................... 			actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
0148C:  MOVF   x4E,W
0148E:  ADDWF  x23,W
01490:  MOVLB  B
01492:  MOVWF  x44
01494:  MOVLB  2
01496:  MOVF   x4F,W
01498:  ADDWFC x24,W
0149A:  MOVLB  B
0149C:  MOVWF  x45
0149E:  MOVLW  00
014A0:  MOVLB  2
014A2:  ADDWFC x25,W
014A4:  MOVLB  B
014A6:  MOVWF  x46
014A8:  MOVLW  00
014AA:  MOVLB  2
014AC:  ADDWFC x26,W
014AE:  MOVLB  B
014B0:  MOVWF  x47
014B2:  MOVF   x3F,W
014B4:  ADDWF  x44,W
014B6:  MOVWF  x3B
014B8:  MOVF   x40,W
014BA:  ADDWFC x45,W
014BC:  MOVWF  x3C
014BE:  MOVF   x41,W
014C0:  ADDWFC x46,W
014C2:  MOVWF  x3D
014C4:  MOVF   x42,W
014C6:  ADDWFC x47,W
014C8:  MOVWF  x3E
.................... 			ReadSector(actsector,FATTable.FAT16); 
014CA:  MOVFF  B3E,B47
014CE:  MOVFF  B3D,B46
014D2:  MOVFF  B3C,B45
014D6:  MOVFF  B3B,B44
014DA:  CLRF   x49
014DC:  MOVLW  17
014DE:  MOVWF  x48
014E0:  MOVLB  0
014E2:  CALL   07CA
.................... 			gFAT32Vars.FATstartidx = clpage; 
014E6:  MOVFF  B42,222
014EA:  MOVFF  B41,221
014EE:  MOVFF  B40,220
014F2:  MOVFF  B3F,21F
014F6:  MOVLB  B
.................... 		} 
.................... 		if(FATTable.FAT16[clpos] > 0xFFF4) 
014F8:  BCF    FD8.0
014FA:  RLCF   x43,W
014FC:  MOVWF  02
014FE:  CLRF   03
01500:  RLCF   03,F
01502:  MOVF   02,W
01504:  ADDLW  17
01506:  MOVWF  FE9
01508:  MOVLW  00
0150A:  ADDWFC 03,W
0150C:  MOVWF  FEA
0150E:  MOVFF  FEC,B45
01512:  MOVF   FED,F
01514:  MOVFF  FEF,B44
01518:  MOVF   x45,W
0151A:  SUBLW  FE
0151C:  BC    1560
0151E:  XORLW  FF
01520:  BNZ   1528
01522:  MOVF   x44,W
01524:  SUBLW  F4
01526:  BC    1560
.................... 			return (FATTable.FAT16[clpos]|0x0FFF0000); 
01528:  BCF    FD8.0
0152A:  RLCF   x43,W
0152C:  MOVWF  02
0152E:  CLRF   03
01530:  RLCF   03,F
01532:  MOVF   02,W
01534:  ADDLW  17
01536:  MOVWF  FE9
01538:  MOVLW  00
0153A:  ADDWFC 03,W
0153C:  MOVWF  FEA
0153E:  MOVFF  FEC,B45
01542:  MOVF   FED,F
01544:  MOVFF  FEF,B44
01548:  MOVFF  B44,00
0154C:  MOVFF  B45,01
01550:  MOVLW  FF
01552:  MOVWF  02
01554:  MOVLW  0F
01556:  MOVWF  03
01558:  MOVLB  0
0155A:  BRA    1586
.................... 		else 
0155C:  BRA    1586
0155E:  MOVLB  B
.................... 			return (FATTable.FAT16[clpos]); 
01560:  BCF    FD8.0
01562:  RLCF   x43,W
01564:  MOVWF  02
01566:  CLRF   03
01568:  RLCF   03,F
0156A:  MOVF   02,W
0156C:  ADDLW  17
0156E:  MOVWF  FE9
01570:  MOVLW  00
01572:  ADDWFC 03,W
01574:  MOVWF  FEA
01576:  MOVFF  FEF,00
0157A:  MOVFF  FEC,01
0157E:  CLRF   02
01580:  CLRF   03
01582:  MOVLB  0
01584:  BRA    1586
.................... 	} 
.................... 	 
.................... } 
01586:  RETLW  00
....................  
.................... void SetClusterEntry(int32 curcluster,int32 value) 
.................... { 
.................... 	int32 actsector; 
.................... 	int32 clpage; 
.................... 	char clpos; 
....................  
.................... #ifdef TRACE 
.................... 	//fprintf(debug, "\r\nSetClusterEntry(%lu, %lu)", curcluster, value);	 
.................... #endif 
.................... 	if(gFATType == FAT32) 
*
02412:  MOVLB  4
02414:  MOVF   xBB,W
02416:  SUBLW  03
02418:  BTFSS  FD8.2
0241A:  BRA    2544
.................... 	{ 
.................... 		//FAT32, 4 bytes per entery. Total 128 entries per sector (512 bytes) 
.................... 		clpage = curcluster >> 7;	//Calculate sector# in FAT table 
0241C:  MOVLB  B
0241E:  RRCF   x18,W
02420:  MOVWF  x24
02422:  RRCF   x17,W
02424:  MOVWF  x23
02426:  RRCF   x16,W
02428:  MOVWF  x22
0242A:  RRCF   x15,W
0242C:  MOVWF  x21
0242E:  RRCF   x24,F
02430:  RRCF   x23,F
02432:  RRCF   x22,F
02434:  RRCF   x21,F
02436:  RRCF   x24,F
02438:  RRCF   x23,F
0243A:  RRCF   x22,F
0243C:  RRCF   x21,F
0243E:  RRCF   x24,F
02440:  RRCF   x23,F
02442:  RRCF   x22,F
02444:  RRCF   x21,F
02446:  RRCF   x24,F
02448:  RRCF   x23,F
0244A:  RRCF   x22,F
0244C:  RRCF   x21,F
0244E:  RRCF   x24,F
02450:  RRCF   x23,F
02452:  RRCF   x22,F
02454:  RRCF   x21,F
02456:  RRCF   x24,F
02458:  RRCF   x23,F
0245A:  RRCF   x22,F
0245C:  RRCF   x21,F
0245E:  MOVLW  01
02460:  ANDWF  x24,F
.................... 		clpos = curcluster & 0x7F;	//Calculate FAT index in sector 
02462:  MOVF   x15,W
02464:  ANDLW  7F
02466:  MOVWF  x25
.................... 		//Calculate FAT physical sector # 
.................... 		actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
02468:  MOVLB  2
0246A:  MOVF   x4E,W
0246C:  ADDWF  x23,W
0246E:  MOVLB  B
02470:  MOVWF  x26
02472:  MOVLB  2
02474:  MOVF   x4F,W
02476:  ADDWFC x24,W
02478:  MOVLB  B
0247A:  MOVWF  x27
0247C:  MOVLW  00
0247E:  MOVLB  2
02480:  ADDWFC x25,W
02482:  MOVLB  B
02484:  MOVWF  x28
02486:  MOVLW  00
02488:  MOVLB  2
0248A:  ADDWFC x26,W
0248C:  MOVLB  B
0248E:  MOVWF  x29
02490:  MOVF   x21,W
02492:  ADDWF  x26,W
02494:  MOVWF  x1D
02496:  MOVF   x22,W
02498:  ADDWFC x27,W
0249A:  MOVWF  x1E
0249C:  MOVF   x23,W
0249E:  ADDWFC x28,W
024A0:  MOVWF  x1F
024A2:  MOVF   x24,W
024A4:  ADDWFC x29,W
024A6:  MOVWF  x20
.................... 		 
.................... 		if (clpage != gFAT32Vars.FATstartidx)  
024A8:  MOVLB  2
024AA:  MOVF   x1F,W
024AC:  MOVLB  B
024AE:  SUBWF  x21,W
024B0:  BNZ   24D0
024B2:  MOVLB  2
024B4:  MOVF   x20,W
024B6:  MOVLB  B
024B8:  SUBWF  x22,W
024BA:  BNZ   24D0
024BC:  MOVLB  2
024BE:  MOVF   x21,W
024C0:  MOVLB  B
024C2:  SUBWF  x23,W
024C4:  BNZ   24D0
024C6:  MOVLB  2
024C8:  MOVF   x22,W
024CA:  MOVLB  B
024CC:  SUBWF  x24,W
024CE:  BZ    250C
.................... 		{ 
.................... 			if(gFAT32Vars.bFATModified) 
024D0:  MOVLB  2
024D2:  MOVF   x3F,F
024D4:  BZ    24DC
.................... 				SaveFATTable(); 
024D6:  MOVLB  0
024D8:  CALL   1262
.................... 			ReadSector(actsector,FATTable.FAT32); 
024DC:  MOVFF  B20,B47
024E0:  MOVFF  B1F,B46
024E4:  MOVFF  B1E,B45
024E8:  MOVFF  B1D,B44
024EC:  MOVLB  B
024EE:  CLRF   x49
024F0:  MOVLW  17
024F2:  MOVWF  x48
024F4:  MOVLB  0
024F6:  CALL   07CA
.................... 			gFAT32Vars.FATstartidx = clpage; 
024FA:  MOVFF  B24,222
024FE:  MOVFF  B23,221
02502:  MOVFF  B22,220
02506:  MOVFF  B21,21F
0250A:  MOVLB  B
.................... 		} 
.................... 		FATTable.FAT32[clpos] = value; 
0250C:  CLRF   x62
0250E:  MOVFF  B25,B61
02512:  CLRF   x64
02514:  MOVLW  04
02516:  MOVWF  x63
02518:  MOVLB  0
0251A:  CALL   039E
0251E:  MOVF   01,W
02520:  ADDLW  17
02522:  MOVWF  FE9
02524:  MOVLW  00
02526:  ADDWFC 02,W
02528:  MOVWF  FEA
0252A:  MOVFF  B19,FEF
0252E:  MOVFF  B1A,FEC
02532:  MOVFF  B1B,FEC
02536:  MOVFF  B1C,FEC
.................... 		gFAT32Vars.bFATModified = 1; 
0253A:  MOVLW  01
0253C:  MOVLB  2
0253E:  MOVWF  x3F
.................... 	} 
.................... 	else	//FAT16 
02540:  BRA    2620
02542:  MOVLB  4
.................... 	{ 
.................... 		//FAT16, 2 bytes per entry. Total 256 entries per sector (512 bytes) 
.................... 		clpage = curcluster >> 8; 
02544:  MOVFF  B16,B21
02548:  MOVFF  B17,B22
0254C:  MOVFF  B18,B23
02550:  MOVLB  B
02552:  CLRF   x24
.................... 		clpos = curcluster & 0xFF; 
02554:  MOVFF  B15,B25
.................... 		actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
02558:  MOVLB  2
0255A:  MOVF   x4E,W
0255C:  ADDWF  x23,W
0255E:  MOVLB  B
02560:  MOVWF  x26
02562:  MOVLB  2
02564:  MOVF   x4F,W
02566:  ADDWFC x24,W
02568:  MOVLB  B
0256A:  MOVWF  x27
0256C:  MOVLW  00
0256E:  MOVLB  2
02570:  ADDWFC x25,W
02572:  MOVLB  B
02574:  MOVWF  x28
02576:  MOVLW  00
02578:  MOVLB  2
0257A:  ADDWFC x26,W
0257C:  MOVLB  B
0257E:  MOVWF  x29
02580:  MOVF   x21,W
02582:  ADDWF  x26,W
02584:  MOVWF  x1D
02586:  MOVF   x22,W
02588:  ADDWFC x27,W
0258A:  MOVWF  x1E
0258C:  MOVF   x23,W
0258E:  ADDWFC x28,W
02590:  MOVWF  x1F
02592:  MOVF   x24,W
02594:  ADDWFC x29,W
02596:  MOVWF  x20
.................... 		if (clpage != gFAT32Vars.FATstartidx)  
02598:  MOVLB  2
0259A:  MOVF   x1F,W
0259C:  MOVLB  B
0259E:  SUBWF  x21,W
025A0:  BNZ   25C0
025A2:  MOVLB  2
025A4:  MOVF   x20,W
025A6:  MOVLB  B
025A8:  SUBWF  x22,W
025AA:  BNZ   25C0
025AC:  MOVLB  2
025AE:  MOVF   x21,W
025B0:  MOVLB  B
025B2:  SUBWF  x23,W
025B4:  BNZ   25C0
025B6:  MOVLB  2
025B8:  MOVF   x22,W
025BA:  MOVLB  B
025BC:  SUBWF  x24,W
025BE:  BZ    25FC
.................... 		{ 
.................... 			if(gFAT32Vars.bFATModified) 
025C0:  MOVLB  2
025C2:  MOVF   x3F,F
025C4:  BZ    25CC
.................... 				SaveFATTable(); 
025C6:  MOVLB  0
025C8:  CALL   1262
.................... 			ReadSector(actsector,FATTable.FAT16); 
025CC:  MOVFF  B20,B47
025D0:  MOVFF  B1F,B46
025D4:  MOVFF  B1E,B45
025D8:  MOVFF  B1D,B44
025DC:  MOVLB  B
025DE:  CLRF   x49
025E0:  MOVLW  17
025E2:  MOVWF  x48
025E4:  MOVLB  0
025E6:  CALL   07CA
.................... 			gFAT32Vars.FATstartidx = clpage; 
025EA:  MOVFF  B24,222
025EE:  MOVFF  B23,221
025F2:  MOVFF  B22,220
025F6:  MOVFF  B21,21F
025FA:  MOVLB  B
.................... 		} 
.................... 		FATTable.FAT16[clpos] = value; 
025FC:  BCF    FD8.0
025FE:  RLCF   x25,W
02600:  MOVWF  02
02602:  CLRF   03
02604:  RLCF   03,F
02606:  MOVF   02,W
02608:  ADDLW  17
0260A:  MOVWF  FE9
0260C:  MOVLW  00
0260E:  ADDWFC 03,W
02610:  MOVWF  FEA
02612:  MOVFF  B19,FEF
02616:  MOVFF  B1A,FEC
.................... 		gFAT32Vars.bFATModified = 1; 
0261A:  MOVLW  01
0261C:  MOVLB  2
0261E:  MOVWF  x3F
.................... 	} 
.................... //	gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
.................... //	actsector += gFAT32Vars.nFatSize; 
.................... //	gFATErrCode = WriteSector(actsector,FATTable.FAT32); 
.................... } 
02620:  MOVLB  0
02622:  RETLW  00
....................  
.................... void ClearClusterEntry(int32 curcluster) 
.................... { 
.................... 	int32 actsector; 
.................... 	int32 clpage; 
.................... 	char clpos; 
....................  
.................... #ifdef TRACE 
.................... 	//fprintf(debug, "\r\nClearClusterEntry()");	 
.................... #endif 
.................... 	if(gFATType == FAT32) 
*
0468C:  MOVLB  4
0468E:  MOVF   xBB,W
04690:  SUBLW  03
04692:  BNZ   46F6
.................... 	{ 
.................... 		clpage = curcluster >> 7; 
04694:  MOVLB  A
04696:  RRCF   xFF,W
04698:  MOVLB  B
0469A:  MOVWF  x07
0469C:  MOVLB  A
0469E:  RRCF   xFE,W
046A0:  MOVLB  B
046A2:  MOVWF  x06
046A4:  MOVLB  A
046A6:  RRCF   xFD,W
046A8:  MOVLB  B
046AA:  MOVWF  x05
046AC:  MOVLB  A
046AE:  RRCF   xFC,W
046B0:  MOVLB  B
046B2:  MOVWF  x04
046B4:  RRCF   x07,F
046B6:  RRCF   x06,F
046B8:  RRCF   x05,F
046BA:  RRCF   x04,F
046BC:  RRCF   x07,F
046BE:  RRCF   x06,F
046C0:  RRCF   x05,F
046C2:  RRCF   x04,F
046C4:  RRCF   x07,F
046C6:  RRCF   x06,F
046C8:  RRCF   x05,F
046CA:  RRCF   x04,F
046CC:  RRCF   x07,F
046CE:  RRCF   x06,F
046D0:  RRCF   x05,F
046D2:  RRCF   x04,F
046D4:  RRCF   x07,F
046D6:  RRCF   x06,F
046D8:  RRCF   x05,F
046DA:  RRCF   x04,F
046DC:  RRCF   x07,F
046DE:  RRCF   x06,F
046E0:  RRCF   x05,F
046E2:  RRCF   x04,F
046E4:  MOVLW  01
046E6:  ANDWF  x07,F
.................... 		clpos = curcluster & 0x7F; 
046E8:  MOVLB  A
046EA:  MOVF   xFC,W
046EC:  ANDLW  7F
046EE:  MOVLB  B
046F0:  MOVWF  x08
.................... 	} 
.................... 	else	//FAT16 
046F2:  BRA    470C
046F4:  MOVLB  4
.................... 	{ 
.................... 		clpage = curcluster >> 8; 
046F6:  MOVFF  AFD,B04
046FA:  MOVFF  AFE,B05
046FE:  MOVFF  AFF,B06
04702:  MOVLB  B
04704:  CLRF   x07
.................... 		clpos = curcluster & 0xFF; 
04706:  MOVFF  AFC,B08
0470A:  MOVLB  B
.................... 	} 
.................... 	if (clpage != gFAT32Vars.FATstartidx)  
0470C:  MOVLB  2
0470E:  MOVF   x1F,W
04710:  MOVLB  B
04712:  SUBWF  x04,W
04714:  BNZ   4736
04716:  MOVLB  2
04718:  MOVF   x20,W
0471A:  MOVLB  B
0471C:  SUBWF  x05,W
0471E:  BNZ   4736
04720:  MOVLB  2
04722:  MOVF   x21,W
04724:  MOVLB  B
04726:  SUBWF  x06,W
04728:  BNZ   4736
0472A:  MOVLB  2
0472C:  MOVF   x22,W
0472E:  MOVLB  B
04730:  SUBWF  x07,W
04732:  BTFSC  FD8.2
04734:  BRA    484A
.................... 	{ 
.................... 		actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
04736:  MOVLB  2
04738:  MOVF   x4E,W
0473A:  ADDWF  x23,W
0473C:  MOVLB  B
0473E:  MOVWF  x09
04740:  MOVLB  2
04742:  MOVF   x4F,W
04744:  ADDWFC x24,W
04746:  MOVLB  B
04748:  MOVWF  x0A
0474A:  MOVLW  00
0474C:  MOVLB  2
0474E:  ADDWFC x25,W
04750:  MOVLB  B
04752:  MOVWF  x0B
04754:  MOVLW  00
04756:  MOVLB  2
04758:  ADDWFC x26,W
0475A:  MOVLB  B
0475C:  MOVWF  x0C
0475E:  MOVLB  2
04760:  MOVF   x1F,W
04762:  MOVLB  B
04764:  ADDWF  x09,W
04766:  MOVWF  x00
04768:  MOVLB  2
0476A:  MOVF   x20,W
0476C:  MOVLB  B
0476E:  ADDWFC x0A,W
04770:  MOVWF  x01
04772:  MOVLB  2
04774:  MOVF   x21,W
04776:  MOVLB  B
04778:  ADDWFC x0B,W
0477A:  MOVWF  x02
0477C:  MOVLB  2
0477E:  MOVF   x22,W
04780:  MOVLB  B
04782:  ADDWFC x0C,W
04784:  MOVWF  x03
.................... 		WriteSector(actsector,FATTable.FAT32); 
04786:  MOVFF  B03,B4B
0478A:  MOVFF  B02,B4A
0478E:  MOVFF  B01,B49
04792:  MOVFF  B00,B48
04796:  CLRF   x4D
04798:  MOVLW  17
0479A:  MOVWF  x4C
0479C:  MOVLB  0
0479E:  CALL   1156
.................... 		actsector += gFAT32Vars.nFatSize; 
047A2:  MOVLB  2
047A4:  MOVF   x3B,W
047A6:  MOVLB  B
047A8:  ADDWF  x00,F
047AA:  MOVLB  2
047AC:  MOVF   x3C,W
047AE:  MOVLB  B
047B0:  ADDWFC x01,F
047B2:  MOVLB  2
047B4:  MOVF   x3D,W
047B6:  MOVLB  B
047B8:  ADDWFC x02,F
047BA:  MOVLB  2
047BC:  MOVF   x3E,W
047BE:  MOVLB  B
047C0:  ADDWFC x03,F
.................... 		WriteSector(actsector,FATTable.FAT32); 
047C2:  MOVFF  B03,B4B
047C6:  MOVFF  B02,B4A
047CA:  MOVFF  B01,B49
047CE:  MOVFF  B00,B48
047D2:  CLRF   x4D
047D4:  MOVLW  17
047D6:  MOVWF  x4C
047D8:  MOVLB  0
047DA:  CALL   1156
.................... 		actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + clpage; 
047DE:  MOVLB  2
047E0:  MOVF   x4E,W
047E2:  ADDWF  x23,W
047E4:  MOVLB  B
047E6:  MOVWF  x09
047E8:  MOVLB  2
047EA:  MOVF   x4F,W
047EC:  ADDWFC x24,W
047EE:  MOVLB  B
047F0:  MOVWF  x0A
047F2:  MOVLW  00
047F4:  MOVLB  2
047F6:  ADDWFC x25,W
047F8:  MOVLB  B
047FA:  MOVWF  x0B
047FC:  MOVLW  00
047FE:  MOVLB  2
04800:  ADDWFC x26,W
04802:  MOVLB  B
04804:  MOVWF  x0C
04806:  MOVF   x04,W
04808:  ADDWF  x09,W
0480A:  MOVWF  x00
0480C:  MOVF   x05,W
0480E:  ADDWFC x0A,W
04810:  MOVWF  x01
04812:  MOVF   x06,W
04814:  ADDWFC x0B,W
04816:  MOVWF  x02
04818:  MOVF   x07,W
0481A:  ADDWFC x0C,W
0481C:  MOVWF  x03
.................... 		ReadSector(actsector,FATTable.FAT32); 
0481E:  MOVFF  B03,B47
04822:  MOVFF  B02,B46
04826:  MOVFF  B01,B45
0482A:  MOVFF  B00,B44
0482E:  CLRF   x49
04830:  MOVLW  17
04832:  MOVWF  x48
04834:  MOVLB  0
04836:  CALL   07CA
.................... 		gFAT32Vars.FATstartidx = clpage; 
0483A:  MOVFF  B07,222
0483E:  MOVFF  B06,221
04842:  MOVFF  B05,220
04846:  MOVFF  B04,21F
.................... 	} 
.................... 	 
.................... 	if(gFATType == FAT32) 
0484A:  MOVLB  4
0484C:  MOVF   xBB,W
0484E:  SUBLW  03
04850:  BNZ   4888
.................... 	{ 
.................... 		FATTable.FAT32[clpos] = 0; 
04852:  MOVLB  B
04854:  CLRF   x62
04856:  MOVFF  B08,B61
0485A:  CLRF   x64
0485C:  MOVLW  04
0485E:  MOVWF  x63
04860:  MOVLB  0
04862:  CALL   039E
04866:  MOVF   01,W
04868:  ADDLW  17
0486A:  MOVWF  FE9
0486C:  MOVLW  00
0486E:  ADDWFC 02,W
04870:  MOVWF  FEA
04872:  MOVF   FEE,F
04874:  MOVF   FEE,F
04876:  CLRF   FEC
04878:  MOVF   FED,F
0487A:  CLRF   FEF
0487C:  MOVF   FED,F
0487E:  CLRF   FEF
04880:  MOVF   FED,F
04882:  CLRF   FEF
.................... 	} 
.................... 	else	//FAT16 
04884:  BRA    48A6
04886:  MOVLB  4
.................... 	{ 
.................... 		FATTable.FAT16[clpos] = 0; 
04888:  BCF    FD8.0
0488A:  MOVLB  B
0488C:  RLCF   x08,W
0488E:  MOVWF  02
04890:  CLRF   03
04892:  RLCF   03,F
04894:  MOVF   02,W
04896:  ADDLW  17
04898:  MOVWF  FE9
0489A:  MOVLW  00
0489C:  ADDWFC 03,W
0489E:  MOVWF  FEA
048A0:  CLRF   FEC
048A2:  MOVF   FED,F
048A4:  CLRF   FEF
.................... 	} 
.................... 	gFAT32Vars.bFATModified = 1; 
048A6:  MOVLW  01
048A8:  MOVLB  2
048AA:  MOVWF  x3F
.................... } 
048AC:  MOVLB  0
048AE:  RETLW  00
....................  
.................... int32 FindFirstFreeCluster() 
.................... { 
.................... 	int32 i,st,actsector,retval; 
.................... 	int16 j; 
....................  
.................... #ifdef TRACE 
.................... 	//fprintf(debug, "\r\nFindFirstFreeCluster()");	 
.................... #endif 
.................... 	st = gFirstEmptyCluster; 
*
02078:  MOVFF  21A,B16
0207C:  MOVFF  219,B15
02080:  MOVFF  218,B14
02084:  MOVFF  217,B13
.................... 	if(gFATType == FAT32) 
02088:  MOVLB  4
0208A:  MOVF   xBB,W
0208C:  SUBLW  03
0208E:  BTFSS  FD8.2
02090:  BRA    225E
.................... 	{ 
.................... 		for (i=st;i<DiskInfo.FATSz32;i++)  
02092:  MOVFF  B16,B12
02096:  MOVFF  B15,B11
0209A:  MOVFF  B14,B10
0209E:  MOVFF  B13,B0F
020A2:  MOVLB  B
020A4:  MOVF   x12,W
020A6:  MOVLB  2
020A8:  SUBWF  x67,W
020AA:  BTFSS  FD8.0
020AC:  BRA    225A
020AE:  BNZ   20DC
020B0:  MOVLB  B
020B2:  MOVF   x11,W
020B4:  MOVLB  2
020B6:  SUBWF  x66,W
020B8:  BTFSS  FD8.0
020BA:  BRA    225A
020BC:  BNZ   20DC
020BE:  MOVLB  B
020C0:  MOVF   x10,W
020C2:  MOVLB  2
020C4:  SUBWF  x65,W
020C6:  BTFSS  FD8.0
020C8:  BRA    225A
020CA:  BNZ   20DC
020CC:  MOVF   x64,W
020CE:  MOVLB  B
020D0:  SUBWF  x0F,W
020D2:  BTFSS  FD8.0
020D4:  BRA    20DA
020D6:  MOVLB  2
020D8:  BRA    225A
020DA:  MOVLB  2
.................... 		{ 
.................... 			if (i != gFAT32Vars.FATstartidx)  
020DC:  MOVF   x1F,W
020DE:  MOVLB  B
020E0:  SUBWF  x0F,W
020E2:  BNZ   2102
020E4:  MOVLB  2
020E6:  MOVF   x20,W
020E8:  MOVLB  B
020EA:  SUBWF  x10,W
020EC:  BNZ   2102
020EE:  MOVLB  2
020F0:  MOVF   x21,W
020F2:  MOVLB  B
020F4:  SUBWF  x11,W
020F6:  BNZ   2102
020F8:  MOVLB  2
020FA:  MOVF   x22,W
020FC:  MOVLB  B
020FE:  SUBWF  x12,W
02100:  BZ    218E
.................... 			{ 
.................... 				actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + i; 
02102:  MOVLB  2
02104:  MOVF   x4E,W
02106:  ADDWF  x23,W
02108:  MOVLB  B
0210A:  MOVWF  x21
0210C:  MOVLB  2
0210E:  MOVF   x4F,W
02110:  ADDWFC x24,W
02112:  MOVLB  B
02114:  MOVWF  x22
02116:  MOVLW  00
02118:  MOVLB  2
0211A:  ADDWFC x25,W
0211C:  MOVLB  B
0211E:  MOVWF  x23
02120:  MOVLW  00
02122:  MOVLB  2
02124:  ADDWFC x26,W
02126:  MOVLB  B
02128:  MOVWF  x24
0212A:  MOVF   x0F,W
0212C:  ADDWF  x21,W
0212E:  MOVWF  x17
02130:  MOVF   x10,W
02132:  ADDWFC x22,W
02134:  MOVWF  x18
02136:  MOVF   x11,W
02138:  ADDWFC x23,W
0213A:  MOVWF  x19
0213C:  MOVF   x12,W
0213E:  ADDWFC x24,W
02140:  MOVWF  x1A
.................... 				//Save FAT 
.................... 				if(gFAT32Vars.bFATModified) 
02142:  MOVLB  2
02144:  MOVF   x3F,F
02146:  BZ    214E
.................... 					SaveFATTable(); 
02148:  MOVLB  0
0214A:  CALL   1262
.................... 				ReadSector(actsector,FATTable.FAT32); 
0214E:  MOVFF  B1A,B47
02152:  MOVFF  B19,B46
02156:  MOVFF  B18,B45
0215A:  MOVFF  B17,B44
0215E:  MOVLB  B
02160:  CLRF   x49
02162:  MOVLW  17
02164:  MOVWF  x48
02166:  MOVLB  0
02168:  CALL   07CA
.................... 				gFAT32Vars.FATstartidx = gFirstEmptyCluster = i; 
0216C:  MOVFF  B12,21A
02170:  MOVFF  B11,219
02174:  MOVFF  B10,218
02178:  MOVFF  B0F,217
0217C:  MOVFF  21A,222
02180:  MOVFF  219,221
02184:  MOVFF  218,220
02188:  MOVFF  217,21F
0218C:  MOVLB  B
.................... 			} 
.................... 			for (j=0;j<128;j++) 
0218E:  CLRF   x20
02190:  CLRF   x1F
02192:  MOVF   x20,F
02194:  BNZ   2246
02196:  MOVF   x1F,W
02198:  SUBLW  7F
0219A:  BNC   2246
.................... 				if (FATTable.FAT32[j] == 0)  
0219C:  RLCF   x1F,W
0219E:  MOVWF  02
021A0:  RLCF   x20,W
021A2:  MOVWF  03
021A4:  RLCF   02,F
021A6:  RLCF   03,F
021A8:  MOVLW  FC
021AA:  ANDWF  02,F
021AC:  MOVF   02,W
021AE:  ADDLW  17
021B0:  MOVWF  FE9
021B2:  MOVLW  00
021B4:  ADDWFC 03,W
021B6:  MOVWF  FEA
021B8:  MOVFF  FEF,B21
021BC:  MOVFF  FEC,B22
021C0:  MOVFF  FEC,B23
021C4:  MOVFF  FEC,B24
021C8:  MOVF   x21,F
021CA:  BNZ   223E
021CC:  MOVF   x22,F
021CE:  BNZ   223E
021D0:  MOVF   x23,F
021D2:  BNZ   223E
021D4:  MOVF   x24,F
021D6:  BNZ   223E
.................... 				{ 
.................... 					retval = i; 
021D8:  MOVFF  B12,B1E
021DC:  MOVFF  B11,B1D
021E0:  MOVFF  B10,B1C
021E4:  MOVFF  B0F,B1B
.................... 					retval <<= 7; 
021E8:  RLCF   x1B,F
021EA:  RLCF   x1C,F
021EC:  RLCF   x1D,F
021EE:  RLCF   x1E,F
021F0:  RLCF   x1B,F
021F2:  RLCF   x1C,F
021F4:  RLCF   x1D,F
021F6:  RLCF   x1E,F
021F8:  RLCF   x1B,F
021FA:  RLCF   x1C,F
021FC:  RLCF   x1D,F
021FE:  RLCF   x1E,F
02200:  RLCF   x1B,F
02202:  RLCF   x1C,F
02204:  RLCF   x1D,F
02206:  RLCF   x1E,F
02208:  RLCF   x1B,F
0220A:  RLCF   x1C,F
0220C:  RLCF   x1D,F
0220E:  RLCF   x1E,F
02210:  RLCF   x1B,F
02212:  RLCF   x1C,F
02214:  RLCF   x1D,F
02216:  RLCF   x1E,F
02218:  RLCF   x1B,F
0221A:  RLCF   x1C,F
0221C:  RLCF   x1D,F
0221E:  RLCF   x1E,F
02220:  MOVLW  80
02222:  ANDWF  x1B,F
.................... 					retval |= j; 
02224:  MOVF   x1F,W
02226:  IORWF  x1B,F
02228:  MOVF   x20,W
0222A:  IORWF  x1C,F
.................... 					return retval; 
0222C:  MOVFF  B1B,00
02230:  MOVFF  B1C,01
02234:  MOVFF  B1D,02
02238:  MOVFF  B1E,03
0223C:  BRA    240E
.................... 				} 
0223E:  INCF   x1F,F
02240:  BTFSC  FD8.2
02242:  INCF   x20,F
02244:  BRA    2192
.................... 		} 
02246:  MOVLW  01
02248:  ADDWF  x0F,F
0224A:  BTFSC  FD8.0
0224C:  INCF   x10,F
0224E:  BTFSC  FD8.2
02250:  INCF   x11,F
02252:  BTFSC  FD8.2
02254:  INCF   x12,F
02256:  BRA    20A4
02258:  MOVLB  2
.................... 	} 
.................... 	else	//FAT16 
0225A:  BRA    2400
0225C:  MOVLB  4
.................... 	{ 
.................... 		for (i=st;i<DiskInfo.FATSz16;i++)  
0225E:  MOVFF  B16,B12
02262:  MOVFF  B15,B11
02266:  MOVFF  B14,B10
0226A:  MOVFF  B13,B0F
0226E:  MOVLB  B
02270:  MOVF   x12,F
02272:  BTFSS  FD8.2
02274:  BRA    23FE
02276:  MOVF   x11,F
02278:  BTFSS  FD8.2
0227A:  BRA    23FE
0227C:  MOVF   x10,W
0227E:  MOVLB  2
02280:  SUBWF  x57,W
02282:  BTFSC  FD8.0
02284:  BRA    228A
02286:  MOVLB  B
02288:  BRA    23FE
0228A:  BNZ   2298
0228C:  MOVF   x56,W
0228E:  MOVLB  B
02290:  SUBWF  x0F,W
02292:  BTFSC  FD8.0
02294:  BRA    23FE
02296:  MOVLB  2
.................... 		{ 
.................... 			if (i != gFAT32Vars.FATstartidx)  
02298:  MOVF   x1F,W
0229A:  MOVLB  B
0229C:  SUBWF  x0F,W
0229E:  BNZ   22BE
022A0:  MOVLB  2
022A2:  MOVF   x20,W
022A4:  MOVLB  B
022A6:  SUBWF  x10,W
022A8:  BNZ   22BE
022AA:  MOVLB  2
022AC:  MOVF   x21,W
022AE:  MOVLB  B
022B0:  SUBWF  x11,W
022B2:  BNZ   22BE
022B4:  MOVLB  2
022B6:  MOVF   x22,W
022B8:  MOVLB  B
022BA:  SUBWF  x12,W
022BC:  BZ    234A
.................... 			{ 
.................... 				actsector = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + i; 
022BE:  MOVLB  2
022C0:  MOVF   x4E,W
022C2:  ADDWF  x23,W
022C4:  MOVLB  B
022C6:  MOVWF  x21
022C8:  MOVLB  2
022CA:  MOVF   x4F,W
022CC:  ADDWFC x24,W
022CE:  MOVLB  B
022D0:  MOVWF  x22
022D2:  MOVLW  00
022D4:  MOVLB  2
022D6:  ADDWFC x25,W
022D8:  MOVLB  B
022DA:  MOVWF  x23
022DC:  MOVLW  00
022DE:  MOVLB  2
022E0:  ADDWFC x26,W
022E2:  MOVLB  B
022E4:  MOVWF  x24
022E6:  MOVF   x0F,W
022E8:  ADDWF  x21,W
022EA:  MOVWF  x17
022EC:  MOVF   x10,W
022EE:  ADDWFC x22,W
022F0:  MOVWF  x18
022F2:  MOVF   x11,W
022F4:  ADDWFC x23,W
022F6:  MOVWF  x19
022F8:  MOVF   x12,W
022FA:  ADDWFC x24,W
022FC:  MOVWF  x1A
.................... 				if(gFAT32Vars.bFATModified) 
022FE:  MOVLB  2
02300:  MOVF   x3F,F
02302:  BZ    230A
.................... 					SaveFATTable(); 
02304:  MOVLB  0
02306:  CALL   1262
.................... 				ReadSector(actsector,FATTable.FAT16); 
0230A:  MOVFF  B1A,B47
0230E:  MOVFF  B19,B46
02312:  MOVFF  B18,B45
02316:  MOVFF  B17,B44
0231A:  MOVLB  B
0231C:  CLRF   x49
0231E:  MOVLW  17
02320:  MOVWF  x48
02322:  MOVLB  0
02324:  CALL   07CA
.................... 				gFAT32Vars.FATstartidx = gFirstEmptyCluster = i; 
02328:  MOVFF  B12,21A
0232C:  MOVFF  B11,219
02330:  MOVFF  B10,218
02334:  MOVFF  B0F,217
02338:  MOVFF  21A,222
0233C:  MOVFF  219,221
02340:  MOVFF  218,220
02344:  MOVFF  217,21F
02348:  MOVLB  B
.................... 			} 
.................... 			for (j=0;j<256;j++) 
0234A:  CLRF   x20
0234C:  CLRF   x1F
0234E:  MOVF   x20,W
02350:  SUBLW  00
02352:  BNC   23EC
.................... 				if (FATTable.FAT16[j] == 0)  
02354:  BCF    FD8.0
02356:  RLCF   x1F,W
02358:  MOVWF  02
0235A:  RLCF   x20,W
0235C:  MOVWF  03
0235E:  MOVF   02,W
02360:  ADDLW  17
02362:  MOVWF  FE9
02364:  MOVLW  00
02366:  ADDWFC 03,W
02368:  MOVWF  FEA
0236A:  MOVFF  FEC,B22
0236E:  MOVF   FED,F
02370:  MOVFF  FEF,B21
02374:  MOVF   x21,F
02376:  BNZ   23E4
02378:  MOVF   x22,F
0237A:  BNZ   23E4
.................... 				{ 
.................... 					retval = i; 
0237C:  MOVFF  B12,B1E
02380:  MOVFF  B11,B1D
02384:  MOVFF  B10,B1C
02388:  MOVFF  B0F,B1B
.................... 					retval <<= 8; 
0238C:  MOVFF  B1D,B1E
02390:  MOVFF  B1C,B1D
02394:  MOVFF  B1B,B1C
02398:  CLRF   x1B
.................... 					retval |= j; 
0239A:  MOVF   x1F,W
0239C:  IORWF  x1B,F
0239E:  MOVF   x20,W
023A0:  IORWF  x1C,F
.................... 					if(retval > 0xFFF4) 
023A2:  MOVF   x1E,F
023A4:  BNZ   23BA
023A6:  MOVF   x1D,F
023A8:  BNZ   23BA
023AA:  MOVF   x1C,W
023AC:  SUBLW  FE
023AE:  BC    23D2
023B0:  XORLW  FF
023B2:  BNZ   23BA
023B4:  MOVF   x1B,W
023B6:  SUBLW  F4
023B8:  BC    23D2
.................... 						return (retval|0x0FFF0000); 
023BA:  MOVFF  B1B,00
023BE:  MOVFF  B1C,01
023C2:  MOVF   x1D,W
023C4:  IORLW  FF
023C6:  MOVWF  02
023C8:  MOVF   x1E,W
023CA:  IORLW  0F
023CC:  MOVWF  03
023CE:  BRA    240E
.................... 					else 
023D0:  BRA    23E4
.................... 						return retval; 
023D2:  MOVFF  B1B,00
023D6:  MOVFF  B1C,01
023DA:  MOVFF  B1D,02
023DE:  MOVFF  B1E,03
023E2:  BRA    240E
.................... 				} 
023E4:  INCF   x1F,F
023E6:  BTFSC  FD8.2
023E8:  INCF   x20,F
023EA:  BRA    234E
.................... 		} 
023EC:  MOVLW  01
023EE:  ADDWF  x0F,F
023F0:  BTFSC  FD8.0
023F2:  INCF   x10,F
023F4:  BTFSC  FD8.2
023F6:  INCF   x11,F
023F8:  BTFSC  FD8.2
023FA:  INCF   x12,F
023FC:  BRA    2270
023FE:  MOVLB  2
.................... 	} 
.................... 	return 0x0FFFFFFF; 
02400:  MOVLW  FF
02402:  MOVWF  00
02404:  MOVWF  01
02406:  MOVWF  02
02408:  MOVLW  0F
0240A:  MOVWF  03
0240C:  MOVLB  B
.................... } 
0240E:  MOVLB  0
02410:  RETLW  00
....................  
.................... void ConvertFilename(DIR *beDir,char *name) 
.................... { 
.................... 	char i,j,c; 
....................  
.................... 	j = 0; 
*
0101C:  MOVLB  B
0101E:  CLRF   x36
.................... 	name[0] = 0; 
01020:  MOVFF  B33,FE9
01024:  MOVFF  B34,FEA
01028:  CLRF   FEF
.................... 	for (i=0;i<8;i++) { 
0102A:  CLRF   x35
0102C:  MOVF   x35,W
0102E:  SUBLW  07
01030:  BNC   1064
.................... 		c = beDir->sName[i]; 
01032:  CLRF   03
01034:  MOVF   x35,W
01036:  ADDWF  x31,W
01038:  MOVWF  FE9
0103A:  MOVF   x32,W
0103C:  ADDWFC 03,W
0103E:  MOVWF  FEA
01040:  MOVFF  FEF,B37
.................... 		if (c == ' ') break; 
01044:  MOVF   x37,W
01046:  SUBLW  20
01048:  BNZ   104C
0104A:  BRA    1064
.................... 		name[j++] = c; 
0104C:  MOVF   x36,W
0104E:  INCF   x36,F
01050:  CLRF   03
01052:  ADDWF  x33,W
01054:  MOVWF  FE9
01056:  MOVF   x34,W
01058:  ADDWFC 03,W
0105A:  MOVWF  FEA
0105C:  MOVFF  B37,FEF
.................... 	} 
01060:  INCF   x35,F
01062:  BRA    102C
.................... 	for (i=0;i<3;i++) { 
01064:  CLRF   x35
01066:  MOVF   x35,W
01068:  SUBLW  02
0106A:  BNC   10C4
.................... 		c = beDir->sExt[i]; 
0106C:  CLRF   03
0106E:  MOVF   x35,W
01070:  ADDLW  08
01072:  MOVWF  01
01074:  MOVLW  00
01076:  ADDWFC 03,F
01078:  MOVF   01,W
0107A:  ADDWF  x31,W
0107C:  MOVWF  FE9
0107E:  MOVF   x32,W
01080:  ADDWFC 03,W
01082:  MOVWF  FEA
01084:  MOVFF  FEF,B37
.................... 		if (c == ' ' || c == 0) break; 
01088:  MOVF   x37,W
0108A:  SUBLW  20
0108C:  BZ    1092
0108E:  MOVF   x37,F
01090:  BNZ   1094
01092:  BRA    10C4
.................... 		if (!i) name[j++] = '.'; 
01094:  MOVF   x35,F
01096:  BNZ   10AC
01098:  MOVF   x36,W
0109A:  INCF   x36,F
0109C:  CLRF   03
0109E:  ADDWF  x33,W
010A0:  MOVWF  FE9
010A2:  MOVF   x34,W
010A4:  ADDWFC 03,W
010A6:  MOVWF  FEA
010A8:  MOVLW  2E
010AA:  MOVWF  FEF
.................... 		name[j++] = c; 
010AC:  MOVF   x36,W
010AE:  INCF   x36,F
010B0:  CLRF   03
010B2:  ADDWF  x33,W
010B4:  MOVWF  FE9
010B6:  MOVF   x34,W
010B8:  ADDWFC 03,W
010BA:  MOVWF  FEA
010BC:  MOVFF  B37,FEF
.................... 	} 
010C0:  INCF   x35,F
010C2:  BRA    1066
.................... 	name[j++] = 0; 
010C4:  MOVF   x36,W
010C6:  INCF   x36,F
010C8:  CLRF   03
010CA:  ADDWF  x33,W
010CC:  MOVWF  FE9
010CE:  MOVF   x34,W
010D0:  ADDWFC 03,W
010D2:  MOVWF  FEA
010D4:  CLRF   FEF
.................... } 
010D6:  MOVLB  0
010D8:  GOTO   16F6 (RETURN)
....................  
.................... void GetDOSName(DIR *pDir, char *fname) 
.................... { 
.................... 	char i,j,leng,c,toext; 
....................  
.................... 	toext = FALSE; 
*
02624:  MOVLB  B
02626:  CLRF   x17
.................... 	j = 0; 
02628:  CLRF   x14
.................... 	leng = strlen(fname); 
0262A:  MOVFF  B12,B19
0262E:  MOVFF  B11,B18
02632:  MOVLB  0
02634:  CALL   0FAA
02638:  MOVFF  01,B15
.................... 	for (i=0;i<8;i++) 
0263C:  MOVLB  B
0263E:  CLRF   x13
02640:  MOVF   x13,W
02642:  SUBLW  07
02644:  BNC   265C
.................... 		pDir->sName[i] = ' '; 
02646:  CLRF   03
02648:  MOVF   x13,W
0264A:  ADDWF  x0F,W
0264C:  MOVWF  FE9
0264E:  MOVF   x10,W
02650:  ADDWFC 03,W
02652:  MOVWF  FEA
02654:  MOVLW  20
02656:  MOVWF  FEF
02658:  INCF   x13,F
0265A:  BRA    2640
.................... 	for (i=0;i<3;i++) 
0265C:  CLRF   x13
0265E:  MOVF   x13,W
02660:  SUBLW  02
02662:  BNC   2684
.................... 		pDir->sExt[i] = ' '; 
02664:  CLRF   03
02666:  MOVF   x13,W
02668:  ADDLW  08
0266A:  MOVWF  01
0266C:  MOVLW  00
0266E:  ADDWFC 03,F
02670:  MOVF   01,W
02672:  ADDWF  x0F,W
02674:  MOVWF  FE9
02676:  MOVF   x10,W
02678:  ADDWFC 03,W
0267A:  MOVWF  FEA
0267C:  MOVLW  20
0267E:  MOVWF  FEF
02680:  INCF   x13,F
02682:  BRA    265E
.................... 	for (i=0;i<leng;i++) { 
02684:  CLRF   x13
02686:  MOVF   x15,W
02688:  SUBWF  x13,W
0268A:  BC    26FA
.................... 		c = fname[i]; 
0268C:  CLRF   03
0268E:  MOVF   x13,W
02690:  ADDWF  x11,W
02692:  MOVWF  FE9
02694:  MOVF   x12,W
02696:  ADDWFC 03,W
02698:  MOVWF  FEA
0269A:  MOVFF  FEF,B16
.................... 		c = toupper(c); 
0269E:  MOVF   x16,W
026A0:  SUBLW  60
026A2:  BC    26B0
026A4:  MOVF   x16,W
026A6:  SUBLW  7A
026A8:  BNC   26B0
026AA:  MOVF   x16,W
026AC:  ANDLW  DF
026AE:  BRA    26B2
026B0:  MOVF   x16,W
026B2:  MOVWF  x16
.................... 		if (c == '.') { 
026B4:  MOVF   x16,W
026B6:  SUBLW  2E
026B8:  BNZ   26C0
.................... 			toext = TRUE; 
026BA:  MOVLW  01
026BC:  MOVWF  x17
.................... 			continue; 
026BE:  BRA    26F6
.................... 		} 
.................... 		if (toext) pDir->sExt[j++] = c; 
026C0:  MOVF   x17,F
026C2:  BZ    26E4
026C4:  MOVF   x14,W
026C6:  INCF   x14,F
026C8:  CLRF   03
026CA:  ADDLW  08
026CC:  MOVWF  01
026CE:  MOVLW  00
026D0:  ADDWFC 03,F
026D2:  MOVF   01,W
026D4:  ADDWF  x0F,W
026D6:  MOVWF  FE9
026D8:  MOVF   x10,W
026DA:  ADDWFC 03,W
026DC:  MOVWF  FEA
026DE:  MOVFF  B16,FEF
.................... 		else pDir->sName[i] = c; 
026E2:  BRA    26F6
026E4:  CLRF   03
026E6:  MOVF   x13,W
026E8:  ADDWF  x0F,W
026EA:  MOVWF  FE9
026EC:  MOVF   x10,W
026EE:  ADDWFC 03,W
026F0:  MOVWF  FEA
026F2:  MOVFF  B16,FEF
.................... 	} 
026F6:  INCF   x13,F
026F8:  BRA    2686
.................... } 
026FA:  MOVLB  0
026FC:  GOTO   2B94 (RETURN)
....................  
.................... //Read the first dir sector 
.................... void ReadRootDirectory(HANDLE hFile) 
.................... { 
.................... 	int32 actsector; 
....................  
.................... 	TRACE0("\r\nReadRootDirectory()");	 
....................  
.................... 	if (hFile > (MAXFILES-1))  
*
00D9A:  MOVLB  B
00D9C:  MOVF   x09,F
00D9E:  BZ    0DA2
.................... 		return; 
00DA0:  BRA    0FA4
.................... 		 
.................... 	actsector = gFAT32Vars.gStartSector + DiskInfo.NumFATs*gFAT32Vars.nFatSize+DiskInfo.RsvdSecCnt; 
00DA2:  CLRF   x3C
00DA4:  CLRF   x3B
00DA6:  CLRF   x3A
00DA8:  MOVFF  250,B39
00DAC:  MOVFF  23E,B40
00DB0:  MOVFF  23D,B3F
00DB4:  MOVFF  23C,B3E
00DB8:  MOVFF  23B,B3D
00DBC:  MOVLB  0
00DBE:  RCALL  08F4
00DC0:  MOVF   00,W
00DC2:  MOVLB  2
00DC4:  ADDWF  x23,W
00DC6:  MOVLB  B
00DC8:  MOVWF  x0E
00DCA:  MOVF   01,W
00DCC:  MOVLB  2
00DCE:  ADDWFC x24,W
00DD0:  MOVLB  B
00DD2:  MOVWF  x0F
00DD4:  MOVF   02,W
00DD6:  MOVLB  2
00DD8:  ADDWFC x25,W
00DDA:  MOVLB  B
00DDC:  MOVWF  x10
00DDE:  MOVF   03,W
00DE0:  MOVLB  2
00DE2:  ADDWFC x26,W
00DE4:  MOVLB  B
00DE6:  MOVWF  x11
00DE8:  MOVLB  2
00DEA:  MOVF   x4E,W
00DEC:  MOVLB  B
00DEE:  ADDWF  x0E,W
00DF0:  MOVWF  x0A
00DF2:  MOVLB  2
00DF4:  MOVF   x4F,W
00DF6:  MOVLB  B
00DF8:  ADDWFC x0F,W
00DFA:  MOVWF  x0B
00DFC:  MOVLW  00
00DFE:  ADDWFC x10,W
00E00:  MOVWF  x0C
00E02:  MOVLW  00
00E04:  ADDWFC x11,W
00E06:  MOVWF  x0D
.................... 	 
.................... 	ReadSector(actsector,gFiles[hFile].IOpuffer); 
00E08:  CLRF   x62
00E0A:  MOVFF  B09,B61
00E0E:  MOVLW  02
00E10:  MOVWF  x64
00E12:  MOVLW  33
00E14:  MOVWF  x63
00E16:  MOVLB  0
00E18:  CALL   039E
00E1C:  MOVFF  02,B0F
00E20:  MOVFF  01,B0E
00E24:  MOVLW  70
00E26:  MOVLB  B
00E28:  ADDWF  01,W
00E2A:  MOVWF  01
00E2C:  MOVLW  02
00E2E:  ADDWFC 02,W
00E30:  MOVWF  03
00E32:  MOVFF  01,B10
00E36:  MOVWF  x11
00E38:  MOVFF  B0D,B47
00E3C:  MOVFF  B0C,B46
00E40:  MOVFF  B0B,B45
00E44:  MOVFF  B0A,B44
00E48:  MOVWF  x49
00E4A:  MOVFF  01,B48
00E4E:  MOVLB  0
00E50:  RCALL  07CA
.................... 	 
.................... 	gFAT32Vars.gDirEntrySector = actsector; 
00E52:  MOVFF  B0D,230
00E56:  MOVFF  B0C,22F
00E5A:  MOVFF  B0B,22E
00E5E:  MOVFF  B0A,22D
.................... 	gFiles[hFile].dirSector = actsector; 
00E62:  MOVLB  B
00E64:  CLRF   x62
00E66:  MOVFF  B09,B61
00E6A:  MOVLW  02
00E6C:  MOVWF  x64
00E6E:  MOVLW  33
00E70:  MOVWF  x63
00E72:  MOVLB  0
00E74:  CALL   039E
00E78:  MOVFF  01,B0E
00E7C:  MOVLW  2B
00E7E:  MOVLB  B
00E80:  ADDWF  01,W
00E82:  MOVWF  01
00E84:  MOVLW  02
00E86:  ADDWFC 02,W
00E88:  MOVWF  03
00E8A:  MOVF   01,W
00E8C:  ADDLW  70
00E8E:  MOVWF  FE9
00E90:  MOVLW  02
00E92:  ADDWFC 03,W
00E94:  MOVWF  FEA
00E96:  MOVFF  B0A,FEF
00E9A:  MOVFF  B0B,FEC
00E9E:  MOVFF  B0C,FEC
00EA2:  MOVFF  B0D,FEC
.................... 	gFiles[hFile].dirIdx = 0; 
00EA6:  CLRF   x62
00EA8:  MOVFF  B09,B61
00EAC:  MOVLW  02
00EAE:  MOVWF  x64
00EB0:  MOVLW  33
00EB2:  MOVWF  x63
00EB4:  MOVLB  0
00EB6:  CALL   039E
00EBA:  MOVFF  01,B0E
00EBE:  MOVLW  2F
00EC0:  MOVLB  B
00EC2:  ADDWF  01,W
00EC4:  MOVWF  01
00EC6:  MOVLW  02
00EC8:  ADDWFC 02,W
00ECA:  MOVWF  03
00ECC:  MOVF   01,W
00ECE:  ADDLW  70
00ED0:  MOVWF  FE9
00ED2:  MOVLW  02
00ED4:  ADDWFC 03,W
00ED6:  MOVWF  FEA
00ED8:  CLRF   FEC
00EDA:  MOVF   FED,F
00EDC:  CLRF   FEF
.................... 	memcpy(&(gFiles[hFile].DirEntry),gFiles[hFile].IOpuffer,32); 
00EDE:  CLRF   x62
00EE0:  MOVFF  B09,B61
00EE4:  MOVLW  02
00EE6:  MOVWF  x64
00EE8:  MOVLW  33
00EEA:  MOVWF  x63
00EEC:  MOVLB  0
00EEE:  CALL   039E
00EF2:  MOVFF  02,B0F
00EF6:  MOVFF  01,B0E
00EFA:  MOVLB  B
00EFC:  MOVFF  01,01
00F00:  MOVLW  02
00F02:  ADDWF  02,W
00F04:  MOVWF  03
00F06:  MOVF   01,W
00F08:  ADDLW  70
00F0A:  MOVWF  01
00F0C:  MOVLW  02
00F0E:  ADDWFC 03,F
00F10:  MOVFF  01,B10
00F14:  MOVFF  03,B11
00F18:  CLRF   x62
00F1A:  MOVFF  B09,B61
00F1E:  MOVLW  02
00F20:  MOVWF  x64
00F22:  MOVLW  33
00F24:  MOVWF  x63
00F26:  MOVLB  0
00F28:  CALL   039E
00F2C:  MOVFF  02,B13
00F30:  MOVFF  01,B12
00F34:  MOVLW  70
00F36:  MOVLB  B
00F38:  ADDWF  01,W
00F3A:  MOVWF  01
00F3C:  MOVLW  02
00F3E:  ADDWFC 02,W
00F40:  MOVWF  03
00F42:  MOVFF  01,B14
00F46:  MOVWF  x15
00F48:  MOVFF  B11,FEA
00F4C:  MOVFF  B10,FE9
00F50:  MOVWF  FE2
00F52:  MOVFF  01,FE1
00F56:  MOVLW  20
00F58:  MOVWF  01
00F5A:  MOVFF  FE6,FEE
00F5E:  DECFSZ 01,F
00F60:  BRA    0F5A
.................... 	gFiles[hFile].CurrentCluster = DiskInfo.RootClus; 
00F62:  CLRF   x62
00F64:  MOVFF  B09,B61
00F68:  MOVLW  02
00F6A:  MOVWF  x64
00F6C:  MOVLW  33
00F6E:  MOVWF  x63
00F70:  MOVLB  0
00F72:  CALL   039E
00F76:  MOVFF  01,B0E
00F7A:  MOVLW  20
00F7C:  MOVLB  B
00F7E:  ADDWF  01,W
00F80:  MOVWF  01
00F82:  MOVLW  02
00F84:  ADDWFC 02,W
00F86:  MOVWF  03
00F88:  MOVF   01,W
00F8A:  ADDLW  70
00F8C:  MOVWF  FE9
00F8E:  MOVLW  02
00F90:  ADDWFC 03,W
00F92:  MOVWF  FEA
00F94:  MOVFF  26C,FEF
00F98:  MOVFF  26D,FEC
00F9C:  MOVFF  26E,FEC
00FA0:  MOVFF  26F,FEC
.................... } 
00FA4:  MOVLB  0
00FA6:  GOTO   1F86 (RETURN)
....................  
.................... //Always call TryFile before calling FindDirEntry to allow search from root dir sector 
.................... char FindDirEntry(char *fname,HANDLE hFile) 
.................... { 
.................... 	DIR *pDir; 
.................... 	int16 i; 
.................... 	char filename[16]; 
.................... 	int32 nextcluster,actsector; 
.................... 	int nSecInClus; 
.................... 	int bDone; 
....................  
....................  
.................... 	TRACE2("\r\nFindDirEntry(%s,%d)", fname, hFile);	 
....................  
.................... 	if (hFile > (MAXFILES-1))  
*
01588:  MOVLB  B
0158A:  MOVF   x12,F
0158C:  BZ    1594
.................... 		return FALSE; 
0158E:  MOVLW  00
01590:  MOVWF  01
01592:  BRA    1C5E
....................  
.................... 	bDone = false; 
01594:  CLRF   x30
.................... 	nSecInClus = 0; 
01596:  CLRF   x2F
.................... 	gFAT32Vars.gFirstEmptyDirEntry = 0xFFFF; 
01598:  MOVLW  FF
0159A:  MOVLB  2
0159C:  MOVWF  x32
0159E:  MOVWF  x31
.................... 	gFAT32Vars.gFirstDirEntryCluster = 0x0FFFFFFF; 
015A0:  MOVLW  0F
015A2:  MOVWF  x36
015A4:  MOVLW  FF
015A6:  MOVWF  x35
015A8:  MOVWF  x34
015AA:  MOVWF  x33
.................... 	nextcluster = gFiles[hFile].CurrentCluster; 
015AC:  MOVLB  B
015AE:  CLRF   x62
015B0:  MOVFF  B12,B61
015B4:  MOVLW  02
015B6:  MOVWF  x64
015B8:  MOVLW  33
015BA:  MOVWF  x63
015BC:  MOVLB  0
015BE:  CALL   039E
015C2:  MOVFF  02,B32
015C6:  MOVFF  01,B31
015CA:  MOVLW  20
015CC:  MOVLB  B
015CE:  ADDWF  01,W
015D0:  MOVWF  01
015D2:  MOVLW  02
015D4:  ADDWFC 02,W
015D6:  MOVWF  03
015D8:  MOVF   01,W
015DA:  ADDLW  70
015DC:  MOVWF  FE9
015DE:  MOVLW  02
015E0:  ADDWFC 03,W
015E2:  MOVWF  FEA
015E4:  MOVFF  FEF,00
015E8:  MOVFF  FEC,01
015EC:  MOVFF  FEC,02
015F0:  MOVFF  FEC,03
015F4:  MOVFF  03,B2A
015F8:  MOVFF  02,B29
015FC:  MOVFF  01,B28
01600:  MOVFF  00,B27
.................... 	do { 
.................... 		pDir = (DIR*)(gFiles[hFile].IOpuffer); 
01604:  CLRF   x62
01606:  MOVFF  B12,B61
0160A:  MOVLW  02
0160C:  MOVWF  x64
0160E:  MOVLW  33
01610:  MOVWF  x63
01612:  MOVLB  0
01614:  CALL   039E
01618:  MOVFF  01,B31
0161C:  MOVLW  70
0161E:  MOVLB  B
01620:  ADDWF  01,W
01622:  MOVWF  01
01624:  MOVLW  02
01626:  ADDWFC 02,W
01628:  MOVFF  01,B13
0162C:  MOVWF  x14
.................... 		for (i=0;i<16;i++)  
0162E:  CLRF   x16
01630:  CLRF   x15
01632:  MOVF   x16,F
01634:  BTFSS  FD8.2
01636:  BRA    17C4
01638:  MOVF   x15,W
0163A:  SUBLW  0F
0163C:  BTFSS  FD8.0
0163E:  BRA    17C4
.................... 		{ 
.................... 			if ((pDir->sName[0] == 0xE5 || pDir->sName[0] == 0) && gFAT32Vars.gFirstEmptyDirEntry == 0xFFFF)  // store first free 
01640:  MOVFF  B13,FE9
01644:  MOVFF  B14,FEA
01648:  MOVF   FEF,W
0164A:  SUBLW  E5
0164C:  BZ    165A
0164E:  MOVFF  B13,FE9
01652:  MOVFF  B14,FEA
01656:  MOVF   FEF,F
01658:  BNZ   16D0
0165A:  MOVLB  2
0165C:  INCFSZ x31,W
0165E:  BRA    1662
01660:  BRA    1666
01662:  MOVLB  B
01664:  BRA    16D0
01666:  INCFSZ x32,W
01668:  BRA    166C
0166A:  BRA    1670
0166C:  MOVLB  B
0166E:  BRA    16D0
.................... 			{ 
.................... 				gFAT32Vars.gFirstEmptyDirEntry = i; 
01670:  MOVFF  B16,232
01674:  MOVFF  B15,231
.................... 				gFAT32Vars.gFirstDirEntryCluster = gFiles[hFile].CurrentCluster; 
01678:  MOVLB  B
0167A:  CLRF   x62
0167C:  MOVFF  B12,B61
01680:  MOVLW  02
01682:  MOVWF  x64
01684:  MOVLW  33
01686:  MOVWF  x63
01688:  MOVLB  0
0168A:  CALL   039E
0168E:  MOVFF  02,B32
01692:  MOVFF  01,B31
01696:  MOVLW  20
01698:  MOVLB  B
0169A:  ADDWF  01,W
0169C:  MOVWF  01
0169E:  MOVLW  02
016A0:  ADDWFC 02,W
016A2:  MOVWF  03
016A4:  MOVF   01,W
016A6:  ADDLW  70
016A8:  MOVWF  FE9
016AA:  MOVLW  02
016AC:  ADDWFC 03,W
016AE:  MOVWF  FEA
016B0:  MOVFF  FEF,00
016B4:  MOVFF  FEC,01
016B8:  MOVFF  FEC,02
016BC:  MOVFF  FEC,03
016C0:  MOVFF  03,236
016C4:  MOVFF  02,235
016C8:  MOVFF  01,234
016CC:  MOVFF  00,233
.................... 			} 
....................  
.................... 			if (pDir->sName[0] == 0) 	//Searched all exist dir entries 
016D0:  MOVFF  B13,FE9
016D4:  MOVFF  B14,FEA
016D8:  MOVF   FEF,F
016DA:  BNZ   16E2
.................... 				return FALSE; 
016DC:  MOVLW  00
016DE:  MOVWF  01
016E0:  BRA    1C5E
....................  
.................... 			ConvertFilename(pDir,filename); 
016E2:  MOVFF  B14,B32
016E6:  MOVFF  B13,B31
016EA:  MOVLW  0B
016EC:  MOVWF  x34
016EE:  MOVLW  17
016F0:  MOVWF  x33
016F2:  MOVLB  0
016F4:  BRA    101C
....................  
.................... 			if (!strcmp(filename,fname)) 	//Found matching dir entry 
016F6:  MOVLW  0B
016F8:  MOVLB  B
016FA:  MOVWF  x32
016FC:  MOVLW  17
016FE:  MOVWF  x31
01700:  MOVFF  B11,B34
01704:  MOVFF  B10,B33
01708:  MOVLB  0
0170A:  BRA    10DC
0170C:  MOVF   01,F
0170E:  BNZ   17B2
.................... 			{ 
.................... 				memcpy(&(gFiles[hFile].DirEntry),pDir,32); 
01710:  MOVLB  B
01712:  CLRF   x62
01714:  MOVFF  B12,B61
01718:  MOVLW  02
0171A:  MOVWF  x64
0171C:  MOVLW  33
0171E:  MOVWF  x63
01720:  MOVLB  0
01722:  CALL   039E
01726:  MOVFF  02,B32
0172A:  MOVFF  01,B31
0172E:  MOVLB  B
01730:  MOVFF  01,01
01734:  MOVLW  02
01736:  ADDWF  02,W
01738:  MOVWF  03
0173A:  MOVF   01,W
0173C:  ADDLW  70
0173E:  MOVWF  01
01740:  MOVLW  02
01742:  ADDWFC 03,F
01744:  MOVFF  01,B33
01748:  MOVFF  03,B34
0174C:  MOVFF  03,FEA
01750:  MOVFF  01,FE9
01754:  MOVFF  B14,FE2
01758:  MOVFF  B13,FE1
0175C:  MOVLW  20
0175E:  MOVWF  01
01760:  MOVFF  FE6,FEE
01764:  DECFSZ 01,F
01766:  BRA    1760
.................... 				gFiles[hFile].dirIdx = i; 
01768:  CLRF   x62
0176A:  MOVFF  B12,B61
0176E:  MOVLW  02
01770:  MOVWF  x64
01772:  MOVLW  33
01774:  MOVWF  x63
01776:  MOVLB  0
01778:  CALL   039E
0177C:  MOVFF  01,B31
01780:  MOVLW  2F
01782:  MOVLB  B
01784:  ADDWF  01,W
01786:  MOVWF  01
01788:  MOVLW  02
0178A:  ADDWFC 02,W
0178C:  MOVWF  03
0178E:  MOVF   01,W
01790:  ADDLW  70
01792:  MOVWF  FE9
01794:  MOVLW  02
01796:  ADDWFC 03,W
01798:  MOVWF  FEA
0179A:  MOVFF  B16,FEC
0179E:  MOVF   FED,F
017A0:  MOVFF  B15,FEF
.................... 				gFAT32Vars.gDirEntryIdx = i; 
017A4:  MOVFF  B16,22C
017A8:  MOVFF  B15,22B
.................... 				return TRUE; 
017AC:  MOVLW  01
017AE:  MOVWF  01
017B0:  BRA    1C5E
.................... 			} 
.................... 			pDir++; 
017B2:  MOVLW  20
017B4:  MOVLB  B
017B6:  ADDWF  x13,F
017B8:  BTFSC  FD8.0
017BA:  INCF   x14,F
.................... 		} 
017BC:  INCF   x15,F
017BE:  BTFSC  FD8.2
017C0:  INCF   x16,F
017C2:  BRA    1632
.................... 		 
.................... 		if(gFATType == FAT32)	//FAT32 DIR sector are chained 
017C4:  MOVLB  4
017C6:  MOVF   xBB,W
017C8:  SUBLW  03
017CA:  BTFSS  FD8.2
017CC:  BRA    1B0E
.................... 		{ 
.................... 			//Searched all sector in cluster? 
.................... 			if(++nSecInClus < DiskInfo.SecPerClus) 
017CE:  MOVLB  B
017D0:  INCF   x2F,F
017D2:  MOVLB  2
017D4:  MOVF   x4D,W
017D6:  MOVLB  B
017D8:  SUBWF  x2F,W
017DA:  BTFSC  FD8.0
017DC:  BRA    1936
.................... 			{ 
.................... 				actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector + nSecInClus; 
017DE:  CLRF   x62
017E0:  MOVFF  B12,B61
017E4:  MOVLW  02
017E6:  MOVWF  x64
017E8:  MOVLW  33
017EA:  MOVWF  x63
017EC:  MOVLB  0
017EE:  CALL   039E
017F2:  MOVFF  02,B32
017F6:  MOVFF  01,B31
017FA:  MOVLW  20
017FC:  MOVLB  B
017FE:  ADDWF  01,W
01800:  MOVWF  01
01802:  MOVLW  02
01804:  ADDWFC 02,W
01806:  MOVWF  03
01808:  MOVF   01,W
0180A:  ADDLW  70
0180C:  MOVWF  FE9
0180E:  MOVLW  02
01810:  ADDWFC 03,W
01812:  MOVWF  FEA
01814:  MOVFF  FEF,B33
01818:  MOVFF  FEC,B34
0181C:  MOVFF  FEC,B35
01820:  MOVFF  FEC,B36
01824:  MOVFF  FEA,B38
01828:  MOVFF  FE9,B37
0182C:  MOVFF  B36,B3C
01830:  MOVFF  B35,B3B
01834:  MOVFF  B34,B3A
01838:  MOVFF  B33,B39
0183C:  CLRF   x40
0183E:  CLRF   x3F
01840:  CLRF   x3E
01842:  MOVFF  24D,B3D
01846:  MOVLB  0
01848:  CALL   08F4
0184C:  MOVFF  B38,FEA
01850:  MOVFF  B37,FE9
01854:  MOVLB  2
01856:  MOVF   x27,W
01858:  MOVLB  B
0185A:  ADDWF  00,W
0185C:  MOVWF  x39
0185E:  MOVLB  2
01860:  MOVF   x28,W
01862:  MOVLB  B
01864:  ADDWFC 01,W
01866:  MOVWF  x3A
01868:  MOVLB  2
0186A:  MOVF   x29,W
0186C:  MOVLB  B
0186E:  ADDWFC 02,W
01870:  MOVWF  x3B
01872:  MOVLB  2
01874:  MOVF   x2A,W
01876:  MOVLB  B
01878:  ADDWFC 03,W
0187A:  MOVWF  x3C
0187C:  MOVF   x2F,W
0187E:  ADDWF  x39,W
01880:  MOVWF  x2B
01882:  MOVLW  00
01884:  ADDWFC x3A,W
01886:  MOVWF  x2C
01888:  MOVLW  00
0188A:  ADDWFC x3B,W
0188C:  MOVWF  x2D
0188E:  MOVLW  00
01890:  ADDWFC x3C,W
01892:  MOVWF  x2E
.................... 				ReadSector(actsector,gFiles[hFile].IOpuffer); 
01894:  CLRF   x62
01896:  MOVFF  B12,B61
0189A:  MOVLW  02
0189C:  MOVWF  x64
0189E:  MOVLW  33
018A0:  MOVWF  x63
018A2:  MOVLB  0
018A4:  CALL   039E
018A8:  MOVFF  02,B32
018AC:  MOVFF  01,B31
018B0:  MOVLW  70
018B2:  MOVLB  B
018B4:  ADDWF  01,W
018B6:  MOVWF  01
018B8:  MOVLW  02
018BA:  ADDWFC 02,W
018BC:  MOVWF  03
018BE:  MOVFF  01,B33
018C2:  MOVWF  x34
018C4:  MOVFF  B2E,B47
018C8:  MOVFF  B2D,B46
018CC:  MOVFF  B2C,B45
018D0:  MOVFF  B2B,B44
018D4:  MOVWF  x49
018D6:  MOVFF  01,B48
018DA:  MOVLB  0
018DC:  CALL   07CA
.................... 				gFAT32Vars.gDirEntrySector = actsector; 
018E0:  MOVFF  B2E,230
018E4:  MOVFF  B2D,22F
018E8:  MOVFF  B2C,22E
018EC:  MOVFF  B2B,22D
.................... 				gFiles[hFile].dirSector = actsector; 
018F0:  MOVLB  B
018F2:  CLRF   x62
018F4:  MOVFF  B12,B61
018F8:  MOVLW  02
018FA:  MOVWF  x64
018FC:  MOVLW  33
018FE:  MOVWF  x63
01900:  MOVLB  0
01902:  CALL   039E
01906:  MOVFF  01,B31
0190A:  MOVLW  2B
0190C:  MOVLB  B
0190E:  ADDWF  01,W
01910:  MOVWF  01
01912:  MOVLW  02
01914:  ADDWFC 02,W
01916:  MOVWF  03
01918:  MOVF   01,W
0191A:  ADDLW  70
0191C:  MOVWF  FE9
0191E:  MOVLW  02
01920:  ADDWFC 03,W
01922:  MOVWF  FEA
01924:  MOVFF  B2B,FEF
01928:  MOVFF  B2C,FEC
0192C:  MOVFF  B2D,FEC
01930:  MOVFF  B2E,FEC
.................... 			} 
.................... 			else	//Get next cluster 
01934:  BRA    1B0A
.................... 			{ 
.................... 				nSecInClus = 0; 
01936:  CLRF   x2F
.................... 				nextcluster = GetNextCluster(gFiles[hFile].CurrentCluster); 
01938:  CLRF   x62
0193A:  MOVFF  B12,B61
0193E:  MOVLW  02
01940:  MOVWF  x64
01942:  MOVLW  33
01944:  MOVWF  x63
01946:  MOVLB  0
01948:  CALL   039E
0194C:  MOVFF  02,B32
01950:  MOVFF  01,B31
01954:  MOVLW  20
01956:  MOVLB  B
01958:  ADDWF  01,W
0195A:  MOVWF  01
0195C:  MOVLW  02
0195E:  ADDWFC 02,W
01960:  MOVWF  03
01962:  MOVF   01,W
01964:  ADDLW  70
01966:  MOVWF  FE9
01968:  MOVLW  02
0196A:  ADDWFC 03,W
0196C:  MOVWF  FEA
0196E:  MOVFF  FEF,B33
01972:  MOVFF  FEC,B34
01976:  MOVFF  FEC,B35
0197A:  MOVFF  FEC,B36
0197E:  MOVFF  B36,B3A
01982:  MOVFF  B35,B39
01986:  MOVFF  B34,B38
0198A:  MOVFF  B33,B37
0198E:  MOVLB  0
01990:  RCALL  1316
01992:  MOVFF  03,B2A
01996:  MOVFF  02,B29
0199A:  MOVFF  01,B28
0199E:  MOVFF  00,B27
.................... 				gFAT32Vars.gFirstDirEntryCluster = nextcluster; 
019A2:  MOVFF  B2A,236
019A6:  MOVFF  B29,235
019AA:  MOVFF  B28,234
019AE:  MOVFF  B27,233
.................... 				if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
019B2:  MOVLB  B
019B4:  INCFSZ x27,W
019B6:  BRA    19C8
019B8:  INCFSZ x28,W
019BA:  BRA    19C8
019BC:  INCFSZ x29,W
019BE:  BRA    19C8
019C0:  MOVF   x2A,W
019C2:  SUBLW  0F
019C4:  BTFSC  FD8.2
019C6:  BRA    1B06
019C8:  MOVF   x27,F
019CA:  BNZ   19DA
019CC:  MOVF   x28,F
019CE:  BNZ   19DA
019D0:  MOVF   x29,F
019D2:  BNZ   19DA
019D4:  MOVF   x2A,F
019D6:  BTFSC  FD8.2
019D8:  BRA    1B06
.................... 				{ 
.................... 					actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
019DA:  MOVFF  B2A,B3C
019DE:  MOVFF  B29,B3B
019E2:  MOVFF  B28,B3A
019E6:  MOVFF  B27,B39
019EA:  CLRF   x40
019EC:  CLRF   x3F
019EE:  CLRF   x3E
019F0:  MOVFF  24D,B3D
019F4:  MOVLB  0
019F6:  CALL   08F4
019FA:  MOVLB  2
019FC:  MOVF   x27,W
019FE:  MOVLB  B
01A00:  ADDWF  00,W
01A02:  MOVWF  x2B
01A04:  MOVLB  2
01A06:  MOVF   x28,W
01A08:  MOVLB  B
01A0A:  ADDWFC 01,W
01A0C:  MOVWF  x2C
01A0E:  MOVLB  2
01A10:  MOVF   x29,W
01A12:  MOVLB  B
01A14:  ADDWFC 02,W
01A16:  MOVWF  x2D
01A18:  MOVLB  2
01A1A:  MOVF   x2A,W
01A1C:  MOVLB  B
01A1E:  ADDWFC 03,W
01A20:  MOVWF  x2E
.................... 					ReadSector(actsector,gFiles[hFile].IOpuffer); 
01A22:  CLRF   x62
01A24:  MOVFF  B12,B61
01A28:  MOVLW  02
01A2A:  MOVWF  x64
01A2C:  MOVLW  33
01A2E:  MOVWF  x63
01A30:  MOVLB  0
01A32:  CALL   039E
01A36:  MOVFF  02,B32
01A3A:  MOVFF  01,B31
01A3E:  MOVLW  70
01A40:  MOVLB  B
01A42:  ADDWF  01,W
01A44:  MOVWF  01
01A46:  MOVLW  02
01A48:  ADDWFC 02,W
01A4A:  MOVWF  03
01A4C:  MOVFF  01,B33
01A50:  MOVWF  x34
01A52:  MOVFF  B2E,B47
01A56:  MOVFF  B2D,B46
01A5A:  MOVFF  B2C,B45
01A5E:  MOVFF  B2B,B44
01A62:  MOVWF  x49
01A64:  MOVFF  01,B48
01A68:  MOVLB  0
01A6A:  CALL   07CA
.................... 					gFAT32Vars.gDirEntrySector = actsector; 
01A6E:  MOVFF  B2E,230
01A72:  MOVFF  B2D,22F
01A76:  MOVFF  B2C,22E
01A7A:  MOVFF  B2B,22D
.................... 					gFiles[hFile].dirSector = actsector; 
01A7E:  MOVLB  B
01A80:  CLRF   x62
01A82:  MOVFF  B12,B61
01A86:  MOVLW  02
01A88:  MOVWF  x64
01A8A:  MOVLW  33
01A8C:  MOVWF  x63
01A8E:  MOVLB  0
01A90:  CALL   039E
01A94:  MOVFF  01,B31
01A98:  MOVLW  2B
01A9A:  MOVLB  B
01A9C:  ADDWF  01,W
01A9E:  MOVWF  01
01AA0:  MOVLW  02
01AA2:  ADDWFC 02,W
01AA4:  MOVWF  03
01AA6:  MOVF   01,W
01AA8:  ADDLW  70
01AAA:  MOVWF  FE9
01AAC:  MOVLW  02
01AAE:  ADDWFC 03,W
01AB0:  MOVWF  FEA
01AB2:  MOVFF  B2B,FEF
01AB6:  MOVFF  B2C,FEC
01ABA:  MOVFF  B2D,FEC
01ABE:  MOVFF  B2E,FEC
.................... 					gFiles[hFile].CurrentCluster = nextcluster; 
01AC2:  CLRF   x62
01AC4:  MOVFF  B12,B61
01AC8:  MOVLW  02
01ACA:  MOVWF  x64
01ACC:  MOVLW  33
01ACE:  MOVWF  x63
01AD0:  MOVLB  0
01AD2:  CALL   039E
01AD6:  MOVFF  01,B31
01ADA:  MOVLW  20
01ADC:  MOVLB  B
01ADE:  ADDWF  01,W
01AE0:  MOVWF  01
01AE2:  MOVLW  02
01AE4:  ADDWFC 02,W
01AE6:  MOVWF  03
01AE8:  MOVF   01,W
01AEA:  ADDLW  70
01AEC:  MOVWF  FE9
01AEE:  MOVLW  02
01AF0:  ADDWFC 03,W
01AF2:  MOVWF  FEA
01AF4:  MOVFF  B27,FEF
01AF8:  MOVFF  B28,FEC
01AFC:  MOVFF  B29,FEC
01B00:  MOVFF  B2A,FEC
.................... 				} 
.................... 				else  
01B04:  BRA    1B0A
.................... 					bDone = true; 
01B06:  MOVLW  01
01B08:  MOVWF  x30
.................... 			} 
.................... 			//bDone = !(nSecInClus < DiskInfo.SecPerClus || (nextcluster != 0x0FFFFFFF && nextcluster != 0)); 
.................... 		} 
.................... 		else	//FAT16 
01B0A:  BRA    1C54
01B0C:  MOVLB  4
.................... 		{ 
.................... 			 
.................... 			if(++nSecInClus < gFAT32Vars.nRootDirSectors) 
01B0E:  MOVLB  B
01B10:  INCF   x2F,F
01B12:  MOVLB  2
01B14:  MOVF   x3A,F
01B16:  BNZ   1B2C
01B18:  MOVF   x39,F
01B1A:  BNZ   1B2C
01B1C:  MOVF   x38,F
01B1E:  BNZ   1B2C
01B20:  MOVF   x37,W
01B22:  MOVLB  B
01B24:  SUBWF  x2F,W
01B26:  BTFSC  FD8.0
01B28:  BRA    1C50
01B2A:  MOVLB  2
.................... 			{ 
.................... 				actsector = gFAT32Vars.gStartSector + DiskInfo.NumFATs*gFAT32Vars.nFatSize+DiskInfo.RsvdSecCnt + nSecInClus; 
01B2C:  MOVLB  B
01B2E:  CLRF   x3C
01B30:  CLRF   x3B
01B32:  CLRF   x3A
01B34:  MOVFF  250,B39
01B38:  MOVFF  23E,B40
01B3C:  MOVFF  23D,B3F
01B40:  MOVFF  23C,B3E
01B44:  MOVFF  23B,B3D
01B48:  MOVLB  0
01B4A:  CALL   08F4
01B4E:  MOVF   00,W
01B50:  MOVLB  2
01B52:  ADDWF  x23,W
01B54:  MOVLB  B
01B56:  MOVWF  x31
01B58:  MOVF   01,W
01B5A:  MOVLB  2
01B5C:  ADDWFC x24,W
01B5E:  MOVLB  B
01B60:  MOVWF  x32
01B62:  MOVF   02,W
01B64:  MOVLB  2
01B66:  ADDWFC x25,W
01B68:  MOVLB  B
01B6A:  MOVWF  x33
01B6C:  MOVF   03,W
01B6E:  MOVLB  2
01B70:  ADDWFC x26,W
01B72:  MOVLB  B
01B74:  MOVWF  x34
01B76:  MOVLB  2
01B78:  MOVF   x4E,W
01B7A:  MOVLB  B
01B7C:  ADDWF  x31,W
01B7E:  MOVWF  x35
01B80:  MOVLB  2
01B82:  MOVF   x4F,W
01B84:  MOVLB  B
01B86:  ADDWFC x32,W
01B88:  MOVWF  x36
01B8A:  MOVLW  00
01B8C:  ADDWFC x33,W
01B8E:  MOVWF  x37
01B90:  MOVLW  00
01B92:  ADDWFC x34,W
01B94:  MOVWF  x38
01B96:  MOVF   x2F,W
01B98:  ADDWF  x35,W
01B9A:  MOVWF  x2B
01B9C:  MOVLW  00
01B9E:  ADDWFC x36,W
01BA0:  MOVWF  x2C
01BA2:  MOVLW  00
01BA4:  ADDWFC x37,W
01BA6:  MOVWF  x2D
01BA8:  MOVLW  00
01BAA:  ADDWFC x38,W
01BAC:  MOVWF  x2E
.................... 				ReadSector(actsector,gFiles[hFile].IOpuffer); 
01BAE:  CLRF   x62
01BB0:  MOVFF  B12,B61
01BB4:  MOVLW  02
01BB6:  MOVWF  x64
01BB8:  MOVLW  33
01BBA:  MOVWF  x63
01BBC:  MOVLB  0
01BBE:  CALL   039E
01BC2:  MOVFF  02,B32
01BC6:  MOVFF  01,B31
01BCA:  MOVLW  70
01BCC:  MOVLB  B
01BCE:  ADDWF  01,W
01BD0:  MOVWF  01
01BD2:  MOVLW  02
01BD4:  ADDWFC 02,W
01BD6:  MOVWF  03
01BD8:  MOVFF  01,B33
01BDC:  MOVWF  x34
01BDE:  MOVFF  B2E,B47
01BE2:  MOVFF  B2D,B46
01BE6:  MOVFF  B2C,B45
01BEA:  MOVFF  B2B,B44
01BEE:  MOVWF  x49
01BF0:  MOVFF  01,B48
01BF4:  MOVLB  0
01BF6:  CALL   07CA
.................... 				gFAT32Vars.gDirEntrySector = actsector; 
01BFA:  MOVFF  B2E,230
01BFE:  MOVFF  B2D,22F
01C02:  MOVFF  B2C,22E
01C06:  MOVFF  B2B,22D
.................... 				gFiles[hFile].dirSector = actsector; 
01C0A:  MOVLB  B
01C0C:  CLRF   x62
01C0E:  MOVFF  B12,B61
01C12:  MOVLW  02
01C14:  MOVWF  x64
01C16:  MOVLW  33
01C18:  MOVWF  x63
01C1A:  MOVLB  0
01C1C:  CALL   039E
01C20:  MOVFF  01,B31
01C24:  MOVLW  2B
01C26:  MOVLB  B
01C28:  ADDWF  01,W
01C2A:  MOVWF  01
01C2C:  MOVLW  02
01C2E:  ADDWFC 02,W
01C30:  MOVWF  03
01C32:  MOVF   01,W
01C34:  ADDLW  70
01C36:  MOVWF  FE9
01C38:  MOVLW  02
01C3A:  ADDWFC 03,W
01C3C:  MOVWF  FEA
01C3E:  MOVFF  B2B,FEF
01C42:  MOVFF  B2C,FEC
01C46:  MOVFF  B2D,FEC
01C4A:  MOVFF  B2E,FEC
.................... 			} 
.................... 			else 
01C4E:  BRA    1C54
.................... 			{ 
.................... 				bDone = true; 
01C50:  MOVLW  01
01C52:  MOVWF  x30
.................... 			} 
.................... 			 
.................... 		} 
.................... 	} while (!bDone); 
01C54:  MOVF   x30,F
01C56:  BTFSC  FD8.2
01C58:  BRA    1604
....................  
.................... 	return FALSE; 
01C5A:  MOVLW  00
01C5C:  MOVWF  01
.................... } 
01C5E:  MOVLB  0
01C60:  RETLW  00
....................  
.................... // file I/O routines 
.................... char* TryFile(char *fname, HANDLE *hFile) 
.................... { 
.................... 	char i,leng; 
.................... 	char *filename; 
....................  
.................... 	TRACE1("\r\nTryFile(%s)", fname); 
.................... 	*hFile = 0xFF; 
*
01EF4:  MOVLB  B
01EF6:  MOVFF  B00,FE9
01EFA:  MOVFF  B01,FEA
01EFE:  MOVLW  FF
01F00:  MOVWF  FEF
.................... 	for (i=0;i<MAXFILES;i++)  
01F02:  CLRF   x02
01F04:  MOVF   x02,F
01F06:  BNZ   1F54
.................... 	{ 
.................... 		if (gFiles[i].Free)  
01F08:  CLRF   x62
01F0A:  MOVFF  B02,B61
01F0E:  MOVLW  02
01F10:  MOVWF  x64
01F12:  MOVLW  33
01F14:  MOVWF  x63
01F16:  MOVLB  0
01F18:  CALL   039E
01F1C:  MOVFF  02,B07
01F20:  MOVFF  01,B06
01F24:  MOVLW  32
01F26:  MOVLB  B
01F28:  ADDWF  01,W
01F2A:  MOVWF  01
01F2C:  MOVLW  02
01F2E:  ADDWFC 02,W
01F30:  MOVWF  03
01F32:  MOVF   01,W
01F34:  ADDLW  70
01F36:  MOVWF  FE9
01F38:  MOVLW  02
01F3A:  ADDWFC 03,W
01F3C:  MOVWF  FEA
01F3E:  MOVF   FEF,F
01F40:  BZ    1F50
.................... 		{ 
.................... 			*hFile = i; 
01F42:  MOVFF  B00,FE9
01F46:  MOVFF  B01,FEA
01F4A:  MOVFF  B02,FEF
.................... 			break; 
01F4E:  BRA    1F54
.................... 		} 
.................... 	} 
01F50:  INCF   x02,F
01F52:  BRA    1F04
.................... 	if (*hFile == 0xFF)  
01F54:  MOVFF  B01,03
01F58:  MOVFF  B00,FE9
01F5C:  MOVFF  B01,FEA
01F60:  INCFSZ FEF,W
01F62:  BRA    1F6C
.................... 		return 0; 
01F64:  MOVLW  00
01F66:  MOVWF  01
01F68:  MOVWF  02
01F6A:  BRA    2074
....................  
.................... 	ReadRootDirectory(*hFile); 
01F6C:  MOVFF  B01,03
01F70:  MOVFF  B00,FE9
01F74:  MOVFF  B01,FEA
01F78:  MOVFF  FEF,B06
01F7C:  MOVFF  B06,B09
01F80:  MOVLB  0
01F82:  GOTO   0D9A
....................  
.................... 	filename = fname; 
01F86:  MOVFF  AFF,B05
01F8A:  MOVFF  AFE,B04
.................... 	leng = strlen(fname); 
01F8E:  MOVFF  AFF,B19
01F92:  MOVFF  AFE,B18
01F96:  CALL   0FAA
01F9A:  MOVFF  01,B03
.................... 	for (i=0;i<leng;i++)  
01F9E:  MOVLB  B
01FA0:  CLRF   x02
01FA2:  MOVF   x03,W
01FA4:  SUBWF  x02,W
01FA6:  BC    206C
.................... 	{ 
.................... 		if (fname[i] == '/')  
01FA8:  CLRF   03
01FAA:  MOVF   x02,W
01FAC:  MOVLB  A
01FAE:  ADDWF  xFE,W
01FB0:  MOVWF  FE9
01FB2:  MOVF   xFF,W
01FB4:  ADDWFC 03,W
01FB6:  MOVWF  FEA
01FB8:  MOVF   FEF,W
01FBA:  SUBLW  2F
01FBC:  BNZ   2066
.................... 		{ 
.................... 			fname[i] = 0; 
01FBE:  CLRF   03
01FC0:  MOVLB  B
01FC2:  MOVF   x02,W
01FC4:  MOVLB  A
01FC6:  ADDWF  xFE,W
01FC8:  MOVWF  FE9
01FCA:  MOVF   xFF,W
01FCC:  ADDWFC 03,W
01FCE:  MOVWF  FEA
01FD0:  CLRF   FEF
.................... 			if (!cwd(filename,*hFile))  
01FD2:  MOVFF  B01,03
01FD6:  MOVFF  B00,FE9
01FDA:  MOVFF  B01,FEA
01FDE:  MOVFF  FEF,B06
01FE2:  MOVFF  B05,B0A
01FE6:  MOVFF  B04,B09
01FEA:  MOVFF  B06,B0B
01FEE:  MOVLB  0
01FF0:  BRA    1D30
01FF2:  MOVF   01,F
01FF4:  BNZ   2042
.................... 			{ 
.................... 				gFiles[*hFile].Free = TRUE; 
01FF6:  MOVFF  B01,03
01FFA:  MOVLB  B
01FFC:  MOVFF  B00,FE9
02000:  MOVFF  B01,FEA
02004:  CLRF   x62
02006:  MOVFF  FEF,B61
0200A:  MOVLW  02
0200C:  MOVWF  x64
0200E:  MOVLW  33
02010:  MOVWF  x63
02012:  MOVLB  0
02014:  CALL   039E
02018:  MOVFF  01,B07
0201C:  MOVLW  32
0201E:  MOVLB  B
02020:  ADDWF  01,W
02022:  MOVWF  01
02024:  MOVLW  02
02026:  ADDWFC 02,W
02028:  MOVWF  03
0202A:  MOVF   01,W
0202C:  ADDLW  70
0202E:  MOVWF  FE9
02030:  MOVLW  02
02032:  ADDWFC 03,W
02034:  MOVWF  FEA
02036:  MOVLW  01
02038:  MOVWF  FEF
.................... 				return 0; 
0203A:  MOVLW  00
0203C:  MOVWF  01
0203E:  MOVWF  02
02040:  BRA    2074
.................... 			} 
.................... 			filename = fname+i+1; 
02042:  MOVLB  B
02044:  MOVF   x02,W
02046:  MOVLB  A
02048:  ADDWF  xFE,W
0204A:  MOVLB  B
0204C:  MOVWF  x06
0204E:  MOVLW  00
02050:  MOVLB  A
02052:  ADDWFC xFF,W
02054:  MOVLB  B
02056:  MOVWF  x07
02058:  MOVLW  01
0205A:  ADDWF  x06,W
0205C:  MOVWF  x04
0205E:  MOVLW  00
02060:  ADDWFC x07,W
02062:  MOVWF  x05
02064:  MOVLB  A
.................... 		} 
.................... 	} 
02066:  MOVLB  B
02068:  INCF   x02,F
0206A:  BRA    1FA2
.................... 	return filename; 
0206C:  MOVFF  B04,01
02070:  MOVFF  B05,02
.................... } 
02074:  MOVLB  0
02076:  RETLW  00
....................  
.................... char fcreate(HANDLE hFile,char *fname) 
.................... { 
.................... 	DIR *pDir; 
.................... 	int32 actsector,actcl; 
.................... 	int16 i; 
....................  
.................... #ifdef TRACE 
.................... 	TRACE2("\r\nfcreate(%d, %s)", hFile, fname);	 
.................... #endif 
....................  
.................... 	if (hFile > (MAXFILES-1)) 
*
027AE:  MOVLB  A
027B0:  MOVF   xFE,F
027B2:  BZ    27BA
.................... 		return FALSE; 
027B4:  MOVLW  00
027B6:  MOVWF  01
027B8:  BRA    2D6A
....................  
.................... 	if(gFATType == FAT32) 
027BA:  MOVLB  4
027BC:  MOVF   xBB,W
027BE:  SUBLW  03
027C0:  BTFSS  FD8.2
027C2:  BRA    2A02
.................... 	{ 
.................... 		if (gFAT32Vars.gFirstDirEntryCluster == 0x0FFFFFFF)  
027C4:  MOVLB  2
027C6:  INCFSZ x33,W
027C8:  BRA    29A6
027CA:  INCFSZ x34,W
027CC:  BRA    29A6
027CE:  INCFSZ x35,W
027D0:  BRA    29A6
027D2:  MOVF   x36,W
027D4:  SUBLW  0F
027D6:  BTFSS  FD8.2
027D8:  BRA    29A6
.................... 		{ 
.................... #ifdef TRACE 
.................... 			TRACE0("\r\nfcreate() - gFirstDirEntryCluster == 0xFFFFFFF");	 
.................... #endif			// extend the directory file !!! 
.................... 			gFAT32Vars.gFirstDirEntryCluster = FindFirstFreeCluster(); 
027DA:  MOVLB  0
027DC:  RCALL  2078
027DE:  MOVFF  03,236
027E2:  MOVFF  02,235
027E6:  MOVFF  01,234
027EA:  MOVFF  00,233
.................... 			gFAT32Vars.gFirstEmptyDirEntry = 0; 
027EE:  MOVLB  2
027F0:  CLRF   x32
027F2:  CLRF   x31
.................... 			SetClusterEntry(gFiles[hFile].CurrentCluster,gFAT32Vars.gFirstDirEntryCluster); 
027F4:  MOVLB  B
027F6:  CLRF   x62
027F8:  MOVFF  AFE,B61
027FC:  MOVLW  02
027FE:  MOVWF  x64
02800:  MOVLW  33
02802:  MOVWF  x63
02804:  MOVLB  0
02806:  CALL   039E
0280A:  MOVFF  02,B0E
0280E:  MOVFF  01,B0D
02812:  MOVLW  20
02814:  MOVLB  B
02816:  ADDWF  01,W
02818:  MOVWF  01
0281A:  MOVLW  02
0281C:  ADDWFC 02,W
0281E:  MOVWF  03
02820:  MOVF   01,W
02822:  ADDLW  70
02824:  MOVWF  FE9
02826:  MOVLW  02
02828:  ADDWFC 03,W
0282A:  MOVWF  FEA
0282C:  MOVFF  FEF,B0F
02830:  MOVFF  FEC,B10
02834:  MOVFF  FEC,B11
02838:  MOVFF  FEC,B12
0283C:  MOVFF  B12,B18
02840:  MOVFF  B11,B17
02844:  MOVFF  B10,B16
02848:  MOVFF  B0F,B15
0284C:  MOVFF  236,B1C
02850:  MOVFF  235,B1B
02854:  MOVFF  234,B1A
02858:  MOVFF  233,B19
0285C:  MOVLB  0
0285E:  RCALL  2412
.................... 			SetClusterEntry(gFAT32Vars.gFirstDirEntryCluster,0x0FFFFFFF); 
02860:  MOVFF  236,B18
02864:  MOVFF  235,B17
02868:  MOVFF  234,B16
0286C:  MOVFF  233,B15
02870:  MOVLW  0F
02872:  MOVLB  B
02874:  MOVWF  x1C
02876:  MOVLW  FF
02878:  MOVWF  x1B
0287A:  MOVWF  x1A
0287C:  MOVWF  x19
0287E:  MOVLB  0
02880:  RCALL  2412
.................... 			actsector = gFAT32Vars.gFirstDirEntryCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
02882:  MOVFF  236,B3C
02886:  MOVFF  235,B3B
0288A:  MOVFF  234,B3A
0288E:  MOVFF  233,B39
02892:  MOVLB  B
02894:  CLRF   x40
02896:  CLRF   x3F
02898:  CLRF   x3E
0289A:  MOVFF  24D,B3D
0289E:  MOVLB  0
028A0:  CALL   08F4
028A4:  MOVLB  2
028A6:  MOVF   x27,W
028A8:  MOVLB  B
028AA:  ADDWF  00,W
028AC:  MOVWF  x03
028AE:  MOVLB  2
028B0:  MOVF   x28,W
028B2:  MOVLB  B
028B4:  ADDWFC 01,W
028B6:  MOVWF  x04
028B8:  MOVLB  2
028BA:  MOVF   x29,W
028BC:  MOVLB  B
028BE:  ADDWFC 02,W
028C0:  MOVWF  x05
028C2:  MOVLB  2
028C4:  MOVF   x2A,W
028C6:  MOVLB  B
028C8:  ADDWFC 03,W
028CA:  MOVWF  x06
.................... 			 
.................... 			for (i=0;i<512;i++) 
028CC:  CLRF   x0C
028CE:  CLRF   x0B
028D0:  MOVF   x0C,W
028D2:  SUBLW  01
028D4:  BNC   2912
.................... 				gFiles[hFile].IOpuffer[i] = 0; 
028D6:  CLRF   x62
028D8:  MOVFF  AFE,B61
028DC:  MOVLW  02
028DE:  MOVWF  x64
028E0:  MOVLW  33
028E2:  MOVWF  x63
028E4:  MOVLB  0
028E6:  CALL   039E
028EA:  MOVFF  01,B0D
028EE:  MOVLB  B
028F0:  MOVF   x0B,W
028F2:  ADDWF  01,W
028F4:  MOVWF  01
028F6:  MOVF   x0C,W
028F8:  ADDWFC 02,W
028FA:  MOVWF  03
028FC:  MOVF   01,W
028FE:  ADDLW  70
02900:  MOVWF  FE9
02902:  MOVLW  02
02904:  ADDWFC 03,W
02906:  MOVWF  FEA
02908:  CLRF   FEF
0290A:  INCF   x0B,F
0290C:  BTFSC  FD8.2
0290E:  INCF   x0C,F
02910:  BRA    28D0
....................  
.................... 			//Clean up  all sectors in the dir cluster 
.................... 			for(i=0; i<DiskInfo.SecPerClus; i++) 
02912:  CLRF   x0C
02914:  CLRF   x0B
02916:  MOVF   x0C,F
02918:  BNZ   2996
0291A:  MOVLB  2
0291C:  MOVF   x4D,W
0291E:  MOVLB  B
02920:  SUBWF  x0B,W
02922:  BC    2996
.................... 				gFATErrCode = WriteSector(actsector + i,gFiles[hFile].IOpuffer); 
02924:  MOVF   x0B,W
02926:  ADDWF  x03,W
02928:  MOVWF  x0D
0292A:  MOVF   x0C,W
0292C:  ADDWFC x04,W
0292E:  MOVWF  x0E
02930:  MOVLW  00
02932:  ADDWFC x05,W
02934:  MOVWF  x0F
02936:  MOVLW  00
02938:  ADDWFC x06,W
0293A:  MOVWF  x10
0293C:  CLRF   x62
0293E:  MOVFF  AFE,B61
02942:  MOVLW  02
02944:  MOVWF  x64
02946:  MOVLW  33
02948:  MOVWF  x63
0294A:  MOVLB  0
0294C:  CALL   039E
02950:  MOVFF  02,B12
02954:  MOVFF  01,B11
02958:  MOVLW  70
0295A:  MOVLB  B
0295C:  ADDWF  01,W
0295E:  MOVWF  01
02960:  MOVLW  02
02962:  ADDWFC 02,W
02964:  MOVWF  03
02966:  MOVFF  01,B13
0296A:  MOVWF  x14
0296C:  MOVFF  B10,B4B
02970:  MOVFF  B0F,B4A
02974:  MOVFF  B0E,B49
02978:  MOVFF  B0D,B48
0297C:  MOVWF  x4D
0297E:  MOVFF  01,B4C
02982:  MOVLB  0
02984:  CALL   1156
02988:  MOVFF  01,09
0298C:  MOVLB  B
0298E:  INCF   x0B,F
02990:  BTFSC  FD8.2
02992:  INCF   x0C,F
02994:  BRA    2916
.................... 				 
.................... 			if(gFATErrCode != MMC_NO_ERR) 
02996:  MOVF   09,F
02998:  BZ    29A4
.................... 			{ 
.................... #ifdef TRACE 
.................... 				TRACE0( "\r\nfcreate() - WriteSector failed");	 
.................... #endif				return false; 
0299A:  MOVLW  00
0299C:  MOVWF  01
0299E:  MOVLB  A
029A0:  BRA    2D6A
029A2:  MOVLB  B
.................... 			} 
.................... 		} 
.................... 		else 
029A4:  BRA    29FE
.................... 			actsector = gFiles[hFile].dirSector; 
029A6:  MOVLB  B
029A8:  CLRF   x62
029AA:  MOVFF  AFE,B61
029AE:  MOVLW  02
029B0:  MOVWF  x64
029B2:  MOVLW  33
029B4:  MOVWF  x63
029B6:  MOVLB  0
029B8:  CALL   039E
029BC:  MOVFF  02,B0E
029C0:  MOVFF  01,B0D
029C4:  MOVLW  2B
029C6:  MOVLB  B
029C8:  ADDWF  01,W
029CA:  MOVWF  01
029CC:  MOVLW  02
029CE:  ADDWFC 02,W
029D0:  MOVWF  03
029D2:  MOVF   01,W
029D4:  ADDLW  70
029D6:  MOVWF  FE9
029D8:  MOVLW  02
029DA:  ADDWFC 03,W
029DC:  MOVWF  FEA
029DE:  MOVFF  FEF,00
029E2:  MOVFF  FEC,01
029E6:  MOVFF  FEC,02
029EA:  MOVFF  FEC,03
029EE:  MOVFF  03,B06
029F2:  MOVFF  02,B05
029F6:  MOVFF  01,B04
029FA:  MOVFF  00,B03
....................  
.................... 		//actsector = gFAT32Vars.gFirstDirEntryCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
.................... 	} 
.................... 	else	//FAT16 
029FE:  BRA    2A5A
02A00:  MOVLB  4
.................... 	{ 
.................... 		//FAT16 has fixed size DIR sectors 
.................... 		actsector = gFiles[hFile].dirSector; 
02A02:  MOVLB  B
02A04:  CLRF   x62
02A06:  MOVFF  AFE,B61
02A0A:  MOVLW  02
02A0C:  MOVWF  x64
02A0E:  MOVLW  33
02A10:  MOVWF  x63
02A12:  MOVLB  0
02A14:  CALL   039E
02A18:  MOVFF  02,B0E
02A1C:  MOVFF  01,B0D
02A20:  MOVLW  2B
02A22:  MOVLB  B
02A24:  ADDWF  01,W
02A26:  MOVWF  01
02A28:  MOVLW  02
02A2A:  ADDWFC 02,W
02A2C:  MOVWF  03
02A2E:  MOVF   01,W
02A30:  ADDLW  70
02A32:  MOVWF  FE9
02A34:  MOVLW  02
02A36:  ADDWFC 03,W
02A38:  MOVWF  FEA
02A3A:  MOVFF  FEF,00
02A3E:  MOVFF  FEC,01
02A42:  MOVFF  FEC,02
02A46:  MOVFF  FEC,03
02A4A:  MOVFF  03,B06
02A4E:  MOVFF  02,B05
02A52:  MOVFF  01,B04
02A56:  MOVFF  00,B03
.................... 	} 
.................... 	 
.................... 	ReadSector(actsector,gFiles[hFile].IOpuffer); 
02A5A:  CLRF   x62
02A5C:  MOVFF  AFE,B61
02A60:  MOVLW  02
02A62:  MOVWF  x64
02A64:  MOVLW  33
02A66:  MOVWF  x63
02A68:  MOVLB  0
02A6A:  CALL   039E
02A6E:  MOVFF  02,B0E
02A72:  MOVFF  01,B0D
02A76:  MOVLW  70
02A78:  MOVLB  B
02A7A:  ADDWF  01,W
02A7C:  MOVWF  01
02A7E:  MOVLW  02
02A80:  ADDWFC 02,W
02A82:  MOVWF  03
02A84:  MOVFF  01,B0F
02A88:  MOVWF  x10
02A8A:  MOVFF  B06,B47
02A8E:  MOVFF  B05,B46
02A92:  MOVFF  B04,B45
02A96:  MOVFF  B03,B44
02A9A:  MOVWF  x49
02A9C:  MOVFF  01,B48
02AA0:  MOVLB  0
02AA2:  CALL   07CA
....................  
.................... 	pDir = (DIR*)(&(gFiles[hFile].IOpuffer[32*gFAT32Vars.gFirstEmptyDirEntry])); 
02AA6:  MOVLB  B
02AA8:  CLRF   x62
02AAA:  MOVFF  AFE,B61
02AAE:  MOVLW  02
02AB0:  MOVWF  x64
02AB2:  MOVLW  33
02AB4:  MOVWF  x63
02AB6:  MOVLB  0
02AB8:  CALL   039E
02ABC:  MOVFF  01,B0D
02AC0:  MOVLB  2
02AC2:  RLCF   x31,W
02AC4:  MOVLB  B
02AC6:  MOVWF  x0F
02AC8:  MOVLB  2
02ACA:  RLCF   x32,W
02ACC:  MOVLB  B
02ACE:  MOVWF  x10
02AD0:  RLCF   x0F,F
02AD2:  RLCF   x10,F
02AD4:  RLCF   x0F,F
02AD6:  RLCF   x10,F
02AD8:  RLCF   x0F,F
02ADA:  RLCF   x10,F
02ADC:  RLCF   x0F,F
02ADE:  RLCF   x10,F
02AE0:  MOVLW  E0
02AE2:  ANDWF  x0F,F
02AE4:  MOVF   x0F,W
02AE6:  ADDWF  01,W
02AE8:  MOVWF  01
02AEA:  MOVF   x10,W
02AEC:  ADDWFC 02,W
02AEE:  MOVWF  03
02AF0:  MOVF   01,W
02AF2:  ADDLW  70
02AF4:  MOVWF  01
02AF6:  MOVLW  02
02AF8:  ADDWFC 03,F
02AFA:  MOVFF  01,B01
02AFE:  MOVFF  03,B02
.................... 	gFiles[hFile].dirSector = actsector; 
02B02:  CLRF   x62
02B04:  MOVFF  AFE,B61
02B08:  MOVLW  02
02B0A:  MOVWF  x64
02B0C:  MOVLW  33
02B0E:  MOVWF  x63
02B10:  MOVLB  0
02B12:  CALL   039E
02B16:  MOVFF  01,B0D
02B1A:  MOVLW  2B
02B1C:  MOVLB  B
02B1E:  ADDWF  01,W
02B20:  MOVWF  01
02B22:  MOVLW  02
02B24:  ADDWFC 02,W
02B26:  MOVWF  03
02B28:  MOVF   01,W
02B2A:  ADDLW  70
02B2C:  MOVWF  FE9
02B2E:  MOVLW  02
02B30:  ADDWFC 03,W
02B32:  MOVWF  FEA
02B34:  MOVFF  B03,FEF
02B38:  MOVFF  B04,FEC
02B3C:  MOVFF  B05,FEC
02B40:  MOVFF  B06,FEC
.................... 	gFiles[hFile].dirIdx = gFAT32Vars.gFirstEmptyDirEntry; 
02B44:  CLRF   x62
02B46:  MOVFF  AFE,B61
02B4A:  MOVLW  02
02B4C:  MOVWF  x64
02B4E:  MOVLW  33
02B50:  MOVWF  x63
02B52:  MOVLB  0
02B54:  CALL   039E
02B58:  MOVFF  01,B0D
02B5C:  MOVLW  2F
02B5E:  MOVLB  B
02B60:  ADDWF  01,W
02B62:  MOVWF  01
02B64:  MOVLW  02
02B66:  ADDWFC 02,W
02B68:  MOVWF  03
02B6A:  MOVF   01,W
02B6C:  ADDLW  70
02B6E:  MOVWF  FE9
02B70:  MOVLW  02
02B72:  ADDWFC 03,W
02B74:  MOVWF  FEA
02B76:  MOVFF  232,FEC
02B7A:  MOVF   FED,F
02B7C:  MOVFF  231,FEF
.................... 	 
.................... 	GetDOSName(pDir,fname); 
02B80:  MOVFF  B02,B10
02B84:  MOVFF  B01,B0F
02B88:  MOVFF  B00,B12
02B8C:  MOVFF  AFF,B11
02B90:  MOVLB  0
02B92:  BRA    2624
.................... 	pDir->bAttr = 0; 
02B94:  MOVLW  0B
02B96:  MOVLB  B
02B98:  ADDWF  x01,W
02B9A:  MOVWF  FE9
02B9C:  MOVLW  00
02B9E:  ADDWFC x02,W
02BA0:  MOVWF  FEA
02BA2:  CLRF   FEF
.................... 	actcl = FindFirstFreeCluster(); 
02BA4:  MOVLB  0
02BA6:  CALL   2078
02BAA:  MOVFF  03,B0A
02BAE:  MOVFF  02,B09
02BB2:  MOVFF  01,B08
02BB6:  MOVFF  00,B07
....................  
.................... #ifdef TRACE 
.................... 	TRACE1("\r\nFindFirstFreeCluster returns %lu", actcl);	 
.................... #endif	 
....................  
.................... 	pDir->hCluster = actcl & 0xFFFF; 
02BBA:  MOVLW  1A
02BBC:  MOVLB  B
02BBE:  ADDWF  x01,W
02BC0:  MOVWF  FE9
02BC2:  MOVLW  00
02BC4:  ADDWFC x02,W
02BC6:  MOVWF  FEA
02BC8:  MOVFF  B07,FEF
02BCC:  MOVFF  B08,FEC
.................... 	pDir->hClusterH = actcl >> 16; 
02BD0:  MOVLW  14
02BD2:  ADDWF  x01,W
02BD4:  MOVWF  FE9
02BD6:  MOVLW  00
02BD8:  ADDWFC x02,W
02BDA:  MOVWF  FEA
02BDC:  MOVFF  B09,FEF
02BE0:  MOVFF  B0A,FEC
.................... 	SetClusterEntry(actcl,0x0FFFFFFF); 
02BE4:  MOVFF  B0A,B18
02BE8:  MOVFF  B09,B17
02BEC:  MOVFF  B08,B16
02BF0:  MOVFF  B07,B15
02BF4:  MOVLW  0F
02BF6:  MOVWF  x1C
02BF8:  MOVLW  FF
02BFA:  MOVWF  x1B
02BFC:  MOVWF  x1A
02BFE:  MOVWF  x19
02C00:  MOVLB  0
02C02:  RCALL  2412
.................... 	pDir->wSize = 0; 
02C04:  MOVLW  1C
02C06:  MOVLB  B
02C08:  ADDWF  x01,W
02C0A:  MOVWF  FE9
02C0C:  MOVLW  00
02C0E:  ADDWFC x02,W
02C10:  MOVWF  FEA
02C12:  MOVF   FEE,F
02C14:  MOVF   FEE,F
02C16:  CLRF   FEC
02C18:  MOVF   FED,F
02C1A:  CLRF   FEF
02C1C:  MOVF   FED,F
02C1E:  CLRF   FEF
02C20:  MOVF   FED,F
02C22:  CLRF   FEF
.................... 	gFiles[hFile].wFileSize = 0; 
02C24:  CLRF   x62
02C26:  MOVFF  AFE,B61
02C2A:  MOVLW  02
02C2C:  MOVWF  x64
02C2E:  MOVLW  33
02C30:  MOVWF  x63
02C32:  MOVLB  0
02C34:  CALL   039E
02C38:  MOVFF  01,B0D
02C3C:  MOVLW  27
02C3E:  MOVLB  B
02C40:  ADDWF  01,W
02C42:  MOVWF  01
02C44:  MOVLW  02
02C46:  ADDWFC 02,W
02C48:  MOVWF  03
02C4A:  MOVF   01,W
02C4C:  ADDLW  70
02C4E:  MOVWF  FE9
02C50:  MOVLW  02
02C52:  ADDWFC 03,W
02C54:  MOVWF  FEA
02C56:  MOVF   FEE,F
02C58:  MOVF   FEE,F
02C5A:  CLRF   FEC
02C5C:  MOVF   FED,F
02C5E:  CLRF   FEF
02C60:  MOVF   FED,F
02C62:  CLRF   FEF
02C64:  MOVF   FED,F
02C66:  CLRF   FEF
.................... 	pDir->hDate = GetCurrentDOSDate(); 
02C68:  MOVLW  18
02C6A:  ADDWF  x01,W
02C6C:  MOVWF  01
02C6E:  MOVLW  00
02C70:  ADDWFC x02,W
02C72:  MOVWF  03
02C74:  MOVFF  01,B0D
02C78:  MOVWF  x0E
02C7A:  MOVLB  0
02C7C:  RCALL  2700
02C7E:  MOVFF  B0E,FEA
02C82:  MOVFF  B0D,FE9
02C86:  MOVFF  02,FEC
02C8A:  MOVF   FED,F
02C8C:  MOVFF  01,FEF
.................... 	pDir->hTime = GetCurrentDOSTime(); 
02C90:  MOVLW  16
02C92:  MOVLB  B
02C94:  ADDWF  x01,W
02C96:  MOVWF  01
02C98:  MOVLW  00
02C9A:  ADDWFC x02,W
02C9C:  MOVWF  03
02C9E:  MOVFF  01,B0D
02CA2:  MOVWF  x0E
02CA4:  MOVLB  0
02CA6:  RCALL  2754
02CA8:  MOVFF  B0E,FEA
02CAC:  MOVFF  B0D,FE9
02CB0:  MOVFF  02,FEC
02CB4:  MOVF   FED,F
02CB6:  MOVFF  01,FEF
....................  
.................... 	gFATErrCode = WriteSector(actsector,gFiles[hFile].IOpuffer); 
02CBA:  MOVLB  B
02CBC:  CLRF   x62
02CBE:  MOVFF  AFE,B61
02CC2:  MOVLW  02
02CC4:  MOVWF  x64
02CC6:  MOVLW  33
02CC8:  MOVWF  x63
02CCA:  MOVLB  0
02CCC:  CALL   039E
02CD0:  MOVFF  02,B0E
02CD4:  MOVFF  01,B0D
02CD8:  MOVLW  70
02CDA:  MOVLB  B
02CDC:  ADDWF  01,W
02CDE:  MOVWF  01
02CE0:  MOVLW  02
02CE2:  ADDWFC 02,W
02CE4:  MOVWF  03
02CE6:  MOVFF  01,B0F
02CEA:  MOVWF  x10
02CEC:  MOVFF  B06,B4B
02CF0:  MOVFF  B05,B4A
02CF4:  MOVFF  B04,B49
02CF8:  MOVFF  B03,B48
02CFC:  MOVWF  x4D
02CFE:  MOVFF  01,B4C
02D02:  MOVLB  0
02D04:  CALL   1156
02D08:  MOVFF  01,09
....................  
.................... 	memcpy(&(gFiles[hFile].DirEntry),pDir,32); 
02D0C:  MOVLB  B
02D0E:  CLRF   x62
02D10:  MOVFF  AFE,B61
02D14:  MOVLW  02
02D16:  MOVWF  x64
02D18:  MOVLW  33
02D1A:  MOVWF  x63
02D1C:  MOVLB  0
02D1E:  CALL   039E
02D22:  MOVFF  02,B0E
02D26:  MOVFF  01,B0D
02D2A:  MOVLB  B
02D2C:  MOVFF  01,01
02D30:  MOVLW  02
02D32:  ADDWF  02,W
02D34:  MOVWF  03
02D36:  MOVF   01,W
02D38:  ADDLW  70
02D3A:  MOVWF  01
02D3C:  MOVLW  02
02D3E:  ADDWFC 03,F
02D40:  MOVFF  01,B0F
02D44:  MOVFF  03,B10
02D48:  MOVFF  03,FEA
02D4C:  MOVFF  01,FE9
02D50:  MOVFF  B02,FE2
02D54:  MOVFF  B01,FE1
02D58:  MOVLW  20
02D5A:  MOVWF  01
02D5C:  MOVFF  FE6,FEE
02D60:  DECFSZ 01,F
02D62:  BRA    2D5C
.................... 	return TRUE; 
02D64:  MOVLW  01
02D66:  MOVWF  01
02D68:  MOVLB  A
.................... } 
02D6A:  MOVLB  0
02D6C:  GOTO   2E2C (RETURN)
....................  
.................... int32 ComposeCluster(HANDLE hFile) 
.................... { 
.................... 	int32 retval; 
....................  
.................... 	retval = gFiles[hFile].DirEntry.hClusterH; 
*
01C62:  MOVLB  B
01C64:  CLRF   x62
01C66:  MOVFF  B14,B61
01C6A:  MOVLW  02
01C6C:  MOVWF  x64
01C6E:  MOVLW  33
01C70:  MOVWF  x63
01C72:  MOVLB  0
01C74:  CALL   039E
01C78:  MOVFF  02,B1A
01C7C:  MOVFF  01,B19
01C80:  MOVLB  B
01C82:  MOVFF  01,B1B
01C86:  MOVLW  02
01C88:  ADDWF  02,W
01C8A:  MOVWF  x1C
01C8C:  MOVLW  14
01C8E:  ADDWF  01,W
01C90:  MOVWF  01
01C92:  MOVLW  00
01C94:  ADDWFC x1C,W
01C96:  MOVWF  03
01C98:  MOVF   01,W
01C9A:  ADDLW  70
01C9C:  MOVWF  FE9
01C9E:  MOVLW  02
01CA0:  ADDWFC 03,W
01CA2:  MOVWF  FEA
01CA4:  MOVFF  FEC,03
01CA8:  MOVF   FED,F
01CAA:  MOVFF  FEF,00
01CAE:  MOVFF  03,01
01CB2:  CLRF   02
01CB4:  CLRF   03
01CB6:  MOVFF  03,B18
01CBA:  MOVFF  02,B17
01CBE:  MOVFF  01,B16
01CC2:  MOVFF  00,B15
.................... 	retval <<= 16; 
01CC6:  MOVFF  B16,B18
01CCA:  MOVFF  B15,B17
01CCE:  CLRF   x15
01CD0:  CLRF   x16
.................... 	retval |= gFiles[hFile].DirEntry.hCluster; 
01CD2:  CLRF   x62
01CD4:  MOVFF  B14,B61
01CD8:  MOVLW  02
01CDA:  MOVWF  x64
01CDC:  MOVLW  33
01CDE:  MOVWF  x63
01CE0:  MOVLB  0
01CE2:  CALL   039E
01CE6:  MOVFF  01,B19
01CEA:  MOVLB  B
01CEC:  MOVFF  01,B1B
01CF0:  MOVLW  02
01CF2:  ADDWF  02,W
01CF4:  MOVWF  x1C
01CF6:  MOVLW  1A
01CF8:  ADDWF  01,W
01CFA:  MOVWF  01
01CFC:  MOVLW  00
01CFE:  ADDWFC x1C,W
01D00:  MOVWF  03
01D02:  MOVF   01,W
01D04:  ADDLW  70
01D06:  MOVWF  FE9
01D08:  MOVLW  02
01D0A:  ADDWFC 03,W
01D0C:  MOVWF  FEA
01D0E:  MOVFF  FEC,03
01D12:  MOVF   FED,F
01D14:  MOVF   FEF,W
01D16:  IORWF  x15,F
01D18:  MOVF   03,W
01D1A:  IORWF  x16,F
.................... 	return retval; 
01D1C:  MOVFF  B15,00
01D20:  MOVFF  B16,01
01D24:  MOVFF  B17,02
01D28:  MOVFF  B18,03
.................... } 
01D2C:  MOVLB  0
01D2E:  RETLW  00
....................  
.................... char fopen(char *fname, char mode) 
.................... { 
.................... 	char found; 
.................... 	HANDLE hFile; 
.................... 	int32 actsector,actcluster,nextcluster; 
.................... 	char *filename; 
....................  
.................... #ifdef TRACE 
.................... 	TRACE2("\r\nfopen(%s, %c)", fname, mode);	 
.................... #endif 
.................... 	if (NO_MMC_CARD)  
*
02D70:  BSF    F93.0
02D72:  BTFSS  F81.0
02D74:  BRA    2D7E
.................... 		return 0xFF; 
02D76:  MOVLW  FF
02D78:  MOVWF  01
02D7A:  GOTO   357A
....................  
.................... 	filename = TryFile(fname,&hFile); 
02D7E:  MOVFF  AEC,AFF
02D82:  MOVFF  AEB,AFE
02D86:  MOVLW  0A
02D88:  MOVLB  B
02D8A:  MOVWF  x01
02D8C:  MOVLW  EF
02D8E:  MOVWF  x00
02D90:  MOVLB  0
02D92:  CALL   1EF4
02D96:  MOVFF  02,AFD
02D9A:  MOVFF  01,AFC
.................... 	 
.................... 	if (filename == 0) 	//Invalid filename? 
02D9E:  MOVLB  A
02DA0:  MOVF   xFC,F
02DA2:  BNZ   2DB4
02DA4:  MOVF   xFD,F
02DA6:  BNZ   2DB4
.................... 		return 0xFF; 
02DA8:  MOVLW  FF
02DAA:  MOVWF  01
02DAC:  MOVLB  0
02DAE:  GOTO   357A
02DB2:  MOVLB  A
.................... 	 
.................... 	found = FALSE; 
02DB4:  CLRF   xEE
.................... 	found = FindDirEntry(filename,hFile); 
02DB6:  MOVFF  AFD,B11
02DBA:  MOVFF  AFC,B10
02DBE:  MOVFF  AEF,B12
02DC2:  MOVLB  0
02DC4:  CALL   1588
02DC8:  MOVFF  01,AEE
.................... 	 
.................... 	if (!found) 	//File not exist 
02DCC:  MOVLB  A
02DCE:  MOVF   xEE,F
02DD0:  BNZ   2E3C
.................... 	{ 
.................... 		if (mode == 'r')  
02DD2:  MOVF   xED,W
02DD4:  SUBLW  72
02DD6:  BNZ   2E1C
.................... 		{ 
.................... 			gFiles[hFile].Free = TRUE; 
02DD8:  MOVLB  B
02DDA:  CLRF   x62
02DDC:  MOVFF  AEF,B61
02DE0:  MOVLW  02
02DE2:  MOVWF  x64
02DE4:  MOVLW  33
02DE6:  MOVWF  x63
02DE8:  MOVLB  0
02DEA:  CALL   039E
02DEE:  MOVFF  01,AFE
02DF2:  MOVLW  32
02DF4:  MOVLB  A
02DF6:  ADDWF  01,W
02DF8:  MOVWF  01
02DFA:  MOVLW  02
02DFC:  ADDWFC 02,W
02DFE:  MOVWF  03
02E00:  MOVF   01,W
02E02:  ADDLW  70
02E04:  MOVWF  FE9
02E06:  MOVLW  02
02E08:  ADDWFC 03,W
02E0A:  MOVWF  FEA
02E0C:  MOVLW  01
02E0E:  MOVWF  FEF
.................... 			return 0xFF; 
02E10:  MOVLW  FF
02E12:  MOVWF  01
02E14:  MOVLB  0
02E16:  BRA    357A
.................... 		}  
.................... 		else  
02E18:  BRA    2E3E
02E1A:  MOVLB  A
.................... 		{ 
.................... 			if (!fcreate(hFile,filename))  
02E1C:  MOVFF  AEF,AFE
02E20:  MOVFF  AFD,B00
02E24:  MOVFF  AFC,AFF
02E28:  MOVLB  0
02E2A:  BRA    27AE
02E2C:  MOVF   01,F
02E2E:  BNZ   2E36
.................... 				return 0xFF; 
02E30:  MOVLW  FF
02E32:  MOVWF  01
02E34:  BRA    357A
.................... 			found = TRUE; 
02E36:  MOVLW  01
02E38:  MOVLB  A
02E3A:  MOVWF  xEE
02E3C:  MOVLB  0
.................... 		} 
.................... 	} 
.................... 	if (found)  
02E3E:  MOVLB  A
02E40:  MOVF   xEE,F
02E42:  BTFSC  FD8.2
02E44:  BRA    3572
.................... 	{ 
.................... 		gFiles[hFile].Free = FALSE; 
02E46:  MOVLB  B
02E48:  CLRF   x62
02E4A:  MOVFF  AEF,B61
02E4E:  MOVLW  02
02E50:  MOVWF  x64
02E52:  MOVLW  33
02E54:  MOVWF  x63
02E56:  MOVLB  0
02E58:  CALL   039E
02E5C:  MOVFF  01,AFE
02E60:  MOVLW  32
02E62:  MOVLB  A
02E64:  ADDWF  01,W
02E66:  MOVWF  01
02E68:  MOVLW  02
02E6A:  ADDWFC 02,W
02E6C:  MOVWF  03
02E6E:  MOVF   01,W
02E70:  ADDLW  70
02E72:  MOVWF  FE9
02E74:  MOVLW  02
02E76:  ADDWFC 03,W
02E78:  MOVWF  FEA
02E7A:  CLRF   FEF
.................... 		gFiles[hFile].mode = mode; 
02E7C:  MOVLB  B
02E7E:  CLRF   x62
02E80:  MOVFF  AEF,B61
02E84:  MOVLW  02
02E86:  MOVWF  x64
02E88:  MOVLW  33
02E8A:  MOVWF  x63
02E8C:  MOVLB  0
02E8E:  CALL   039E
02E92:  MOVFF  01,AFE
02E96:  MOVLW  31
02E98:  MOVLB  A
02E9A:  ADDWF  01,W
02E9C:  MOVWF  01
02E9E:  MOVLW  02
02EA0:  ADDWFC 02,W
02EA2:  MOVWF  03
02EA4:  MOVF   01,W
02EA6:  ADDLW  70
02EA8:  MOVWF  FE9
02EAA:  MOVLW  02
02EAC:  ADDWFC 03,W
02EAE:  MOVWF  FEA
02EB0:  MOVFF  AED,FEF
.................... 		if  (mode == 'a') 	//Append 
02EB4:  MOVF   xED,W
02EB6:  SUBLW  61
02EB8:  BTFSS  FD8.2
02EBA:  BRA    3390
.................... 		{ 
.................... 			gFiles[hFile].wFileSize = gFiles[hFile].DirEntry.wSize; 
02EBC:  MOVLB  B
02EBE:  CLRF   x62
02EC0:  MOVFF  AEF,B61
02EC4:  MOVLW  02
02EC6:  MOVWF  x64
02EC8:  MOVLW  33
02ECA:  MOVWF  x63
02ECC:  MOVLB  0
02ECE:  CALL   039E
02ED2:  MOVFF  02,AFF
02ED6:  MOVFF  01,AFE
02EDA:  MOVLW  27
02EDC:  MOVLB  A
02EDE:  ADDWF  01,W
02EE0:  MOVWF  01
02EE2:  MOVLW  02
02EE4:  ADDWFC 02,W
02EE6:  MOVWF  03
02EE8:  MOVF   01,W
02EEA:  ADDLW  70
02EEC:  MOVWF  01
02EEE:  MOVLW  02
02EF0:  ADDWFC 03,F
02EF2:  MOVFF  01,B00
02EF6:  MOVLB  B
02EF8:  MOVFF  03,B01
02EFC:  CLRF   x62
02EFE:  MOVFF  AEF,B61
02F02:  MOVLW  02
02F04:  MOVWF  x64
02F06:  MOVLW  33
02F08:  MOVWF  x63
02F0A:  MOVLB  0
02F0C:  CALL   039E
02F10:  MOVFF  02,B03
02F14:  MOVFF  01,B02
02F18:  MOVLB  B
02F1A:  MOVFF  01,B04
02F1E:  MOVLW  02
02F20:  ADDWF  02,W
02F22:  MOVWF  x05
02F24:  MOVLW  1C
02F26:  ADDWF  01,W
02F28:  MOVWF  01
02F2A:  MOVLW  00
02F2C:  ADDWFC x05,W
02F2E:  MOVWF  03
02F30:  MOVF   01,W
02F32:  ADDLW  70
02F34:  MOVWF  FE9
02F36:  MOVLW  02
02F38:  ADDWFC 03,W
02F3A:  MOVWF  FEA
02F3C:  MOVFF  FEF,00
02F40:  MOVFF  FEC,01
02F44:  MOVFF  FEC,02
02F48:  MOVFF  FEC,03
02F4C:  MOVFF  B01,FEA
02F50:  MOVFF  B00,FE9
02F54:  MOVFF  00,FEF
02F58:  MOVFF  01,FEC
02F5C:  MOVFF  02,FEC
02F60:  MOVFF  03,FEC
.................... 			actcluster = ComposeCluster(hFile); 
02F64:  MOVFF  AEF,B14
02F68:  MOVLB  0
02F6A:  CALL   1C62
02F6E:  MOVFF  03,AF7
02F72:  MOVFF  02,AF6
02F76:  MOVFF  01,AF5
02F7A:  MOVFF  00,AF4
.................... 			nextcluster = actcluster; 
02F7E:  MOVFF  AF7,AFB
02F82:  MOVFF  AF6,AFA
02F86:  MOVFF  AF5,AF9
02F8A:  MOVFF  AF4,AF8
.................... 			TRACE2("\r\nCluster starts at %lu(0x%04X).", actcluster, actcluster); 
.................... 			while (actcluster != 0x0FFFFFFF && nextcluster != 0)  
.................... 			{ 
02F8E:  MOVLB  A
02F90:  INCFSZ xF4,W
02F92:  BRA    2FA2
02F94:  INCFSZ xF5,W
02F96:  BRA    2FA2
02F98:  INCFSZ xF6,W
02F9A:  BRA    2FA2
02F9C:  MOVF   xF7,W
02F9E:  SUBLW  0F
02FA0:  BZ    3010
02FA2:  MOVF   xF8,F
02FA4:  BNZ   2FB2
02FA6:  MOVF   xF9,F
02FA8:  BNZ   2FB2
02FAA:  MOVF   xFA,F
02FAC:  BNZ   2FB2
02FAE:  MOVF   xFB,F
02FB0:  BZ    3010
.................... 				nextcluster = GetNextCluster(actcluster); 
02FB2:  MOVFF  AF7,B3A
02FB6:  MOVFF  AF6,B39
02FBA:  MOVFF  AF5,B38
02FBE:  MOVFF  AF4,B37
02FC2:  MOVLB  0
02FC4:  CALL   1316
02FC8:  MOVFF  03,AFB
02FCC:  MOVFF  02,AFA
02FD0:  MOVFF  01,AF9
02FD4:  MOVFF  00,AF8
.................... 				if (nextcluster == 0x0FFFFFFF || nextcluster == 0)  
02FD8:  MOVLB  A
02FDA:  INCFSZ xF8,W
02FDC:  BRA    2FEC
02FDE:  INCFSZ xF9,W
02FE0:  BRA    2FEC
02FE2:  INCFSZ xFA,W
02FE4:  BRA    2FEC
02FE6:  MOVF   xFB,W
02FE8:  SUBLW  0F
02FEA:  BZ    2FFC
02FEC:  MOVF   xF8,F
02FEE:  BNZ   2FFE
02FF0:  MOVF   xF9,F
02FF2:  BNZ   2FFE
02FF4:  MOVF   xFA,F
02FF6:  BNZ   2FFE
02FF8:  MOVF   xFB,F
02FFA:  BNZ   2FFE
.................... 					break; 
02FFC:  BRA    3010
.................... 				actcluster = nextcluster; 
02FFE:  MOVFF  AFB,AF7
03002:  MOVFF  AFA,AF6
03006:  MOVFF  AF9,AF5
0300A:  MOVFF  AF8,AF4
.................... 			} 
0300E:  BRA    2F90
.................... 			TRACE2("\r\nFound end cluster %lu(0x%04X).", actcluster, actcluster); 
.................... 			 
.................... 			actsector = actcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
03010:  MOVFF  AF7,B3C
03014:  MOVFF  AF6,B3B
03018:  MOVFF  AF5,B3A
0301C:  MOVFF  AF4,B39
03020:  MOVLB  B
03022:  CLRF   x40
03024:  CLRF   x3F
03026:  CLRF   x3E
03028:  MOVFF  24D,B3D
0302C:  MOVLB  0
0302E:  CALL   08F4
03032:  MOVLB  2
03034:  MOVF   x27,W
03036:  MOVLB  A
03038:  ADDWF  00,W
0303A:  MOVWF  xF0
0303C:  MOVLB  2
0303E:  MOVF   x28,W
03040:  MOVLB  A
03042:  ADDWFC 01,W
03044:  MOVWF  xF1
03046:  MOVLB  2
03048:  MOVF   x29,W
0304A:  MOVLB  B
0304C:  ADDWFC 02,W
0304E:  MOVLB  A
03050:  MOVWF  xF2
03052:  MOVLB  2
03054:  MOVF   x2A,W
03056:  MOVLB  B
03058:  ADDWFC 03,W
0305A:  MOVLB  A
0305C:  MOVWF  xF3
.................... 			gFiles[hFile].SecInCluster = (gFiles[hFile].wFileSize>>9)%DiskInfo.SecPerClus; 
0305E:  MOVLB  B
03060:  CLRF   x62
03062:  MOVFF  AEF,B61
03066:  MOVLW  02
03068:  MOVWF  x64
0306A:  MOVLW  33
0306C:  MOVWF  x63
0306E:  MOVLB  0
03070:  CALL   039E
03074:  MOVFF  02,AFF
03078:  MOVFF  01,AFE
0307C:  MOVLW  24
0307E:  MOVLB  A
03080:  ADDWF  01,W
03082:  MOVWF  01
03084:  MOVLW  02
03086:  ADDWFC 02,W
03088:  MOVWF  03
0308A:  MOVF   01,W
0308C:  ADDLW  70
0308E:  MOVWF  01
03090:  MOVLW  02
03092:  ADDWFC 03,F
03094:  MOVFF  01,B00
03098:  MOVLB  B
0309A:  MOVFF  03,B01
0309E:  CLRF   x62
030A0:  MOVFF  AEF,B61
030A4:  MOVLW  02
030A6:  MOVWF  x64
030A8:  MOVLW  33
030AA:  MOVWF  x63
030AC:  MOVLB  0
030AE:  CALL   039E
030B2:  MOVFF  02,B03
030B6:  MOVFF  01,B02
030BA:  MOVLW  27
030BC:  MOVLB  B
030BE:  ADDWF  01,W
030C0:  MOVWF  01
030C2:  MOVLW  02
030C4:  ADDWFC 02,W
030C6:  MOVWF  03
030C8:  MOVF   01,W
030CA:  ADDLW  70
030CC:  MOVWF  FE9
030CE:  MOVLW  02
030D0:  ADDWFC 03,W
030D2:  MOVWF  FEA
030D4:  MOVFF  FEF,B04
030D8:  MOVFF  FEC,B05
030DC:  MOVFF  FEC,B06
030E0:  MOVFF  FEC,B07
030E4:  MOVF   FED,F
030E6:  MOVF   FED,F
030E8:  MOVF   FED,F
030EA:  BCF    FD8.0
030EC:  CLRF   x0C
030EE:  RRCF   x07,W
030F0:  MOVWF  x0B
030F2:  RRCF   x06,W
030F4:  MOVWF  x0A
030F6:  RRCF   x05,W
030F8:  MOVWF  x09
030FA:  MOVFF  FEA,B0E
030FE:  MOVFF  FE9,B0D
03102:  MOVFF  B0C,B12
03106:  MOVFF  B0B,B11
0310A:  MOVFF  B0A,B10
0310E:  MOVWF  x0F
03110:  CLRF   x16
03112:  CLRF   x15
03114:  CLRF   x14
03116:  MOVFF  24D,B13
0311A:  MOVLB  0
0311C:  CALL   0950
03120:  MOVFF  FEF,00
03124:  MOVFF  FEC,01
03128:  MOVFF  FEC,02
0312C:  MOVFF  FEC,03
03130:  MOVFF  B0E,FEA
03134:  MOVFF  B0D,FE9
03138:  MOVFF  B01,FEA
0313C:  MOVFF  B00,FE9
03140:  MOVFF  00,FEF
.................... 			actsector += gFiles[hFile].SecInCluster; 
03144:  MOVLB  B
03146:  CLRF   x62
03148:  MOVFF  AEF,B61
0314C:  MOVLW  02
0314E:  MOVWF  x64
03150:  MOVLW  33
03152:  MOVWF  x63
03154:  MOVLB  0
03156:  CALL   039E
0315A:  MOVFF  01,AFE
0315E:  MOVLW  24
03160:  MOVLB  A
03162:  ADDWF  01,W
03164:  MOVWF  01
03166:  MOVLW  02
03168:  ADDWFC 02,W
0316A:  MOVWF  03
0316C:  MOVF   01,W
0316E:  ADDLW  70
03170:  MOVWF  FE9
03172:  MOVLW  02
03174:  ADDWFC 03,W
03176:  MOVWF  FEA
03178:  MOVF   FEF,W
0317A:  ADDWF  xF0,F
0317C:  MOVLW  00
0317E:  ADDWFC xF1,F
03180:  ADDWFC xF2,F
03182:  ADDWFC xF3,F
.................... 			 
.................... 			ReadSector(actsector,gFiles[hFile].IOpuffer); 
03184:  MOVLB  B
03186:  CLRF   x62
03188:  MOVFF  AEF,B61
0318C:  MOVLW  02
0318E:  MOVWF  x64
03190:  MOVLW  33
03192:  MOVWF  x63
03194:  MOVLB  0
03196:  CALL   039E
0319A:  MOVFF  02,AFF
0319E:  MOVFF  01,AFE
031A2:  MOVLW  70
031A4:  MOVLB  A
031A6:  ADDWF  01,W
031A8:  MOVWF  01
031AA:  MOVLW  02
031AC:  ADDWFC 02,W
031AE:  MOVWF  03
031B0:  MOVFF  01,B00
031B4:  MOVLB  B
031B6:  MOVWF  x01
031B8:  MOVFF  AF3,B47
031BC:  MOVFF  AF2,B46
031C0:  MOVFF  AF1,B45
031C4:  MOVFF  AF0,B44
031C8:  MOVWF  x49
031CA:  MOVFF  01,B48
031CE:  MOVLB  0
031D0:  CALL   07CA
.................... 			 
.................... 			gFiles[hFile].CurrentCluster = actcluster; 
031D4:  MOVLB  B
031D6:  CLRF   x62
031D8:  MOVFF  AEF,B61
031DC:  MOVLW  02
031DE:  MOVWF  x64
031E0:  MOVLW  33
031E2:  MOVWF  x63
031E4:  MOVLB  0
031E6:  CALL   039E
031EA:  MOVFF  01,AFE
031EE:  MOVLW  20
031F0:  MOVLB  A
031F2:  ADDWF  01,W
031F4:  MOVWF  01
031F6:  MOVLW  02
031F8:  ADDWFC 02,W
031FA:  MOVWF  03
031FC:  MOVF   01,W
031FE:  ADDLW  70
03200:  MOVWF  FE9
03202:  MOVLW  02
03204:  ADDWFC 03,W
03206:  MOVWF  FEA
03208:  MOVFF  AF4,FEF
0320C:  MOVFF  AF5,FEC
03210:  MOVFF  AF6,FEC
03214:  MOVFF  AF7,FEC
.................... 			gFiles[hFile].posinsector = gFiles[hFile].wFileSize & 0x01FF; 
03218:  MOVLB  B
0321A:  CLRF   x62
0321C:  MOVFF  AEF,B61
03220:  MOVLW  02
03222:  MOVWF  x64
03224:  MOVLW  33
03226:  MOVWF  x63
03228:  MOVLB  0
0322A:  CALL   039E
0322E:  MOVFF  02,AFF
03232:  MOVFF  01,AFE
03236:  MOVLW  25
03238:  MOVLB  A
0323A:  ADDWF  01,W
0323C:  MOVWF  01
0323E:  MOVLW  02
03240:  ADDWFC 02,W
03242:  MOVWF  03
03244:  MOVF   01,W
03246:  ADDLW  70
03248:  MOVWF  01
0324A:  MOVLW  02
0324C:  ADDWFC 03,F
0324E:  MOVFF  01,B00
03252:  MOVLB  B
03254:  MOVFF  03,B01
03258:  CLRF   x62
0325A:  MOVFF  AEF,B61
0325E:  MOVLW  02
03260:  MOVWF  x64
03262:  MOVLW  33
03264:  MOVWF  x63
03266:  MOVLB  0
03268:  CALL   039E
0326C:  MOVFF  02,B03
03270:  MOVFF  01,B02
03274:  MOVLW  27
03276:  MOVLB  B
03278:  ADDWF  01,W
0327A:  MOVWF  01
0327C:  MOVLW  02
0327E:  ADDWFC 02,W
03280:  MOVWF  03
03282:  MOVF   01,W
03284:  ADDLW  70
03286:  MOVWF  FE9
03288:  MOVLW  02
0328A:  ADDWFC 03,W
0328C:  MOVWF  FEA
0328E:  MOVFF  FEF,B04
03292:  MOVFF  FEC,B05
03296:  MOVFF  FEC,B06
0329A:  MOVFF  FEC,B07
0329E:  MOVF   x05,W
032A0:  ANDLW  01
032A2:  MOVFF  B01,FEA
032A6:  MOVFF  B00,FE9
032AA:  MOVFF  B04,FEF
032AE:  MOVWF  FEC
.................... 			 
.................... 			if (gFiles[hFile].posinsector == 0 && gFiles[hFile].wFileSize != 0)  
032B0:  CLRF   x62
032B2:  MOVFF  AEF,B61
032B6:  MOVLW  02
032B8:  MOVWF  x64
032BA:  MOVLW  33
032BC:  MOVWF  x63
032BE:  MOVLB  0
032C0:  CALL   039E
032C4:  MOVFF  02,AFF
032C8:  MOVFF  01,AFE
032CC:  MOVLW  25
032CE:  MOVLB  A
032D0:  ADDWF  01,W
032D2:  MOVWF  01
032D4:  MOVLW  02
032D6:  ADDWFC 02,W
032D8:  MOVWF  03
032DA:  MOVF   01,W
032DC:  ADDLW  70
032DE:  MOVWF  FE9
032E0:  MOVLW  02
032E2:  ADDWFC 03,W
032E4:  MOVWF  FEA
032E6:  MOVFF  FEC,B01
032EA:  MOVF   FED,F
032EC:  MOVFF  FEF,B00
032F0:  MOVLB  B
032F2:  MOVF   x00,F
032F4:  BNZ   338C
032F6:  MOVF   x01,F
032F8:  BNZ   338C
032FA:  CLRF   x62
032FC:  MOVFF  AEF,B61
03300:  MOVLW  02
03302:  MOVWF  x64
03304:  MOVLW  33
03306:  MOVWF  x63
03308:  MOVLB  0
0330A:  CALL   039E
0330E:  MOVFF  02,B03
03312:  MOVFF  01,B02
03316:  MOVLW  27
03318:  MOVLB  B
0331A:  ADDWF  01,W
0331C:  MOVWF  01
0331E:  MOVLW  02
03320:  ADDWFC 02,W
03322:  MOVWF  03
03324:  MOVF   01,W
03326:  ADDLW  70
03328:  MOVWF  FE9
0332A:  MOVLW  02
0332C:  ADDWFC 03,W
0332E:  MOVWF  FEA
03330:  MOVFF  FEF,B04
03334:  MOVFF  FEC,B05
03338:  MOVFF  FEC,B06
0333C:  MOVFF  FEC,B07
03340:  MOVF   x04,F
03342:  BNZ   3350
03344:  MOVF   x05,F
03346:  BNZ   3350
03348:  MOVF   x06,F
0334A:  BNZ   3350
0334C:  MOVF   x07,F
0334E:  BZ    338C
.................... 				gFiles[hFile].posinsector = 512; 
03350:  CLRF   x62
03352:  MOVFF  AEF,B61
03356:  MOVLW  02
03358:  MOVWF  x64
0335A:  MOVLW  33
0335C:  MOVWF  x63
0335E:  MOVLB  0
03360:  CALL   039E
03364:  MOVFF  01,AFE
03368:  MOVLW  25
0336A:  MOVLB  A
0336C:  ADDWF  01,W
0336E:  MOVWF  01
03370:  MOVLW  02
03372:  ADDWFC 02,W
03374:  MOVWF  03
03376:  MOVF   01,W
03378:  ADDLW  70
0337A:  MOVWF  FE9
0337C:  MOVLW  02
0337E:  ADDWFC 03,W
03380:  MOVWF  FEA
03382:  MOVLW  02
03384:  MOVWF  FEC
03386:  MOVF   FED,F
03388:  CLRF   FEF
0338A:  MOVLB  B
.................... 		}  
.................... 		else 	//Write or read only 
0338C:  BRA    3574
0338E:  MOVLB  A
.................... 		{ 
.................... 			gFiles[hFile].wFileSize = 0; 
03390:  MOVLB  B
03392:  CLRF   x62
03394:  MOVFF  AEF,B61
03398:  MOVLW  02
0339A:  MOVWF  x64
0339C:  MOVLW  33
0339E:  MOVWF  x63
033A0:  MOVLB  0
033A2:  CALL   039E
033A6:  MOVFF  01,AFE
033AA:  MOVLW  27
033AC:  MOVLB  A
033AE:  ADDWF  01,W
033B0:  MOVWF  01
033B2:  MOVLW  02
033B4:  ADDWFC 02,W
033B6:  MOVWF  03
033B8:  MOVF   01,W
033BA:  ADDLW  70
033BC:  MOVWF  FE9
033BE:  MOVLW  02
033C0:  ADDWFC 03,W
033C2:  MOVWF  FEA
033C4:  MOVF   FEE,F
033C6:  MOVF   FEE,F
033C8:  CLRF   FEC
033CA:  MOVF   FED,F
033CC:  CLRF   FEF
033CE:  MOVF   FED,F
033D0:  CLRF   FEF
033D2:  MOVF   FED,F
033D4:  CLRF   FEF
.................... 			actsector = ComposeCluster(hFile)*DiskInfo.SecPerClus; 
033D6:  MOVFF  AEF,B14
033DA:  MOVLB  0
033DC:  CALL   1C62
033E0:  MOVFF  03,B01
033E4:  MOVFF  02,B00
033E8:  MOVFF  01,AFF
033EC:  MOVFF  00,AFE
033F0:  MOVFF  FEA,B03
033F4:  MOVFF  FE9,B02
033F8:  MOVFF  03,B3C
033FC:  MOVFF  02,B3B
03400:  MOVFF  01,B3A
03404:  MOVFF  00,B39
03408:  MOVLB  B
0340A:  CLRF   x40
0340C:  CLRF   x3F
0340E:  CLRF   x3E
03410:  MOVFF  24D,B3D
03414:  MOVLB  0
03416:  CALL   08F4
0341A:  MOVFF  B03,FEA
0341E:  MOVFF  B02,FE9
03422:  MOVFF  03,AF3
03426:  MOVFF  02,AF2
0342A:  MOVFF  01,AF1
0342E:  MOVFF  00,AF0
.................... 			actsector += gFAT32Vars.gFirstDataSector; 
03432:  MOVLB  2
03434:  MOVF   x27,W
03436:  MOVLB  A
03438:  ADDWF  xF0,F
0343A:  MOVLB  2
0343C:  MOVF   x28,W
0343E:  MOVLB  A
03440:  ADDWFC xF1,F
03442:  MOVLB  2
03444:  MOVF   x29,W
03446:  MOVLB  A
03448:  ADDWFC xF2,F
0344A:  MOVLB  2
0344C:  MOVF   x2A,W
0344E:  MOVLB  A
03450:  ADDWFC xF3,F
.................... 			ReadSector(actsector,gFiles[hFile].IOpuffer); 
03452:  MOVLB  B
03454:  CLRF   x62
03456:  MOVFF  AEF,B61
0345A:  MOVLW  02
0345C:  MOVWF  x64
0345E:  MOVLW  33
03460:  MOVWF  x63
03462:  MOVLB  0
03464:  CALL   039E
03468:  MOVFF  02,AFF
0346C:  MOVFF  01,AFE
03470:  MOVLW  70
03472:  MOVLB  A
03474:  ADDWF  01,W
03476:  MOVWF  01
03478:  MOVLW  02
0347A:  ADDWFC 02,W
0347C:  MOVWF  03
0347E:  MOVFF  01,B00
03482:  MOVLB  B
03484:  MOVWF  x01
03486:  MOVFF  AF3,B47
0348A:  MOVFF  AF2,B46
0348E:  MOVFF  AF1,B45
03492:  MOVFF  AF0,B44
03496:  MOVWF  x49
03498:  MOVFF  01,B48
0349C:  MOVLB  0
0349E:  CALL   07CA
.................... 			gFiles[hFile].CurrentCluster = ComposeCluster(hFile); 
034A2:  MOVLB  B
034A4:  CLRF   x62
034A6:  MOVFF  AEF,B61
034AA:  MOVLW  02
034AC:  MOVWF  x64
034AE:  MOVLW  33
034B0:  MOVWF  x63
034B2:  MOVLB  0
034B4:  CALL   039E
034B8:  MOVFF  02,AFF
034BC:  MOVFF  01,AFE
034C0:  MOVLW  20
034C2:  MOVLB  A
034C4:  ADDWF  01,W
034C6:  MOVWF  01
034C8:  MOVLW  02
034CA:  ADDWFC 02,W
034CC:  MOVWF  03
034CE:  MOVF   01,W
034D0:  ADDLW  70
034D2:  MOVWF  01
034D4:  MOVLW  02
034D6:  ADDWFC 03,F
034D8:  MOVFF  01,B00
034DC:  MOVFF  03,B01
034E0:  MOVFF  AEF,B14
034E4:  MOVLB  0
034E6:  CALL   1C62
034EA:  MOVFF  B01,FEA
034EE:  MOVFF  B00,FE9
034F2:  MOVFF  00,FEF
034F6:  MOVFF  01,FEC
034FA:  MOVFF  02,FEC
034FE:  MOVFF  03,FEC
.................... 			gFiles[hFile].posinsector = 0; 
03502:  MOVLB  B
03504:  CLRF   x62
03506:  MOVFF  AEF,B61
0350A:  MOVLW  02
0350C:  MOVWF  x64
0350E:  MOVLW  33
03510:  MOVWF  x63
03512:  MOVLB  0
03514:  CALL   039E
03518:  MOVFF  01,AFE
0351C:  MOVLW  25
0351E:  MOVLB  A
03520:  ADDWF  01,W
03522:  MOVWF  01
03524:  MOVLW  02
03526:  ADDWFC 02,W
03528:  MOVWF  03
0352A:  MOVF   01,W
0352C:  ADDLW  70
0352E:  MOVWF  FE9
03530:  MOVLW  02
03532:  ADDWFC 03,W
03534:  MOVWF  FEA
03536:  CLRF   FEC
03538:  MOVF   FED,F
0353A:  CLRF   FEF
.................... 			gFiles[hFile].SecInCluster = 0; 
0353C:  MOVLB  B
0353E:  CLRF   x62
03540:  MOVFF  AEF,B61
03544:  MOVLW  02
03546:  MOVWF  x64
03548:  MOVLW  33
0354A:  MOVWF  x63
0354C:  MOVLB  0
0354E:  CALL   039E
03552:  MOVFF  01,AFE
03556:  MOVLW  24
03558:  MOVLB  A
0355A:  ADDWF  01,W
0355C:  MOVWF  01
0355E:  MOVLW  02
03560:  ADDWFC 02,W
03562:  MOVWF  03
03564:  MOVF   01,W
03566:  ADDLW  70
03568:  MOVWF  FE9
0356A:  MOVLW  02
0356C:  ADDWFC 03,W
0356E:  MOVWF  FEA
03570:  CLRF   FEF
03572:  MOVLB  B
.................... 		} 
.................... 	} 
.................... 	return hFile; 
03574:  MOVLB  A
03576:  MOVFF  AEF,01
0357A:  MOVLB  0
.................... } 
0357C:  GOTO   4D9A (RETURN)
....................  
.................... void fclose(HANDLE hFile) 
.................... { 
.................... #ifdef TRACE 
.................... 	//fprintf(debug, "\r\nfclose()");	 
.................... #endif 
.................... 	//	output_low(YELLOWLED); 
.................... 	if (hFile > (MAXFILES-1)) return; 
*
045C2:  MOVLB  A
045C4:  MOVF   xEB,F
045C6:  BZ    45CA
045C8:  BRA    4686
.................... 	if ((gFiles[hFile].mode == 'a') || (gFiles[hFile].mode == 'w'))  
045CA:  MOVLB  B
045CC:  CLRF   x62
045CE:  MOVFF  AEB,B61
045D2:  MOVLW  02
045D4:  MOVWF  x64
045D6:  MOVLW  33
045D8:  MOVWF  x63
045DA:  MOVLB  0
045DC:  CALL   039E
045E0:  MOVFF  02,AED
045E4:  MOVFF  01,AEC
045E8:  MOVLW  31
045EA:  MOVLB  A
045EC:  ADDWF  01,W
045EE:  MOVWF  01
045F0:  MOVLW  02
045F2:  ADDWFC 02,W
045F4:  MOVWF  03
045F6:  MOVF   01,W
045F8:  ADDLW  70
045FA:  MOVWF  FE9
045FC:  MOVLW  02
045FE:  ADDWFC 03,W
04600:  MOVWF  FEA
04602:  MOVF   FEF,W
04604:  SUBLW  61
04606:  BZ    4646
04608:  MOVLB  B
0460A:  CLRF   x62
0460C:  MOVFF  AEB,B61
04610:  MOVLW  02
04612:  MOVWF  x64
04614:  MOVLW  33
04616:  MOVWF  x63
04618:  MOVLB  0
0461A:  CALL   039E
0461E:  MOVFF  02,AF0
04622:  MOVFF  01,AEF
04626:  MOVLW  31
04628:  MOVLB  A
0462A:  ADDWF  01,W
0462C:  MOVWF  01
0462E:  MOVLW  02
04630:  ADDWFC 02,W
04632:  MOVWF  03
04634:  MOVF   01,W
04636:  ADDLW  70
04638:  MOVWF  FE9
0463A:  MOVLW  02
0463C:  ADDWFC 03,W
0463E:  MOVWF  FEA
04640:  MOVF   FEF,W
04642:  SUBLW  77
04644:  BNZ   464E
.................... 		fflush(hFile); 
04646:  MOVFF  AEB,AEC
0464A:  MOVLB  0
0464C:  BRA    4126
.................... 	gFiles[hFile].Free = TRUE; 
0464E:  MOVLB  B
04650:  CLRF   x62
04652:  MOVFF  AEB,B61
04656:  MOVLW  02
04658:  MOVWF  x64
0465A:  MOVLW  33
0465C:  MOVWF  x63
0465E:  MOVLB  0
04660:  CALL   039E
04664:  MOVFF  01,AEC
04668:  MOVLW  32
0466A:  MOVLB  A
0466C:  ADDWF  01,W
0466E:  MOVWF  01
04670:  MOVLW  02
04672:  ADDWFC 02,W
04674:  MOVWF  03
04676:  MOVF   01,W
04678:  ADDLW  70
0467A:  MOVWF  FE9
0467C:  MOVLW  02
0467E:  ADDWFC 03,W
04680:  MOVWF  FEA
04682:  MOVLW  01
04684:  MOVWF  FEF
.................... } 
04686:  MOVLB  0
04688:  GOTO   4E0E (RETURN)
....................  
.................... void fflush(HANDLE hFile) 
.................... { 
.................... 	int32 actsector; 
.................... 	DIR *pDir; 
....................  
.................... 	if (hFile > (MAXFILES-1))  
*
04126:  MOVLB  A
04128:  MOVF   xEC,F
0412A:  BZ    412E
.................... 		return; 
0412C:  BRA    45BC
.................... 	 
.................... 	//Write data sector 
.................... 	actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
0412E:  MOVLB  B
04130:  CLRF   x62
04132:  MOVFF  AEC,B61
04136:  MOVLW  02
04138:  MOVWF  x64
0413A:  MOVLW  33
0413C:  MOVWF  x63
0413E:  MOVLB  0
04140:  CALL   039E
04144:  MOVFF  02,AF4
04148:  MOVFF  01,AF3
0414C:  MOVLW  20
0414E:  MOVLB  A
04150:  ADDWF  01,W
04152:  MOVWF  01
04154:  MOVLW  02
04156:  ADDWFC 02,W
04158:  MOVWF  03
0415A:  MOVF   01,W
0415C:  ADDLW  70
0415E:  MOVWF  FE9
04160:  MOVLW  02
04162:  ADDWFC 03,W
04164:  MOVWF  FEA
04166:  MOVFF  FEF,AF5
0416A:  MOVFF  FEC,AF6
0416E:  MOVFF  FEC,AF7
04172:  MOVFF  FEC,AF8
04176:  MOVFF  FEA,AFA
0417A:  MOVFF  FE9,AF9
0417E:  MOVFF  AF8,B3C
04182:  MOVFF  AF7,B3B
04186:  MOVFF  AF6,B3A
0418A:  MOVFF  AF5,B39
0418E:  MOVLB  B
04190:  CLRF   x40
04192:  CLRF   x3F
04194:  CLRF   x3E
04196:  MOVFF  24D,B3D
0419A:  MOVLB  0
0419C:  CALL   08F4
041A0:  MOVFF  AFA,FEA
041A4:  MOVFF  AF9,FE9
041A8:  MOVLB  2
041AA:  MOVF   x27,W
041AC:  MOVLB  A
041AE:  ADDWF  00,W
041B0:  MOVWF  xED
041B2:  MOVLB  2
041B4:  MOVF   x28,W
041B6:  MOVLB  A
041B8:  ADDWFC 01,W
041BA:  MOVWF  xEE
041BC:  MOVLB  2
041BE:  MOVF   x29,W
041C0:  MOVLB  A
041C2:  ADDWFC 02,W
041C4:  MOVWF  xEF
041C6:  MOVLB  2
041C8:  MOVF   x2A,W
041CA:  MOVLB  A
041CC:  ADDWFC 03,W
041CE:  MOVWF  xF0
.................... 	actsector += gFiles[hFile].SecInCluster; 
041D0:  MOVLB  B
041D2:  CLRF   x62
041D4:  MOVFF  AEC,B61
041D8:  MOVLW  02
041DA:  MOVWF  x64
041DC:  MOVLW  33
041DE:  MOVWF  x63
041E0:  MOVLB  0
041E2:  CALL   039E
041E6:  MOVFF  01,AF3
041EA:  MOVLW  24
041EC:  MOVLB  A
041EE:  ADDWF  01,W
041F0:  MOVWF  01
041F2:  MOVLW  02
041F4:  ADDWFC 02,W
041F6:  MOVWF  03
041F8:  MOVF   01,W
041FA:  ADDLW  70
041FC:  MOVWF  FE9
041FE:  MOVLW  02
04200:  ADDWFC 03,W
04202:  MOVWF  FEA
04204:  MOVF   FEF,W
04206:  ADDWF  xED,F
04208:  MOVLW  00
0420A:  ADDWFC xEE,F
0420C:  ADDWFC xEF,F
0420E:  ADDWFC xF0,F
.................... 	WriteSector(actsector,gFiles[hFile].IOpuffer); 
04210:  MOVLB  B
04212:  CLRF   x62
04214:  MOVFF  AEC,B61
04218:  MOVLW  02
0421A:  MOVWF  x64
0421C:  MOVLW  33
0421E:  MOVWF  x63
04220:  MOVLB  0
04222:  CALL   039E
04226:  MOVFF  02,AF4
0422A:  MOVFF  01,AF3
0422E:  MOVLW  70
04230:  MOVLB  A
04232:  ADDWF  01,W
04234:  MOVWF  01
04236:  MOVLW  02
04238:  ADDWFC 02,W
0423A:  MOVWF  03
0423C:  MOVFF  01,AF5
04240:  MOVWF  xF6
04242:  MOVFF  AF0,B4B
04246:  MOVFF  AEF,B4A
0424A:  MOVFF  AEE,B49
0424E:  MOVFF  AED,B48
04252:  MOVFF  FE8,B4D
04256:  MOVFF  01,B4C
0425A:  MOVLB  0
0425C:  CALL   1156
.................... 	 
.................... 	if(gFAT32Vars.bFATModified) 
04260:  MOVLB  2
04262:  MOVF   x3F,F
04264:  BZ    426C
.................... 		SaveFATTable(); 
04266:  MOVLB  0
04268:  CALL   1262
.................... 	 
.................... 	//Read dir entry 
.................... 	if(ReadSector(gFiles[hFile].dirSector,gFiles[hFile].IOpuffer) == MMC_NO_ERR) 
0426C:  MOVLB  B
0426E:  CLRF   x62
04270:  MOVFF  AEC,B61
04274:  MOVLW  02
04276:  MOVWF  x64
04278:  MOVLW  33
0427A:  MOVWF  x63
0427C:  MOVLB  0
0427E:  CALL   039E
04282:  MOVFF  02,AF4
04286:  MOVFF  01,AF3
0428A:  MOVLW  2B
0428C:  MOVLB  A
0428E:  ADDWF  01,W
04290:  MOVWF  01
04292:  MOVLW  02
04294:  ADDWFC 02,W
04296:  MOVWF  03
04298:  MOVF   01,W
0429A:  ADDLW  70
0429C:  MOVWF  FE9
0429E:  MOVLW  02
042A0:  ADDWFC 03,W
042A2:  MOVWF  FEA
042A4:  MOVFF  FEF,AF5
042A8:  MOVFF  FEC,AF6
042AC:  MOVFF  FEC,AF7
042B0:  MOVFF  FEC,AF8
042B4:  MOVLB  B
042B6:  CLRF   x62
042B8:  MOVFF  AEC,B61
042BC:  MOVLW  02
042BE:  MOVWF  x64
042C0:  MOVLW  33
042C2:  MOVWF  x63
042C4:  MOVLB  0
042C6:  CALL   039E
042CA:  MOVFF  02,AFA
042CE:  MOVFF  01,AF9
042D2:  MOVLW  70
042D4:  MOVLB  A
042D6:  ADDWF  01,W
042D8:  MOVWF  01
042DA:  MOVLW  02
042DC:  ADDWFC 02,W
042DE:  MOVWF  03
042E0:  MOVFF  01,AFB
042E4:  MOVWF  xFC
042E6:  MOVFF  AF8,B47
042EA:  MOVFF  AF7,B46
042EE:  MOVFF  AF6,B45
042F2:  MOVFF  AF5,B44
042F6:  MOVFF  FE8,B49
042FA:  MOVFF  01,B48
042FE:  MOVLB  0
04300:  CALL   07CA
04304:  MOVF   01,F
04306:  BTFSS  FD8.2
04308:  BRA    456A
.................... 	{ 
.................... 		pDir = (DIR*)(&(gFiles[hFile].IOpuffer[32*gFiles[hFile].dirIdx])); 
0430A:  MOVLB  B
0430C:  CLRF   x62
0430E:  MOVFF  AEC,B61
04312:  MOVLW  02
04314:  MOVWF  x64
04316:  MOVLW  33
04318:  MOVWF  x63
0431A:  MOVLB  0
0431C:  CALL   039E
04320:  MOVFF  02,AF4
04324:  MOVFF  01,AF3
04328:  MOVLB  B
0432A:  CLRF   x62
0432C:  MOVFF  AEC,B61
04330:  MOVLW  02
04332:  MOVWF  x64
04334:  MOVLW  33
04336:  MOVWF  x63
04338:  MOVLB  0
0433A:  CALL   039E
0433E:  MOVFF  02,AF6
04342:  MOVFF  01,AF5
04346:  MOVLW  2F
04348:  MOVLB  A
0434A:  ADDWF  01,W
0434C:  MOVWF  01
0434E:  MOVLW  02
04350:  ADDWFC 02,W
04352:  MOVWF  03
04354:  MOVF   01,W
04356:  ADDLW  70
04358:  MOVWF  FE9
0435A:  MOVLW  02
0435C:  ADDWFC 03,W
0435E:  MOVWF  FEA
04360:  MOVFF  FEC,03
04364:  MOVF   FED,F
04366:  MOVFF  FEF,02
0436A:  RLCF   02,W
0436C:  MOVWF  xF7
0436E:  RLCF   03,W
04370:  MOVWF  xF8
04372:  RLCF   xF7,F
04374:  RLCF   xF8,F
04376:  RLCF   xF7,F
04378:  RLCF   xF8,F
0437A:  RLCF   xF7,F
0437C:  RLCF   xF8,F
0437E:  RLCF   xF7,F
04380:  RLCF   xF8,F
04382:  MOVLW  E0
04384:  ANDWF  xF7,F
04386:  MOVF   xF7,W
04388:  ADDWF  xF3,W
0438A:  MOVWF  01
0438C:  MOVF   xF8,W
0438E:  ADDWFC xF4,W
04390:  MOVWF  03
04392:  MOVF   01,W
04394:  ADDLW  70
04396:  MOVWF  01
04398:  MOVLW  02
0439A:  ADDWFC 03,F
0439C:  MOVFF  01,AF1
043A0:  MOVFF  03,AF2
.................... 	 
.................... 		//Update file size 
.................... 		if (gFiles[hFile].DirEntry.bAttr & 0x10)  
043A4:  MOVLB  B
043A6:  CLRF   x62
043A8:  MOVFF  AEC,B61
043AC:  MOVLW  02
043AE:  MOVWF  x64
043B0:  MOVLW  33
043B2:  MOVWF  x63
043B4:  MOVLB  0
043B6:  CALL   039E
043BA:  MOVFF  02,AF4
043BE:  MOVFF  01,AF3
043C2:  MOVLB  A
043C4:  MOVFF  01,AF5
043C8:  MOVLW  02
043CA:  ADDWF  02,W
043CC:  MOVWF  xF6
043CE:  MOVLW  0B
043D0:  ADDWF  01,W
043D2:  MOVWF  01
043D4:  MOVLW  00
043D6:  ADDWFC xF6,W
043D8:  MOVWF  03
043DA:  MOVF   01,W
043DC:  ADDLW  70
043DE:  MOVWF  FE9
043E0:  MOVLW  02
043E2:  ADDWFC 03,W
043E4:  MOVWF  FEA
043E6:  BTFSS  FEF.4
043E8:  BRA    440A
.................... 			pDir->wSize = 0; // if it is a directory 
043EA:  MOVLW  1C
043EC:  ADDWF  xF1,W
043EE:  MOVWF  FE9
043F0:  MOVLW  00
043F2:  ADDWFC xF2,W
043F4:  MOVWF  FEA
043F6:  MOVF   FEE,F
043F8:  MOVF   FEE,F
043FA:  CLRF   FEC
043FC:  MOVF   FED,F
043FE:  CLRF   FEF
04400:  MOVF   FED,F
04402:  CLRF   FEF
04404:  MOVF   FED,F
04406:  CLRF   FEF
.................... 		else  
04408:  BRA    447C
.................... 			pDir->wSize = gFiles[hFile].wFileSize; 
0440A:  MOVLW  1C
0440C:  ADDWF  xF1,W
0440E:  MOVWF  01
04410:  MOVLW  00
04412:  ADDWFC xF2,W
04414:  MOVWF  03
04416:  MOVFF  01,AF3
0441A:  MOVWF  xF4
0441C:  MOVLB  B
0441E:  CLRF   x62
04420:  MOVFF  AEC,B61
04424:  MOVLW  02
04426:  MOVWF  x64
04428:  MOVLW  33
0442A:  MOVWF  x63
0442C:  MOVLB  0
0442E:  CALL   039E
04432:  MOVFF  02,AF6
04436:  MOVFF  01,AF5
0443A:  MOVLW  27
0443C:  MOVLB  A
0443E:  ADDWF  01,W
04440:  MOVWF  01
04442:  MOVLW  02
04444:  ADDWFC 02,W
04446:  MOVWF  03
04448:  MOVF   01,W
0444A:  ADDLW  70
0444C:  MOVWF  FE9
0444E:  MOVLW  02
04450:  ADDWFC 03,W
04452:  MOVWF  FEA
04454:  MOVFF  FEF,00
04458:  MOVFF  FEC,01
0445C:  MOVFF  FEC,02
04460:  MOVFF  FEC,03
04464:  MOVFF  AF4,FEA
04468:  MOVFF  AF3,FE9
0446C:  MOVFF  00,FEF
04470:  MOVFF  01,FEC
04474:  MOVFF  02,FEC
04478:  MOVFF  03,FEC
....................  
.................... 		//Update file date/time 
.................... 		pDir->hDate = GetCurrentDOSDate(); 
0447C:  MOVLW  18
0447E:  ADDWF  xF1,W
04480:  MOVWF  01
04482:  MOVLW  00
04484:  ADDWFC xF2,W
04486:  MOVWF  03
04488:  MOVFF  01,AF3
0448C:  MOVWF  xF4
0448E:  MOVLB  0
04490:  CALL   2700
04494:  MOVFF  AF4,FEA
04498:  MOVFF  AF3,FE9
0449C:  MOVFF  02,FEC
044A0:  MOVF   FED,F
044A2:  MOVFF  01,FEF
.................... 		pDir->hTime = GetCurrentDOSTime(); 
044A6:  MOVLW  16
044A8:  MOVLB  A
044AA:  ADDWF  xF1,W
044AC:  MOVWF  01
044AE:  MOVLW  00
044B0:  ADDWFC xF2,W
044B2:  MOVWF  03
044B4:  MOVFF  01,AF3
044B8:  MOVWF  xF4
044BA:  MOVLB  0
044BC:  CALL   2754
044C0:  MOVFF  AF4,FEA
044C4:  MOVFF  AF3,FE9
044C8:  MOVFF  02,FEC
044CC:  MOVF   FED,F
044CE:  MOVFF  01,FEF
....................  
.................... 		//Write dir entry 
.................... 		WriteSector(gFiles[hFile].dirSector,gFiles[hFile].IOpuffer); 
044D2:  MOVLB  B
044D4:  CLRF   x62
044D6:  MOVFF  AEC,B61
044DA:  MOVLW  02
044DC:  MOVWF  x64
044DE:  MOVLW  33
044E0:  MOVWF  x63
044E2:  MOVLB  0
044E4:  CALL   039E
044E8:  MOVFF  02,AF4
044EC:  MOVFF  01,AF3
044F0:  MOVLW  2B
044F2:  MOVLB  A
044F4:  ADDWF  01,W
044F6:  MOVWF  01
044F8:  MOVLW  02
044FA:  ADDWFC 02,W
044FC:  MOVWF  03
044FE:  MOVF   01,W
04500:  ADDLW  70
04502:  MOVWF  FE9
04504:  MOVLW  02
04506:  ADDWFC 03,W
04508:  MOVWF  FEA
0450A:  MOVFF  FEF,AF5
0450E:  MOVFF  FEC,AF6
04512:  MOVFF  FEC,AF7
04516:  MOVFF  FEC,AF8
0451A:  MOVLB  B
0451C:  CLRF   x62
0451E:  MOVFF  AEC,B61
04522:  MOVLW  02
04524:  MOVWF  x64
04526:  MOVLW  33
04528:  MOVWF  x63
0452A:  MOVLB  0
0452C:  CALL   039E
04530:  MOVFF  02,AFA
04534:  MOVFF  01,AF9
04538:  MOVLW  70
0453A:  MOVLB  A
0453C:  ADDWF  01,W
0453E:  MOVWF  01
04540:  MOVLW  02
04542:  ADDWFC 02,W
04544:  MOVWF  03
04546:  MOVFF  01,AFB
0454A:  MOVWF  xFC
0454C:  MOVFF  AF8,B4B
04550:  MOVFF  AF7,B4A
04554:  MOVFF  AF6,B49
04558:  MOVFF  AF5,B48
0455C:  MOVFF  FE8,B4D
04560:  MOVFF  01,B4C
04564:  MOVLB  0
04566:  CALL   1156
.................... 	} 
....................  
.................... 	//Read back data sector 
.................... 	ReadSector(actsector,gFiles[hFile].IOpuffer); 
0456A:  MOVLB  B
0456C:  CLRF   x62
0456E:  MOVFF  AEC,B61
04572:  MOVLW  02
04574:  MOVWF  x64
04576:  MOVLW  33
04578:  MOVWF  x63
0457A:  MOVLB  0
0457C:  CALL   039E
04580:  MOVFF  02,AF4
04584:  MOVFF  01,AF3
04588:  MOVLW  70
0458A:  MOVLB  A
0458C:  ADDWF  01,W
0458E:  MOVWF  01
04590:  MOVLW  02
04592:  ADDWFC 02,W
04594:  MOVWF  03
04596:  MOVFF  01,AF5
0459A:  MOVWF  xF6
0459C:  MOVFF  AF0,B47
045A0:  MOVFF  AEF,B46
045A4:  MOVFF  AEE,B45
045A8:  MOVFF  AED,B44
045AC:  MOVFF  FE8,B49
045B0:  MOVFF  01,B48
045B4:  MOVLB  0
045B6:  CALL   07CA
045BA:  MOVLB  A
.................... } 
045BC:  MOVLB  0
045BE:  GOTO   464E (RETURN)
....................  
.................... char cwd(char *fname, HANDLE hFile) 
.................... { 
.................... 	int32 actsector; 
....................  
.................... 	if (hFile > (MAXFILES-1))  
*
01D30:  MOVLB  B
01D32:  MOVF   x0B,F
01D34:  BZ    1D3C
.................... 		return FALSE; // just in case of overaddressing 
01D36:  MOVLW  00
01D38:  MOVWF  01
01D3A:  BRA    1EEE
.................... 	 
.................... 	if (IsSelfDir(fname))  
01D3C:  MOVFF  B0A,B11
01D40:  MOVFF  B09,B10
01D44:  MOVLB  0
01D46:  GOTO   0FE6
01D4A:  MOVF   01,F
01D4C:  BZ    1D58
.................... 		return TRUE; // already in Root dir 
01D4E:  MOVLW  01
01D50:  MOVWF  01
01D52:  MOVLB  B
01D54:  BRA    1EEE
01D56:  MOVLB  0
.................... 	 
.................... 	if (!FindDirEntry(fname,hFile))  
01D58:  MOVFF  B0A,B11
01D5C:  MOVFF  B09,B10
01D60:  MOVFF  B0B,B12
01D64:  RCALL  1588
01D66:  MOVF   01,F
01D68:  BNZ   1D74
.................... 		return FALSE; // not found 
01D6A:  MOVLW  00
01D6C:  MOVWF  01
01D6E:  MOVLB  B
01D70:  BRA    1EEE
01D72:  MOVLB  0
.................... 	 
.................... 	actsector = ComposeCluster(hFile)*DiskInfo.SecPerClus; 
01D74:  MOVFF  B0B,B14
01D78:  RCALL  1C62
01D7A:  MOVFF  03,B13
01D7E:  MOVFF  02,B12
01D82:  MOVFF  01,B11
01D86:  MOVFF  00,B10
01D8A:  MOVFF  FEA,B15
01D8E:  MOVFF  FE9,B14
01D92:  MOVFF  03,B3C
01D96:  MOVFF  02,B3B
01D9A:  MOVFF  01,B3A
01D9E:  MOVFF  00,B39
01DA2:  MOVLB  B
01DA4:  CLRF   x40
01DA6:  CLRF   x3F
01DA8:  CLRF   x3E
01DAA:  MOVFF  24D,B3D
01DAE:  MOVLB  0
01DB0:  CALL   08F4
01DB4:  MOVFF  B15,FEA
01DB8:  MOVFF  B14,FE9
01DBC:  MOVFF  03,B0F
01DC0:  MOVFF  02,B0E
01DC4:  MOVFF  01,B0D
01DC8:  MOVFF  00,B0C
.................... 	actsector += gFAT32Vars.gFirstDataSector; // read current dir 
01DCC:  MOVLB  2
01DCE:  MOVF   x27,W
01DD0:  MOVLB  B
01DD2:  ADDWF  x0C,F
01DD4:  MOVLB  2
01DD6:  MOVF   x28,W
01DD8:  MOVLB  B
01DDA:  ADDWFC x0D,F
01DDC:  MOVLB  2
01DDE:  MOVF   x29,W
01DE0:  MOVLB  B
01DE2:  ADDWFC x0E,F
01DE4:  MOVLB  2
01DE6:  MOVF   x2A,W
01DE8:  MOVLB  B
01DEA:  ADDWFC x0F,F
.................... 	ReadSector(actsector,gFiles[hFile].IOpuffer); 
01DEC:  CLRF   x62
01DEE:  MOVFF  B0B,B61
01DF2:  MOVLW  02
01DF4:  MOVWF  x64
01DF6:  MOVLW  33
01DF8:  MOVWF  x63
01DFA:  MOVLB  0
01DFC:  CALL   039E
01E00:  MOVFF  02,B11
01E04:  MOVFF  01,B10
01E08:  MOVLW  70
01E0A:  MOVLB  B
01E0C:  ADDWF  01,W
01E0E:  MOVWF  01
01E10:  MOVLW  02
01E12:  ADDWFC 02,W
01E14:  MOVWF  03
01E16:  MOVFF  01,B12
01E1A:  MOVWF  x13
01E1C:  MOVFF  B0F,B47
01E20:  MOVFF  B0E,B46
01E24:  MOVFF  B0D,B45
01E28:  MOVFF  B0C,B44
01E2C:  MOVWF  x49
01E2E:  MOVFF  01,B48
01E32:  MOVLB  0
01E34:  CALL   07CA
.................... 	gFAT32Vars.gDirEntrySector = actsector; 
01E38:  MOVFF  B0F,230
01E3C:  MOVFF  B0E,22F
01E40:  MOVFF  B0D,22E
01E44:  MOVFF  B0C,22D
.................... 	gFiles[hFile].dirSector = actsector; 
01E48:  MOVLB  B
01E4A:  CLRF   x62
01E4C:  MOVFF  B0B,B61
01E50:  MOVLW  02
01E52:  MOVWF  x64
01E54:  MOVLW  33
01E56:  MOVWF  x63
01E58:  MOVLB  0
01E5A:  CALL   039E
01E5E:  MOVFF  01,B10
01E62:  MOVLW  2B
01E64:  MOVLB  B
01E66:  ADDWF  01,W
01E68:  MOVWF  01
01E6A:  MOVLW  02
01E6C:  ADDWFC 02,W
01E6E:  MOVWF  03
01E70:  MOVF   01,W
01E72:  ADDLW  70
01E74:  MOVWF  FE9
01E76:  MOVLW  02
01E78:  ADDWFC 03,W
01E7A:  MOVWF  FEA
01E7C:  MOVFF  B0C,FEF
01E80:  MOVFF  B0D,FEC
01E84:  MOVFF  B0E,FEC
01E88:  MOVFF  B0F,FEC
.................... 	gFiles[hFile].CurrentCluster = ComposeCluster(hFile); 
01E8C:  CLRF   x62
01E8E:  MOVFF  B0B,B61
01E92:  MOVLW  02
01E94:  MOVWF  x64
01E96:  MOVLW  33
01E98:  MOVWF  x63
01E9A:  MOVLB  0
01E9C:  CALL   039E
01EA0:  MOVFF  02,B11
01EA4:  MOVFF  01,B10
01EA8:  MOVLW  20
01EAA:  MOVLB  B
01EAC:  ADDWF  01,W
01EAE:  MOVWF  01
01EB0:  MOVLW  02
01EB2:  ADDWFC 02,W
01EB4:  MOVWF  03
01EB6:  MOVF   01,W
01EB8:  ADDLW  70
01EBA:  MOVWF  01
01EBC:  MOVLW  02
01EBE:  ADDWFC 03,F
01EC0:  MOVFF  01,B12
01EC4:  MOVFF  03,B13
01EC8:  MOVFF  B0B,B14
01ECC:  MOVLB  0
01ECE:  RCALL  1C62
01ED0:  MOVFF  B13,FEA
01ED4:  MOVFF  B12,FE9
01ED8:  MOVFF  00,FEF
01EDC:  MOVFF  01,FEC
01EE0:  MOVFF  02,FEC
01EE4:  MOVFF  03,FEC
.................... 	return TRUE; 
01EE8:  MOVLW  01
01EEA:  MOVWF  01
01EEC:  MOVLB  B
.................... } 
01EEE:  MOVLB  0
01EF0:  GOTO   1FF2 (RETURN)
....................  
.................... void fputch(char ch, HANDLE hFile) 
.................... { 
.................... 	int32 nextcluster,actsector; 
....................  
.................... 	if (hFile > (MAXFILES-1))  
.................... 		return; 
.................... 		 
.................... 	//Sector buffer full? Write to disk 
.................... 	if (gFiles[hFile].posinsector >= 512)  
.................... 	{ 
.................... 		//Calculate physical sector# 
.................... 		actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
.................... 		actsector += gFiles[hFile].SecInCluster; 
.................... 		 
.................... 		//Increase sector counter 
.................... 		gFiles[hFile].SecInCluster++; 
.................... 		 
.................... 		//Write to disk 
.................... 		WriteSector(actsector,gFiles[hFile].IOpuffer); 
....................  
....................  
.................... 		//Finished a cluster? Find a free cluster and append it to FAT chain. 
.................... 		if(gFiles[hFile].SecInCluster >= DiskInfo.SecPerClus) 
.................... 		{ 
.................... 			//Get next free cluster 
.................... 			nextcluster = FindFirstFreeCluster(); 
....................  
.................... 			//Is it a valid cluster? 
.................... 			if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
.................... 			{ 
.................... 				//Append new found cluster to FAT chain 
.................... 				SetClusterEntry(gFiles[hFile].CurrentCluster,nextcluster); 
.................... 				SetClusterEntry(nextcluster,0x0FFFFFFF); 
.................... 				 
.................... 				//Calculate phsical sector# 
.................... 				actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
.................... 				 
.................... 				//Read sector into buffer			 
.................... 				ReadSector(actsector,gFiles[hFile].IOpuffer); 
.................... 				 
.................... 				//Clear buffer 
.................... 				memset(gFiles[hFile].IOpuffer, 0, 512); 
.................... 			 
.................... 				//Remember cluster# 
.................... 				gFiles[hFile].CurrentCluster = nextcluster; 
.................... 			} 
.................... 			 
.................... 			//Reset sector (in cluster) counter 
.................... 			gFiles[hFile].SecInCluster = 0; 
.................... 		} 
....................  
.................... 		//Reset byte (in sector) counter 
.................... 		gFiles[hFile].posinsector = 0; 
.................... 	} 
.................... 	 
.................... 	gFiles[hFile].IOpuffer[gFiles[hFile].posinsector] = ch; 
.................... 	gFiles[hFile].posinsector++; 
.................... 	gFiles[hFile].wFileSize++; 
....................  
.................... } 
....................  
.................... void fputstring(char *str, HANDLE hFile) 
.................... { 
....................  
.................... #ifdef TRACE 
.................... //	fprintf(debug, "\r\nfputstring(%s, %d)", str, hFile);	 
.................... #endif 
....................  
.................... 	if (hFile > (MAXFILES-1))  
.................... 		return; 
....................  
.................... 	while(*str) 
.................... 		fputch(*str++,hFile); 
.................... } 
....................  
.................... int16 fread(char *buffer, int16 leng, HANDLE hFile) 
.................... { 
.................... 	int16 i,retv; 
.................... 	char c,v; 
....................  
.................... 	TRACE1("\r\nfread(length=%ld)", leng);	 
....................  
.................... 	if (hFile > (MAXFILES-1)) return 0; 
*
03B88:  MOVLB  A
03B8A:  MOVF   xF5,F
03B8C:  BZ    3B96
03B8E:  MOVLW  00
03B90:  MOVWF  01
03B92:  MOVWF  02
03B94:  BRA    3BF0
.................... 	retv = 0; 
03B96:  CLRF   xF9
03B98:  CLRF   xF8
.................... 	for (i=0;i<leng;i++)  
03B9A:  CLRF   xF7
03B9C:  CLRF   xF6
03B9E:  MOVF   xF7,W
03BA0:  SUBWF  xF4,W
03BA2:  BNC   3BE8
03BA4:  BNZ   3BAC
03BA6:  MOVF   xF3,W
03BA8:  SUBWF  xF6,W
03BAA:  BC    3BE8
.................... 	{ 
.................... 		v = fgetch(&c,hFile); 
03BAC:  MOVLW  0A
03BAE:  MOVWF  xFD
03BB0:  MOVLW  FA
03BB2:  MOVWF  xFC
03BB4:  MOVFF  AF5,AFE
03BB8:  MOVLB  0
03BBA:  RCALL  3580
03BBC:  MOVFF  01,AFB
.................... 		if (v) { 
03BC0:  MOVLB  A
03BC2:  MOVF   xFB,F
03BC4:  BZ    3BDE
.................... 			buffer[i] = c; 
03BC6:  MOVF   xF1,W
03BC8:  ADDWF  xF6,W
03BCA:  MOVWF  FE9
03BCC:  MOVF   xF2,W
03BCE:  ADDWFC xF7,W
03BD0:  MOVWF  FEA
03BD2:  MOVFF  AFA,FEF
.................... 			retv++; 
03BD6:  INCF   xF8,F
03BD8:  BTFSC  FD8.2
03BDA:  INCF   xF9,F
.................... 		} 
.................... 		else break; 
03BDC:  BRA    3BE0
03BDE:  BRA    3BE8
.................... 	} 
03BE0:  INCF   xF6,F
03BE2:  BTFSC  FD8.2
03BE4:  INCF   xF7,F
03BE6:  BRA    3B9E
.................... 	return retv; 
03BE8:  MOVFF  AF8,01
03BEC:  MOVFF  AF9,02
.................... } 
03BF0:  MOVLB  0
03BF2:  RETLW  00
....................  
.................... void fwrite(char *buffer, int16 leng, HANDLE hFile) 
.................... { 
.................... 	int16 i; 
....................  
.................... 	TRACE1("\r\nfwrite(length=%ld)", leng);	 
.................... 	 
.................... 	if (hFile > (MAXFILES-1))  
.................... 		return; 
.................... 		 
.................... 	for (i=0;i<leng;i++) 
.................... 		fputch(buffer[i],hFile); 
....................  
.................... } 
....................  
.................... char fgetch(char *ch,HANDLE hFile) 
.................... { 
.................... 	int32 nextcluster,actsector; 
....................  
.................... 	if (hFile > (MAXFILES-1))  
*
03580:  MOVLB  A
03582:  MOVF   xFE,F
03584:  BZ    358C
.................... 		return FALSE; 
03586:  MOVLW  00
03588:  MOVWF  01
0358A:  BRA    3B84
.................... 	 
.................... 	if (gFiles[hFile].wFileSize >= gFiles[hFile].DirEntry.wSize) //Invalid read pointer 
0358C:  MOVLB  B
0358E:  CLRF   x62
03590:  MOVFF  AFE,B61
03594:  MOVLW  02
03596:  MOVWF  x64
03598:  MOVLW  33
0359A:  MOVWF  x63
0359C:  MOVLB  0
0359E:  CALL   039E
035A2:  MOVFF  02,B08
035A6:  MOVFF  01,B07
035AA:  MOVLW  27
035AC:  MOVLB  B
035AE:  ADDWF  01,W
035B0:  MOVWF  01
035B2:  MOVLW  02
035B4:  ADDWFC 02,W
035B6:  MOVWF  03
035B8:  MOVF   01,W
035BA:  ADDLW  70
035BC:  MOVWF  FE9
035BE:  MOVLW  02
035C0:  ADDWFC 03,W
035C2:  MOVWF  FEA
035C4:  MOVFF  FEF,B09
035C8:  MOVFF  FEC,B0A
035CC:  MOVFF  FEC,B0B
035D0:  MOVFF  FEC,B0C
035D4:  CLRF   x62
035D6:  MOVFF  AFE,B61
035DA:  MOVLW  02
035DC:  MOVWF  x64
035DE:  MOVLW  33
035E0:  MOVWF  x63
035E2:  MOVLB  0
035E4:  CALL   039E
035E8:  MOVFF  02,B0E
035EC:  MOVFF  01,B0D
035F0:  MOVLB  B
035F2:  MOVFF  01,B0F
035F6:  MOVLW  02
035F8:  ADDWF  02,W
035FA:  MOVWF  x10
035FC:  MOVLW  1C
035FE:  ADDWF  01,W
03600:  MOVWF  01
03602:  MOVLW  00
03604:  ADDWFC x10,W
03606:  MOVWF  03
03608:  MOVF   01,W
0360A:  ADDLW  70
0360C:  MOVWF  FE9
0360E:  MOVLW  02
03610:  ADDWFC 03,W
03612:  MOVWF  FEA
03614:  MOVFF  FEF,00
03618:  MOVFF  FEC,01
0361C:  MOVFF  FEC,02
03620:  MOVFF  FEC,03
03624:  MOVF   03,W
03626:  SUBWF  x0C,W
03628:  BNC   364A
0362A:  BNZ   3642
0362C:  MOVF   02,W
0362E:  SUBWF  x0B,W
03630:  BNC   364A
03632:  BNZ   3642
03634:  MOVF   01,W
03636:  SUBWF  x0A,W
03638:  BNC   364A
0363A:  BNZ   3642
0363C:  MOVF   00,W
0363E:  SUBWF  x09,W
03640:  BNC   364A
.................... 		return FALSE; 
03642:  MOVLW  00
03644:  MOVWF  01
03646:  MOVLB  A
03648:  BRA    3B84
.................... 	 
.................... 	*ch = gFiles[hFile].IOpuffer[gFiles[hFile].posinsector]; 
0364A:  MOVFF  AFD,03
0364E:  MOVFF  AFC,B07
03652:  MOVLB  B
03654:  MOVFF  AFD,B08
03658:  CLRF   x62
0365A:  MOVFF  AFE,B61
0365E:  MOVLW  02
03660:  MOVWF  x64
03662:  MOVLW  33
03664:  MOVWF  x63
03666:  MOVLB  0
03668:  CALL   039E
0366C:  MOVFF  02,B0A
03670:  MOVFF  01,B09
03674:  MOVLB  B
03676:  CLRF   x62
03678:  MOVFF  AFE,B61
0367C:  MOVLW  02
0367E:  MOVWF  x64
03680:  MOVLW  33
03682:  MOVWF  x63
03684:  MOVLB  0
03686:  CALL   039E
0368A:  MOVFF  01,B0B
0368E:  MOVLW  25
03690:  MOVLB  B
03692:  ADDWF  01,W
03694:  MOVWF  01
03696:  MOVLW  02
03698:  ADDWFC 02,W
0369A:  MOVWF  03
0369C:  MOVF   01,W
0369E:  ADDLW  70
036A0:  MOVWF  FE9
036A2:  MOVLW  02
036A4:  ADDWFC 03,W
036A6:  MOVWF  FEA
036A8:  MOVFF  FEC,B0E
036AC:  MOVF   FED,F
036AE:  MOVFF  FEF,B0D
036B2:  MOVF   x0D,W
036B4:  ADDWF  x09,W
036B6:  MOVWF  01
036B8:  MOVF   x0E,W
036BA:  ADDWFC x0A,W
036BC:  MOVWF  03
036BE:  MOVF   01,W
036C0:  ADDLW  70
036C2:  MOVWF  FE9
036C4:  MOVLW  02
036C6:  ADDWFC 03,W
036C8:  MOVWF  FEA
036CA:  MOVFF  FEF,B0F
036CE:  MOVFF  B08,FEA
036D2:  MOVFF  B07,FE9
036D6:  MOVFF  B0F,FEF
.................... 	 
.................... 	gFiles[hFile].posinsector++; 
036DA:  CLRF   x62
036DC:  MOVFF  AFE,B61
036E0:  MOVLW  02
036E2:  MOVWF  x64
036E4:  MOVLW  33
036E6:  MOVWF  x63
036E8:  MOVLB  0
036EA:  CALL   039E
036EE:  MOVFF  02,B08
036F2:  MOVFF  01,B07
036F6:  MOVLW  25
036F8:  MOVLB  B
036FA:  ADDWF  01,W
036FC:  MOVWF  01
036FE:  MOVLW  02
03700:  ADDWFC 02,W
03702:  MOVWF  03
03704:  MOVF   01,W
03706:  ADDLW  70
03708:  MOVWF  FE9
0370A:  MOVLW  02
0370C:  ADDWFC 03,W
0370E:  MOVWF  FEA
03710:  MOVLW  01
03712:  ADDWF  FEE,F
03714:  BNC   3718
03716:  INCF   FEF,F
.................... 	gFiles[hFile].wFileSize++; 
03718:  CLRF   x62
0371A:  MOVFF  AFE,B61
0371E:  MOVLW  02
03720:  MOVWF  x64
03722:  MOVLW  33
03724:  MOVWF  x63
03726:  MOVLB  0
03728:  CALL   039E
0372C:  MOVFF  02,B08
03730:  MOVFF  01,B07
03734:  MOVLW  27
03736:  MOVLB  B
03738:  ADDWF  01,W
0373A:  MOVWF  01
0373C:  MOVLW  02
0373E:  ADDWFC 02,W
03740:  MOVWF  03
03742:  MOVF   01,W
03744:  ADDLW  70
03746:  MOVWF  FE9
03748:  MOVLW  02
0374A:  ADDWFC 03,W
0374C:  MOVWF  FEA
0374E:  MOVLW  01
03750:  ADDWF  FEE,F
03752:  BNZ   375E
03754:  INCF   FEE,F
03756:  BNZ   375E
03758:  INCF   FEE,F
0375A:  BNZ   375E
0375C:  INCF   FED,F
.................... 	 
.................... 	if (gFiles[hFile].posinsector >= 512)  
0375E:  CLRF   x62
03760:  MOVFF  AFE,B61
03764:  MOVLW  02
03766:  MOVWF  x64
03768:  MOVLW  33
0376A:  MOVWF  x63
0376C:  MOVLB  0
0376E:  CALL   039E
03772:  MOVFF  02,B08
03776:  MOVFF  01,B07
0377A:  MOVLW  25
0377C:  MOVLB  B
0377E:  ADDWF  01,W
03780:  MOVWF  01
03782:  MOVLW  02
03784:  ADDWFC 02,W
03786:  MOVWF  03
03788:  MOVF   01,W
0378A:  ADDLW  70
0378C:  MOVWF  FE9
0378E:  MOVLW  02
03790:  ADDWFC 03,W
03792:  MOVWF  FEA
03794:  MOVFF  FEC,B0A
03798:  MOVF   FED,F
0379A:  MOVFF  FEF,B09
0379E:  MOVF   x0A,W
037A0:  SUBLW  01
037A2:  BTFSC  FD8.0
037A4:  BRA    3B7E
.................... 	{ 
.................... 		//More sector in cluster? 
.................... 		gFiles[hFile].SecInCluster++;  
037A6:  CLRF   x62
037A8:  MOVFF  AFE,B61
037AC:  MOVLW  02
037AE:  MOVWF  x64
037B0:  MOVLW  33
037B2:  MOVWF  x63
037B4:  MOVLB  0
037B6:  CALL   039E
037BA:  MOVFF  01,B07
037BE:  MOVLW  24
037C0:  MOVLB  B
037C2:  ADDWF  01,W
037C4:  MOVWF  01
037C6:  MOVLW  02
037C8:  ADDWFC 02,W
037CA:  MOVWF  03
037CC:  MOVF   01,W
037CE:  ADDLW  70
037D0:  MOVWF  FE9
037D2:  MOVLW  02
037D4:  ADDWFC 03,W
037D6:  MOVWF  FEA
037D8:  INCF   FEF,F
.................... 		if(gFiles[hFile].SecInCluster < DiskInfo.SecPerClus)	//Get next sector incluster 
037DA:  CLRF   x62
037DC:  MOVFF  AFE,B61
037E0:  MOVLW  02
037E2:  MOVWF  x64
037E4:  MOVLW  33
037E6:  MOVWF  x63
037E8:  MOVLB  0
037EA:  CALL   039E
037EE:  MOVFF  02,B08
037F2:  MOVFF  01,B07
037F6:  MOVLW  24
037F8:  MOVLB  B
037FA:  ADDWF  01,W
037FC:  MOVWF  01
037FE:  MOVLW  02
03800:  ADDWFC 02,W
03802:  MOVWF  03
03804:  MOVF   01,W
03806:  ADDLW  70
03808:  MOVWF  FE9
0380A:  MOVLW  02
0380C:  ADDWFC 03,W
0380E:  MOVWF  FEA
03810:  MOVLB  2
03812:  MOVF   x4D,W
03814:  SUBWF  FEF,W
03816:  BTFSC  FD8.0
03818:  BRA    3982
.................... 		{ 
.................... 			actsector = gFiles[hFile].CurrentCluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
0381A:  MOVLB  B
0381C:  CLRF   x62
0381E:  MOVFF  AFE,B61
03822:  MOVLW  02
03824:  MOVWF  x64
03826:  MOVLW  33
03828:  MOVWF  x63
0382A:  MOVLB  0
0382C:  CALL   039E
03830:  MOVFF  02,B08
03834:  MOVFF  01,B07
03838:  MOVLW  20
0383A:  MOVLB  B
0383C:  ADDWF  01,W
0383E:  MOVWF  01
03840:  MOVLW  02
03842:  ADDWFC 02,W
03844:  MOVWF  03
03846:  MOVF   01,W
03848:  ADDLW  70
0384A:  MOVWF  FE9
0384C:  MOVLW  02
0384E:  ADDWFC 03,W
03850:  MOVWF  FEA
03852:  MOVFF  FEF,B09
03856:  MOVFF  FEC,B0A
0385A:  MOVFF  FEC,B0B
0385E:  MOVFF  FEC,B0C
03862:  MOVFF  FEA,B0E
03866:  MOVFF  FE9,B0D
0386A:  MOVFF  B0C,B3C
0386E:  MOVFF  B0B,B3B
03872:  MOVFF  B0A,B3A
03876:  MOVFF  B09,B39
0387A:  CLRF   x40
0387C:  CLRF   x3F
0387E:  CLRF   x3E
03880:  MOVFF  24D,B3D
03884:  MOVLB  0
03886:  CALL   08F4
0388A:  MOVFF  B0E,FEA
0388E:  MOVFF  B0D,FE9
03892:  MOVLB  2
03894:  MOVF   x27,W
03896:  MOVLB  B
03898:  ADDWF  00,W
0389A:  MOVWF  x03
0389C:  MOVLB  2
0389E:  MOVF   x28,W
038A0:  MOVLB  B
038A2:  ADDWFC 01,W
038A4:  MOVWF  x04
038A6:  MOVLB  2
038A8:  MOVF   x29,W
038AA:  MOVLB  B
038AC:  ADDWFC 02,W
038AE:  MOVWF  x05
038B0:  MOVLB  2
038B2:  MOVF   x2A,W
038B4:  MOVLB  B
038B6:  ADDWFC 03,W
038B8:  MOVWF  x06
.................... 			actsector += gFiles[hFile].SecInCluster; 
038BA:  CLRF   x62
038BC:  MOVFF  AFE,B61
038C0:  MOVLW  02
038C2:  MOVWF  x64
038C4:  MOVLW  33
038C6:  MOVWF  x63
038C8:  MOVLB  0
038CA:  CALL   039E
038CE:  MOVFF  01,B07
038D2:  MOVLW  24
038D4:  MOVLB  B
038D6:  ADDWF  01,W
038D8:  MOVWF  01
038DA:  MOVLW  02
038DC:  ADDWFC 02,W
038DE:  MOVWF  03
038E0:  MOVF   01,W
038E2:  ADDLW  70
038E4:  MOVWF  FE9
038E6:  MOVLW  02
038E8:  ADDWFC 03,W
038EA:  MOVWF  FEA
038EC:  MOVF   FEF,W
038EE:  ADDWF  x03,F
038F0:  MOVLW  00
038F2:  ADDWFC x04,F
038F4:  ADDWFC x05,F
038F6:  ADDWFC x06,F
.................... 			ReadSector(actsector,gFiles[hFile].IOpuffer); 
038F8:  CLRF   x62
038FA:  MOVFF  AFE,B61
038FE:  MOVLW  02
03900:  MOVWF  x64
03902:  MOVLW  33
03904:  MOVWF  x63
03906:  MOVLB  0
03908:  CALL   039E
0390C:  MOVFF  02,B08
03910:  MOVFF  01,B07
03914:  MOVLW  70
03916:  MOVLB  B
03918:  ADDWF  01,W
0391A:  MOVWF  01
0391C:  MOVLW  02
0391E:  ADDWFC 02,W
03920:  MOVWF  03
03922:  MOVFF  01,B09
03926:  MOVWF  x0A
03928:  MOVFF  B06,B47
0392C:  MOVFF  B05,B46
03930:  MOVFF  B04,B45
03934:  MOVFF  B03,B44
03938:  MOVWF  x49
0393A:  MOVFF  01,B48
0393E:  MOVLB  0
03940:  CALL   07CA
.................... 			gFiles[hFile].posinsector = 0; 
03944:  MOVLB  B
03946:  CLRF   x62
03948:  MOVFF  AFE,B61
0394C:  MOVLW  02
0394E:  MOVWF  x64
03950:  MOVLW  33
03952:  MOVWF  x63
03954:  MOVLB  0
03956:  CALL   039E
0395A:  MOVFF  01,B07
0395E:  MOVLW  25
03960:  MOVLB  B
03962:  ADDWF  01,W
03964:  MOVWF  01
03966:  MOVLW  02
03968:  ADDWFC 02,W
0396A:  MOVWF  03
0396C:  MOVF   01,W
0396E:  ADDLW  70
03970:  MOVWF  FE9
03972:  MOVLW  02
03974:  ADDWFC 03,W
03976:  MOVWF  FEA
03978:  CLRF   FEC
0397A:  MOVF   FED,F
0397C:  CLRF   FEF
.................... 		} 
.................... 		else	//Get next cluster 
0397E:  BRA    3B7E
03980:  MOVLB  2
.................... 		{ 
.................... 			gFiles[hFile].SecInCluster = 0; 
03982:  MOVLB  B
03984:  CLRF   x62
03986:  MOVFF  AFE,B61
0398A:  MOVLW  02
0398C:  MOVWF  x64
0398E:  MOVLW  33
03990:  MOVWF  x63
03992:  MOVLB  0
03994:  CALL   039E
03998:  MOVFF  01,B07
0399C:  MOVLW  24
0399E:  MOVLB  B
039A0:  ADDWF  01,W
039A2:  MOVWF  01
039A4:  MOVLW  02
039A6:  ADDWFC 02,W
039A8:  MOVWF  03
039AA:  MOVF   01,W
039AC:  ADDLW  70
039AE:  MOVWF  FE9
039B0:  MOVLW  02
039B2:  ADDWFC 03,W
039B4:  MOVWF  FEA
039B6:  CLRF   FEF
.................... 			nextcluster = GetNextCluster(gFiles[hFile].CurrentCluster); 
039B8:  CLRF   x62
039BA:  MOVFF  AFE,B61
039BE:  MOVLW  02
039C0:  MOVWF  x64
039C2:  MOVLW  33
039C4:  MOVWF  x63
039C6:  MOVLB  0
039C8:  CALL   039E
039CC:  MOVFF  02,B08
039D0:  MOVFF  01,B07
039D4:  MOVLW  20
039D6:  MOVLB  B
039D8:  ADDWF  01,W
039DA:  MOVWF  01
039DC:  MOVLW  02
039DE:  ADDWFC 02,W
039E0:  MOVWF  03
039E2:  MOVF   01,W
039E4:  ADDLW  70
039E6:  MOVWF  FE9
039E8:  MOVLW  02
039EA:  ADDWFC 03,W
039EC:  MOVWF  FEA
039EE:  MOVFF  FEF,B09
039F2:  MOVFF  FEC,B0A
039F6:  MOVFF  FEC,B0B
039FA:  MOVFF  FEC,B0C
039FE:  MOVFF  B0C,B3A
03A02:  MOVFF  B0B,B39
03A06:  MOVFF  B0A,B38
03A0A:  MOVFF  B09,B37
03A0E:  MOVLB  0
03A10:  CALL   1316
03A14:  MOVFF  03,B02
03A18:  MOVFF  02,B01
03A1C:  MOVFF  01,B00
03A20:  MOVFF  00,AFF
.................... 			if (nextcluster != 0x0FFFFFFF && nextcluster != 0)  
03A24:  MOVLB  A
03A26:  INCFSZ xFF,W
03A28:  BRA    3A4A
03A2A:  MOVLB  B
03A2C:  INCFSZ x00,W
03A2E:  BRA    3A32
03A30:  BRA    3A36
03A32:  MOVLB  A
03A34:  BRA    3A4A
03A36:  INCFSZ x01,W
03A38:  BRA    3A3C
03A3A:  BRA    3A40
03A3C:  MOVLB  A
03A3E:  BRA    3A4A
03A40:  MOVF   x02,W
03A42:  SUBLW  0F
03A44:  BTFSC  FD8.2
03A46:  BRA    3B7E
03A48:  MOVLB  A
03A4A:  MOVF   xFF,F
03A4C:  BNZ   3A6C
03A4E:  MOVLB  B
03A50:  MOVF   x00,F
03A52:  BTFSC  FD8.2
03A54:  BRA    3A5A
03A56:  MOVLB  A
03A58:  BRA    3A6C
03A5A:  MOVF   x01,F
03A5C:  BTFSC  FD8.2
03A5E:  BRA    3A64
03A60:  MOVLB  A
03A62:  BRA    3A6C
03A64:  MOVF   x02,F
03A66:  BTFSC  FD8.2
03A68:  BRA    3B7E
03A6A:  MOVLB  A
.................... 			{ 
.................... 				actsector = nextcluster*DiskInfo.SecPerClus + gFAT32Vars.gFirstDataSector; 
03A6C:  MOVFF  B02,B3C
03A70:  MOVFF  B01,B3B
03A74:  MOVFF  B00,B3A
03A78:  MOVFF  AFF,B39
03A7C:  MOVLB  B
03A7E:  CLRF   x40
03A80:  CLRF   x3F
03A82:  CLRF   x3E
03A84:  MOVFF  24D,B3D
03A88:  MOVLB  0
03A8A:  CALL   08F4
03A8E:  MOVLB  2
03A90:  MOVF   x27,W
03A92:  MOVLB  B
03A94:  ADDWF  00,W
03A96:  MOVWF  x03
03A98:  MOVLB  2
03A9A:  MOVF   x28,W
03A9C:  MOVLB  B
03A9E:  ADDWFC 01,W
03AA0:  MOVWF  x04
03AA2:  MOVLB  2
03AA4:  MOVF   x29,W
03AA6:  MOVLB  B
03AA8:  ADDWFC 02,W
03AAA:  MOVWF  x05
03AAC:  MOVLB  2
03AAE:  MOVF   x2A,W
03AB0:  MOVLB  B
03AB2:  ADDWFC 03,W
03AB4:  MOVWF  x06
.................... 				ReadSector(actsector,gFiles[hFile].IOpuffer); 
03AB6:  CLRF   x62
03AB8:  MOVFF  AFE,B61
03ABC:  MOVLW  02
03ABE:  MOVWF  x64
03AC0:  MOVLW  33
03AC2:  MOVWF  x63
03AC4:  MOVLB  0
03AC6:  CALL   039E
03ACA:  MOVFF  02,B08
03ACE:  MOVFF  01,B07
03AD2:  MOVLW  70
03AD4:  MOVLB  B
03AD6:  ADDWF  01,W
03AD8:  MOVWF  01
03ADA:  MOVLW  02
03ADC:  ADDWFC 02,W
03ADE:  MOVWF  03
03AE0:  MOVFF  01,B09
03AE4:  MOVWF  x0A
03AE6:  MOVFF  B06,B47
03AEA:  MOVFF  B05,B46
03AEE:  MOVFF  B04,B45
03AF2:  MOVFF  B03,B44
03AF6:  MOVWF  x49
03AF8:  MOVFF  01,B48
03AFC:  MOVLB  0
03AFE:  CALL   07CA
.................... 				gFiles[hFile].CurrentCluster = nextcluster; 
03B02:  MOVLB  B
03B04:  CLRF   x62
03B06:  MOVFF  AFE,B61
03B0A:  MOVLW  02
03B0C:  MOVWF  x64
03B0E:  MOVLW  33
03B10:  MOVWF  x63
03B12:  MOVLB  0
03B14:  CALL   039E
03B18:  MOVFF  01,B07
03B1C:  MOVLW  20
03B1E:  MOVLB  B
03B20:  ADDWF  01,W
03B22:  MOVWF  01
03B24:  MOVLW  02
03B26:  ADDWFC 02,W
03B28:  MOVWF  03
03B2A:  MOVF   01,W
03B2C:  ADDLW  70
03B2E:  MOVWF  FE9
03B30:  MOVLW  02
03B32:  ADDWFC 03,W
03B34:  MOVWF  FEA
03B36:  MOVFF  AFF,FEF
03B3A:  MOVFF  B00,FEC
03B3E:  MOVFF  B01,FEC
03B42:  MOVFF  B02,FEC
.................... 				gFiles[hFile].posinsector = 0; 
03B46:  CLRF   x62
03B48:  MOVFF  AFE,B61
03B4C:  MOVLW  02
03B4E:  MOVWF  x64
03B50:  MOVLW  33
03B52:  MOVWF  x63
03B54:  MOVLB  0
03B56:  CALL   039E
03B5A:  MOVFF  01,B07
03B5E:  MOVLW  25
03B60:  MOVLB  B
03B62:  ADDWF  01,W
03B64:  MOVWF  01
03B66:  MOVLW  02
03B68:  ADDWFC 02,W
03B6A:  MOVWF  03
03B6C:  MOVF   01,W
03B6E:  ADDLW  70
03B70:  MOVWF  FE9
03B72:  MOVLW  02
03B74:  ADDWFC 03,W
03B76:  MOVWF  FEA
03B78:  CLRF   FEC
03B7A:  MOVF   FED,F
03B7C:  CLRF   FEF
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	return TRUE; 
03B7E:  MOVLW  01
03B80:  MOVWF  01
03B82:  MOVLB  A
.................... } 
03B84:  MOVLB  0
03B86:  RETLW  00
....................  
.................... char remove(char *fname) 
.................... { 
.................... 	char i,found; 
.................... 	HANDLE hFile; 
.................... 	DIR *pDir; 
.................... 	int32 nextcluster,currentcluster; 
.................... 	char *filename; 
....................  
.................... 	filename = TryFile(fname,&hFile); 
*
048B0:  MOVFF  AEC,AFF
048B4:  MOVFF  AEB,AFE
048B8:  MOVLW  0A
048BA:  MOVLB  B
048BC:  MOVWF  x01
048BE:  MOVLW  EF
048C0:  MOVWF  x00
048C2:  MOVLB  0
048C4:  CALL   1EF4
048C8:  MOVFF  02,AFB
048CC:  MOVFF  01,AFA
.................... 	if (filename == 0) return FALSE; 
048D0:  MOVLB  A
048D2:  MOVF   xFA,F
048D4:  BNZ   48E0
048D6:  MOVF   xFB,F
048D8:  BNZ   48E0
048DA:  MOVLW  00
048DC:  MOVWF  01
048DE:  BRA    4B32
.................... 	found = FindDirEntry(filename,hFile); 
048E0:  MOVFF  AFB,B11
048E4:  MOVFF  AFA,B10
048E8:  MOVFF  AEF,B12
048EC:  MOVLB  0
048EE:  CALL   1588
048F2:  MOVFF  01,AEE
.................... 	if (!found) { 
048F6:  MOVLB  A
048F8:  MOVF   xEE,F
048FA:  BNZ   493A
.................... 		gFiles[hFile].Free = TRUE; 
048FC:  MOVLB  B
048FE:  CLRF   x62
04900:  MOVFF  AEF,B61
04904:  MOVLW  02
04906:  MOVWF  x64
04908:  MOVLW  33
0490A:  MOVWF  x63
0490C:  MOVLB  0
0490E:  CALL   039E
04912:  MOVFF  01,AFC
04916:  MOVLW  32
04918:  MOVLB  A
0491A:  ADDWF  01,W
0491C:  MOVWF  01
0491E:  MOVLW  02
04920:  ADDWFC 02,W
04922:  MOVWF  03
04924:  MOVF   01,W
04926:  ADDLW  70
04928:  MOVWF  FE9
0492A:  MOVLW  02
0492C:  ADDWFC 03,W
0492E:  MOVWF  FEA
04930:  MOVLW  01
04932:  MOVWF  FEF
.................... 		return FALSE; 
04934:  MOVLW  00
04936:  MOVWF  01
04938:  BRA    4B32
.................... 	} 
.................... 	pDir = (DIR*)(&(gFiles[hFile].IOpuffer[32*gFAT32Vars.gDirEntryIdx])); 
0493A:  MOVLB  B
0493C:  CLRF   x62
0493E:  MOVFF  AEF,B61
04942:  MOVLW  02
04944:  MOVWF  x64
04946:  MOVLW  33
04948:  MOVWF  x63
0494A:  MOVLB  0
0494C:  CALL   039E
04950:  MOVFF  01,AFC
04954:  MOVLB  2
04956:  RLCF   x2B,W
04958:  MOVLB  A
0495A:  MOVWF  xFE
0495C:  MOVLB  2
0495E:  RLCF   x2C,W
04960:  MOVLB  A
04962:  MOVWF  xFF
04964:  RLCF   xFE,F
04966:  RLCF   xFF,F
04968:  RLCF   xFE,F
0496A:  RLCF   xFF,F
0496C:  RLCF   xFE,F
0496E:  RLCF   xFF,F
04970:  RLCF   xFE,F
04972:  RLCF   xFF,F
04974:  MOVLW  E0
04976:  ANDWF  xFE,F
04978:  MOVF   xFE,W
0497A:  ADDWF  01,W
0497C:  MOVWF  01
0497E:  MOVF   xFF,W
04980:  ADDWFC 02,W
04982:  MOVWF  03
04984:  MOVF   01,W
04986:  ADDLW  70
04988:  MOVWF  01
0498A:  MOVLW  02
0498C:  ADDWFC 03,F
0498E:  MOVFF  01,AF0
04992:  MOVFF  03,AF1
.................... 	pDir->sName[0] = 0xE5; 
04996:  MOVFF  AF0,FE9
0499A:  MOVFF  AF1,FEA
0499E:  MOVLW  E5
049A0:  MOVWF  FEF
.................... 	for (i=1;i<8;i++) 
049A2:  MOVLW  01
049A4:  MOVWF  xED
049A6:  MOVF   xED,W
049A8:  SUBLW  07
049AA:  BNC   49C2
.................... 		pDir->sName[i] = ' '; 
049AC:  CLRF   03
049AE:  MOVF   xED,W
049B0:  ADDWF  xF0,W
049B2:  MOVWF  FE9
049B4:  MOVF   xF1,W
049B6:  ADDWFC 03,W
049B8:  MOVWF  FEA
049BA:  MOVLW  20
049BC:  MOVWF  FEF
049BE:  INCF   xED,F
049C0:  BRA    49A6
.................... 	for (i=0;i<3;i++) 
049C2:  CLRF   xED
049C4:  MOVF   xED,W
049C6:  SUBLW  02
049C8:  BNC   49EA
.................... 		pDir->sExt[i] = ' '; 
049CA:  CLRF   03
049CC:  MOVF   xED,W
049CE:  ADDLW  08
049D0:  MOVWF  01
049D2:  MOVLW  00
049D4:  ADDWFC 03,F
049D6:  MOVF   01,W
049D8:  ADDWF  xF0,W
049DA:  MOVWF  FE9
049DC:  MOVF   xF1,W
049DE:  ADDWFC 03,W
049E0:  MOVWF  FEA
049E2:  MOVLW  20
049E4:  MOVWF  FEF
049E6:  INCF   xED,F
049E8:  BRA    49C4
.................... 	WriteSector(gFAT32Vars.gDirEntrySector,gFiles[hFile].IOpuffer); 
049EA:  MOVLB  B
049EC:  CLRF   x62
049EE:  MOVFF  AEF,B61
049F2:  MOVLW  02
049F4:  MOVWF  x64
049F6:  MOVLW  33
049F8:  MOVWF  x63
049FA:  MOVLB  0
049FC:  CALL   039E
04A00:  MOVFF  02,AFD
04A04:  MOVFF  01,AFC
04A08:  MOVLW  70
04A0A:  MOVLB  A
04A0C:  ADDWF  01,W
04A0E:  MOVWF  01
04A10:  MOVLW  02
04A12:  ADDWFC 02,W
04A14:  MOVWF  03
04A16:  MOVFF  01,AFE
04A1A:  MOVWF  xFF
04A1C:  MOVFF  230,B4B
04A20:  MOVFF  22F,B4A
04A24:  MOVFF  22E,B49
04A28:  MOVFF  22D,B48
04A2C:  MOVFF  FE8,B4D
04A30:  MOVFF  01,B4C
04A34:  MOVLB  0
04A36:  CALL   1156
.................... 	currentcluster = ComposeCluster(hFile); 
04A3A:  MOVFF  AEF,B14
04A3E:  CALL   1C62
04A42:  MOVFF  03,AF9
04A46:  MOVFF  02,AF8
04A4A:  MOVFF  01,AF7
04A4E:  MOVFF  00,AF6
.................... 	while (currentcluster != 0x0FFFFFFF && nextcluster != 0)  
.................... 	{ 
04A52:  MOVLB  A
04A54:  INCFSZ xF6,W
04A56:  BRA    4A66
04A58:  INCFSZ xF7,W
04A5A:  BRA    4A66
04A5C:  INCFSZ xF8,W
04A5E:  BRA    4A66
04A60:  MOVF   xF9,W
04A62:  SUBLW  0F
04A64:  BZ    4AC0
04A66:  MOVF   xF2,F
04A68:  BNZ   4A76
04A6A:  MOVF   xF3,F
04A6C:  BNZ   4A76
04A6E:  MOVF   xF4,F
04A70:  BNZ   4A76
04A72:  MOVF   xF5,F
04A74:  BZ    4AC0
.................... 		nextcluster = GetNextCluster(currentcluster); 
04A76:  MOVFF  AF9,B3A
04A7A:  MOVFF  AF8,B39
04A7E:  MOVFF  AF7,B38
04A82:  MOVFF  AF6,B37
04A86:  MOVLB  0
04A88:  CALL   1316
04A8C:  MOVFF  03,AF5
04A90:  MOVFF  02,AF4
04A94:  MOVFF  01,AF3
04A98:  MOVFF  00,AF2
.................... 		ClearClusterEntry(currentcluster); 
04A9C:  MOVFF  AF9,AFF
04AA0:  MOVFF  AF8,AFE
04AA4:  MOVFF  AF7,AFD
04AA8:  MOVFF  AF6,AFC
04AAC:  RCALL  468C
.................... 		currentcluster = nextcluster; 
04AAE:  MOVFF  AF5,AF9
04AB2:  MOVFF  AF4,AF8
04AB6:  MOVFF  AF3,AF7
04ABA:  MOVFF  AF2,AF6
.................... 	} 
04ABE:  BRA    4A52
.................... 	ClearClusterEntry(currentcluster); 
04AC0:  MOVFF  AF9,AFF
04AC4:  MOVFF  AF8,AFE
04AC8:  MOVFF  AF7,AFD
04ACC:  MOVFF  AF6,AFC
04AD0:  MOVLB  0
04AD2:  RCALL  468C
.................... 	SetClusterEntry(currentcluster,0); 
04AD4:  MOVFF  AF9,B18
04AD8:  MOVFF  AF8,B17
04ADC:  MOVFF  AF7,B16
04AE0:  MOVFF  AF6,B15
04AE4:  MOVLB  B
04AE6:  CLRF   x1C
04AE8:  CLRF   x1B
04AEA:  CLRF   x1A
04AEC:  CLRF   x19
04AEE:  MOVLB  0
04AF0:  CALL   2412
.................... 	SaveFATTable(); 
04AF4:  CALL   1262
.................... //	currentcluster = gFAT32Vars.gStartSector+DiskInfo.RsvdSecCnt + gFAT32Vars.FATstartidx; 
.................... //	WriteSector(currentcluster,FATTable.FAT32); 
.................... //	currentcluster += DiskInfo.FATSz32; 
.................... //	WriteSector(currentcluster,FATTable.FAT32); 
.................... 	gFiles[hFile].Free = TRUE; 
04AF8:  MOVLB  B
04AFA:  CLRF   x62
04AFC:  MOVFF  AEF,B61
04B00:  MOVLW  02
04B02:  MOVWF  x64
04B04:  MOVLW  33
04B06:  MOVWF  x63
04B08:  MOVLB  0
04B0A:  CALL   039E
04B0E:  MOVFF  01,AFC
04B12:  MOVLW  32
04B14:  MOVLB  A
04B16:  ADDWF  01,W
04B18:  MOVWF  01
04B1A:  MOVLW  02
04B1C:  ADDWFC 02,W
04B1E:  MOVWF  03
04B20:  MOVF   01,W
04B22:  ADDLW  70
04B24:  MOVWF  FE9
04B26:  MOVLW  02
04B28:  ADDWFC 03,W
04B2A:  MOVWF  FEA
04B2C:  MOVLW  01
04B2E:  MOVWF  FEF
.................... 	return TRUE; 
04B30:  MOVWF  01
.................... } 
04B32:  MOVLB  0
04B34:  GOTO   4E1C (RETURN)
....................  
.................... char getfsize(char *fname, int32 *fsiz) 
.................... { 
.................... 	char found; 
.................... 	HANDLE hFile; 
.................... 	DIR *pDir; 
.................... 	char *filename; 
....................  
.................... 	*fsiz = 0; 
.................... 	filename = TryFile(fname,&hFile); 
.................... 	if (filename == 0)  
.................... 		return 1; 
....................  
.................... 	found = FindDirEntry(filename,hFile); 
.................... 	if (!found)  
.................... 	{ 
.................... 		gFiles[hFile].Free = TRUE; 
.................... 		return 2; 
.................... 	} 
.................... 	//fprintf(debug, "getfsize - found DirEntry %lu.\r\n", gFAT32Vars.gDirEntryIdx); 
.................... 	 
.................... 	pDir = (DIR*)(&(gFiles[hFile].IOpuffer[32*gFAT32Vars.gDirEntryIdx])); 
.................... 	gFiles[hFile].Free = TRUE; 
.................... 	*fsiz = pDir->wSize; 
.................... 	return 0; 
.................... } 
....................  
....................  
....................  
.................... HANDLE hFile=0xff; 
.................... char gfilename[32]; 
....................  
.................... #define BUFFER_BIN_BLOCK	1024	//minimum 64 
.................... //#define BUFFER_HEX_LINE		64 
.................... //BYTE gBuffer[BUFFER_HEX_LINE]; 
.................... BYTE gBinBlock[BUFFER_BIN_BLOCK]; 
.................... int32 gBlockAddr; 
.................... int16 gBlockWritePtr; 
....................  
.................... #include "3310lcd.c" 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... /* 
....................  
.................... 							CompactFlash MP3 Player with PIC16F877L(PLCC) VS1001K LPH7779-LCD(Nokia 3310) 
....................  
.................... 			Design & programming by Raphael Abrams 2002-2003 --- http://www.walrus.com/~raphael/html/mp3.html --- raphael@walrus.com 
....................  
.................... 					LCD interface by Michel Bavin 2003 --- http://users.skynet.be/bk317494/ ---  bavin@skynet.be 
....................  
....................  
.................... ver 4.0n 
.................... December 10, 2003. 
....................  
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use fast_io(D) 
....................  
.................... #byte userport	=0xf83	//port d 
.................... //#byte rstport = 0xf82   //port c 
.................... #byte tris_userport	=0xf95	//tris d 
.................... //#byte tris_rstport = 0xf94    //tris c 
....................  
.................... //#define NOKIA_SPI 
.................... // NOKIA_LCD // ************************************************************************** 
.................... #bit nok_sclk =userport.0	//RD0 
.................... #bit nok_sda =userport.1	//RD1 
.................... #bit nok_dc =userport.2		//RD2 
.................... #bit nok_cs =userport.3		//RD3 
.................... #bit nok_res =userport.4    //RD4 
....................  
.................... #define USERPORT_ON  0xE0	// iiio oooo 
.................... #define USERPORT_OFF 0xEF 
....................  
.................... #define NOKIA_GRAPH 
.................... #ifdef NOKIA_GRAPH 
....................  
.................... BYTE nokia_vram[504]; 	//84*48 pixels 
.................... int16 nCharPos=0; 
....................  
.................... //#locate nokia_vram=0x100 
....................  
.................... char nokia_getpixel(int x, int y); 
.................... void nokia_putpixel(int x, int y, int nColor); 
.................... void nokia_refresh(void);  
.................... #endif 
....................  
.................... //5*7 font 
.................... BYTE CONST TABLE5 [240]={ 
.................... 						0x00,0x00,0x00,0x00,0x00,	// 20 space	 		ASCII table for NOKIA LCD: 96 rows * 5 bytes= 480 bytes 
.................... 						0x00,0x00,0x5f,0x00,0x00,	// 21 ! 
.................... 						0x00,0x07,0x00,0x07,0x00,	// 22 " 
.................... 						0x14,0x7f,0x14,0x7f,0x14,	// 23 # 
.................... 						0x24,0x2a,0x7f,0x2a,0x12,	// 24 $ 
.................... 						0x23,0x13,0x08,0x64,0x62,	// 25 % 
.................... 						0x36,0x49,0x55,0x22,0x50,	// 26 & 
.................... 						0x00,0x05,0x03,0x00,0x00,	// 27 ' 
.................... 						0x00,0x1c,0x22,0x41,0x00,	// 28 ( 
.................... 						0x00,0x41,0x22,0x1c,0x00,	// 29 ) 
.................... 						0x14,0x08,0x3e,0x08,0x14,	// 2a * 
.................... 						0x08,0x08,0x3e,0x08,0x08,	// 2b + 
.................... 						0x00,0x50,0x30,0x00,0x00,	// 2c , 
.................... 						0x08,0x08,0x08,0x08,0x08,	// 2d - 
.................... 						0x00,0x60,0x60,0x00,0x00,	// 2e . 
.................... 						0x20,0x10,0x08,0x04,0x02,	// 2f / 
.................... 						0x3e,0x51,0x49,0x45,0x3e,	// 30 0 
.................... 						0x00,0x42,0x7f,0x40,0x00,	// 31 1 
.................... 						0x42,0x61,0x51,0x49,0x46,	// 32 2 
.................... 						0x21,0x41,0x45,0x4b,0x31,	// 33 3 
.................... 						0x18,0x14,0x12,0x7f,0x10,	// 34 4 
.................... 						0x27,0x45,0x45,0x45,0x39,	// 35 5 
.................... 						0x3c,0x4a,0x49,0x49,0x30,	// 36 6 
.................... 						0x01,0x71,0x09,0x05,0x03,	// 37 7 
.................... 						0x36,0x49,0x49,0x49,0x36,	// 38 8 
.................... 						0x06,0x49,0x49,0x29,0x1e,	// 39 9 
.................... 						0x00,0x36,0x36,0x00,0x00,	// 3a : 
.................... 						0x00,0x56,0x36,0x00,0x00,	// 3b ; 
.................... 						0x08,0x14,0x22,0x41,0x00,	// 3c < 
.................... 						0x14,0x14,0x14,0x14,0x14,	// 3d = 
.................... 						0x00,0x41,0x22,0x14,0x08,	// 3e > 
.................... 						0x02,0x01,0x51,0x09,0x06,	// 3f ? 
.................... 						0x32,0x49,0x79,0x41,0x3e,	// 40 @ 
.................... 						0x7e,0x11,0x11,0x11,0x7e,	// 41 A 
.................... 						0x7f,0x49,0x49,0x49,0x36,	// 42 B 
.................... 						0x3e,0x41,0x41,0x41,0x22,	// 43 C 
.................... 						0x7f,0x41,0x41,0x22,0x1c,	// 44 D 
.................... 						0x7f,0x49,0x49,0x49,0x41,	// 45 E 
.................... 						0x7f,0x09,0x09,0x09,0x01,	// 46 F 
.................... 						0x3e,0x41,0x49,0x49,0x7a,	// 47 G 
.................... 						0x7f,0x08,0x08,0x08,0x7f,	// 48 H 
.................... 						0x00,0x41,0x7f,0x41,0x00,	// 49 I 
.................... 						0x20,0x40,0x41,0x3f,0x01,	// 4a J 
.................... 						0x7f,0x08,0x14,0x22,0x41,	// 4b K 
.................... 						0x7f,0x40,0x40,0x40,0x40,	// 4c L 
.................... 						0x7f,0x02,0x0c,0x02,0x7f,	// 4d M 
.................... 						0x7f,0x04,0x08,0x10,0x7f,	// 4e N 
.................... 						0x3e,0x41,0x41,0x41,0x3e};	// 4f O 
....................  
....................  
.................... BYTE CONST TABLE6 [240]={ 
.................... 						0x7f,0x09,0x09,0x09,0x06,	// 50 P 
.................... 						0x3e,0x41,0x51,0x21,0x5e,	// 51 Q 
.................... 						0x7f,0x09,0x19,0x29,0x46,	// 52 R 
.................... 						0x46,0x49,0x49,0x49,0x31,	// 53 S 
.................... 						0x01,0x01,0x7f,0x01,0x01,	// 54 T 
.................... 						0x3f,0x40,0x40,0x40,0x3f,	// 55 U 
.................... 						0x1f,0x20,0x40,0x20,0x1f,	// 56 V 
.................... 						0x3f,0x40,0x38,0x40,0x3f,	// 57 W 
.................... 						0x63,0x14,0x08,0x14,0x63,	// 58 X 
.................... 						0x07,0x08,0x70,0x08,0x07,	// 59 Y 
.................... 						0x61,0x51,0x49,0x45,0x43,	// 5a Z 
.................... 						0x00,0x7f,0x41,0x41,0x00,	// 5b [ 
.................... 						0x02,0x04,0x08,0x10,0x20,	// 5c 
.................... 						0x00,0x41,0x41,0x7f,0x00,	// 5d 
.................... 						0x04,0x02,0x01,0x02,0x04,	// 5e 
.................... 						0x40,0x40,0x40,0x40,0x40,	// 5f 
.................... 						0x00,0x01,0x02,0x04,0x00,	// 60 
.................... 						0x20,0x54,0x54,0x54,0x78,	// 61 a 
.................... 						0x7f,0x48,0x44,0x44,0x38,	// 62 b 
.................... 						0x38,0x44,0x44,0x44,0x20,	// 63 c 
.................... 						0x38,0x44,0x44,0x48,0x7f,	// 64 d 
.................... 						0x38,0x54,0x54,0x54,0x18,	// 65 e 
.................... 						0x08,0x7e,0x09,0x01,0x02,	// 66 f 
.................... 						0x0c,0x52,0x52,0x52,0x3e,	// 67 g 
.................... 						0x7f,0x08,0x04,0x04,0x78,	// 68 h 
.................... 						0x00,0x44,0x7d,0x40,0x00,	// 69 i 
.................... 						0x20,0x40,0x44,0x3d,0x00,	// 6a j 
.................... 						0x7f,0x10,0x28,0x44,0x00,	// 6b k 
.................... 						0x00,0x41,0x7f,0x40,0x00,	// 6c l 
.................... 						0x7c,0x04,0x18,0x04,0x78,	// 6d m 
.................... 						0x7c,0x08,0x04,0x04,0x78,	// 6e n 
.................... 						0x38,0x44,0x44,0x44,0x38,	// 6f o 
.................... 						0x7c,0x14,0x14,0x14,0x08,	// 70 p 
.................... 						0x08,0x14,0x14,0x18,0x7c,	// 71 q 
.................... 						0x7c,0x08,0x04,0x04,0x08,	// 72 r 
.................... 						0x48,0x54,0x54,0x54,0x20,	// 73 s 
.................... 						0x04,0x3f,0x44,0x40,0x20,	// 74 t 
.................... 						0x3c,0x40,0x40,0x20,0x7c,	// 75 u 
.................... 						0x1c,0x20,0x40,0x20,0x1c,	// 76 v 
.................... 						0x3c,0x40,0x30,0x40,0x3c,	// 77 w 
.................... 						0x44,0x28,0x10,0x28,0x44,	// 78 x 
.................... 						0x0c,0x50,0x50,0x50,0x3c,	// 79 y 
.................... 						0x44,0x64,0x54,0x4c,0x44,	// 7a z 
.................... 						0x00,0x08,0x36,0x41,0x00,	// 7b 
.................... 						0x00,0x00,0x7f,0x00,0x00,	// 7c 
.................... 						0x00,0x41,0x36,0x08,0x00,	// 7d 
.................... 						0x10,0x08,0x08,0x10,0x08,	// 7e 
.................... 						0x78,0x46,0x41,0x46,0x78};	// 7f 
....................  
....................  
.................... //--------------------------------------prototypes 
.................... //#SEPARATE 
.................... void 	nokia_init(void); 
.................... //#SEPARATE 
.................... void 	nokia_write_command(char bytefornokia_command); 
.................... //#SEPARATE 
.................... void 	nokia_write_data(char bytefornokia_data); 
.................... //#SEPARATE 
.................... void 	nokia_write_dorc(char bytefornokia); 
.................... //#SEPARATE 
.................... void 	nokia_gotoxy(byte xnokia, byte ynokia); 
.................... //#SEPARATE 
.................... void 	nokia_printchar(byte cvar); 
.................... //#SEPARATE 
.................... void 	nokia_clean_ddram(void); 
....................  
.................... void 	table_to_nokialcd(void); 
....................  
.................... //--------------------------------------end prototypes 
.................... int16 ddram; 
.................... int16 charpos; 
.................... char char_row,charsel,chardata; 
.................... char char_invert; 
....................  
.................... void TestLCD() 
.................... { 
....................  
.................... 	nokia_init();				// nokia 3310 lcd init.	********************************************************************** 
....................  
.................... 	nokia_write_command(0x0d);	// mod control inverse video change 
....................  
.................... 	nokia_gotoxy(0,1);			// nokia 3310 lcd cursor x y position 
.................... 	printf(nokia_printchar,"Wei Fang");	// *************************************************************************** 
....................  
.................... 	delay_ms(1000); 
.................... 	nokia_write_command(0x0c);	// mod control normal change 
....................  
.................... } 
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_init(void) 
.................... { 
.................... #use standard_io(D) 
....................       tris_userport	= USERPORT_ON; 
*
005CA:  MOVLW  E0
005CC:  MOVWF  F95
....................       //tris_rstport = tris_rstport&0xDF;   //xxoxxxxx 
....................  
....................       char_invert = 0; 
005CE:  MOVLB  A
005D0:  CLRF   xE4
....................  
....................  
.................... 		delay_us(200); 
005D2:  MOVLW  85
005D4:  MOVWF  00
005D6:  DECFSZ 00,F
005D8:  BRA    05D6
....................  
.................... 		nok_dc=1;				// bytes are stored in the display data ram, address counter, incremented automatically 
005DA:  BSF    F83.2
.................... 		nok_cs=1;				// chip disabled 
005DC:  BSF    F83.3
.................... 		delay_us(200); 
005DE:  MOVLW  85
005E0:  MOVWF  00
005E2:  DECFSZ 00,F
005E4:  BRA    05E2
....................  
.................... 		nok_res=0;				// reset chip during 250ms 
005E6:  BCF    F83.4
.................... 		delay_ms(250);			// works with less..... 
005E8:  MOVLW  FA
005EA:  MOVLB  B
005EC:  MOVWF  x60
005EE:  MOVLB  0
005F0:  RCALL  0584
.................... 		nok_res=1; 
005F2:  BSF    F83.4
....................  
.................... 		nokia_write_command(0x21);	// set extins extended instruction set 
005F4:  MOVLW  21
005F6:  MOVLB  B
005F8:  MOVWF  x61
005FA:  MOVLB  0
005FC:  RCALL  0512
.................... 		nokia_write_command(0xbe);	// Vop  v1: 0xc8 (for 3V)// v2: 0xa0 (for 3V) 0xbe	******************************************************************************************************************** 
005FE:  MOVLW  BE
00600:  MOVLB  B
00602:  MOVWF  x61
00604:  MOVLB  0
00606:  RCALL  0512
.................... 		nokia_write_command(0x13);	// bias 
00608:  MOVLW  13
0060A:  MOVLB  B
0060C:  MOVWF  x61
0060E:  MOVLB  0
00610:  RCALL  0512
.................... 		nokia_write_command(0x20);	// horizontal mode from left to right, X axe are incremented automatically , 0x22 for vertical addressing ,back on normal instruction set too 
00612:  MOVLW  20
00614:  MOVLB  B
00616:  MOVWF  x61
00618:  MOVLB  0
0061A:  RCALL  0512
.................... 		nokia_write_command(0x09);	// all on 
0061C:  MOVLW  09
0061E:  MOVLB  B
00620:  MOVWF  x61
00622:  MOVLB  0
00624:  RCALL  0512
....................  
.................... 		delay_ms(50); 
00626:  MOVLW  32
00628:  MOVLB  B
0062A:  MOVWF  x60
0062C:  MOVLB  0
0062E:  RCALL  0584
....................  
.................... 		nokia_clean_ddram();		// reset DDRAM, otherwise the lcd is blurred with random pixels 
00630:  RCALL  0370
....................  
.................... 		delay_ms(10); 
00632:  MOVLW  0A
00634:  MOVLB  B
00636:  MOVWF  x60
00638:  MOVLB  0
0063A:  RCALL  0584
....................  
.................... 		nokia_write_command(0x08);	// mod control blank change (all off) 
0063C:  MOVLW  08
0063E:  MOVLB  B
00640:  MOVWF  x61
00642:  MOVLB  0
00644:  RCALL  0512
.................... 		delay_ms(10); 
00646:  MOVLW  0A
00648:  MOVLB  B
0064A:  MOVWF  x60
0064C:  MOVLB  0
0064E:  RCALL  0584
....................  
.................... 		nokia_write_command(0x0c);	// mod control normal change 
00650:  MOVLW  0C
00652:  MOVLB  B
00654:  MOVWF  x61
00656:  MOVLB  0
00658:  RCALL  0512
....................  
....................       tris_userport=USERPORT_OFF;	// iiii iooi 
0065A:  MOVLW  EF
0065C:  MOVWF  F95
.................... #use fast_io(D) 
....................  
.................... } 
0065E:  GOTO   4CAE (RETURN)
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_clean_ddram(void) 
.................... { 
.................... #ifdef NOKIA_GRAPH 
.................... 	for (ddram=0;ddram<504;ddram++){nokia_vram[ddram] = 0x00;} 
*
00370:  MOVLB  A
00372:  CLRF   xDE
00374:  CLRF   xDD
00376:  MOVF   xDE,W
00378:  SUBLW  01
0037A:  BNC   039A
0037C:  BNZ   0384
0037E:  MOVF   xDD,W
00380:  SUBLW  F7
00382:  BNC   039A
00384:  MOVLW  E3
00386:  ADDWF  xDD,W
00388:  MOVWF  FE9
0038A:  MOVLW  08
0038C:  ADDWFC xDE,W
0038E:  MOVWF  FEA
00390:  CLRF   FEF
00392:  INCF   xDD,F
00394:  BTFSC  FD8.2
00396:  INCF   xDE,F
00398:  BRA    0376
.................... 	 
.................... #else 
.................... 	nokia_gotoxy(0,0);			// 84*6=504		clear LCD 
.................... 	for (ddram=504;ddram>0;ddram--){nokia_write_data(0x00);} 
.................... #endif 
....................  
.................... } 
0039A:  MOVLB  0
0039C:  RETLW  00
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_write_command(char bytefornokia_command) 
.................... { 
.................... 	tris_userport	=USERPORT_ON;	// iiii oooo 
*
00512:  MOVLW  E0
00514:  MOVWF  F95
....................  
.................... 	nok_dc=0;	// byte is a command it is read with the eight SCLK pulse 
00516:  BCF    F83.2
.................... 	nok_cs=0;	// chip enabled 
00518:  BCF    F83.3
.................... 	nokia_write_dorc(bytefornokia_command); 
0051A:  MOVFF  B61,B62
0051E:  RCALL  04DE
.................... 	nok_cs=1;	// chip disabled 
00520:  BSF    F83.3
....................  
.................... 	tris_userport	=USERPORT_OFF;	// iiii iooo 
00522:  MOVLW  EF
00524:  MOVWF  F95
....................  
.................... } 
00526:  RETLW  00
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_write_data(char bytefornokia_data) 
.................... { 
.................... #ifdef NOKIA_GRAPH 
....................    	if(char_invert) 
*
003F4:  MOVLB  A
003F6:  MOVF   xE4,F
003F8:  BZ    0400
....................       		bytefornokia_data = ~bytefornokia_data; 
003FA:  MOVLB  B
003FC:  COMF   x61,F
003FE:  MOVLB  A
....................       	//if(nCharPos >= 504) 
....................       	//	nCharPos = 0; 
.................... 	nokia_vram[nCharPos++] = bytefornokia_data; 
00400:  MOVFF  ADC,03
00404:  MOVF   xDB,W
00406:  INCF   xDB,F
00408:  BTFSC  FD8.2
0040A:  INCF   xDC,F
0040C:  MOVLB  B
0040E:  MOVWF  x62
00410:  MOVLW  E3
00412:  ADDWF  x62,W
00414:  MOVWF  FE9
00416:  MOVLW  08
00418:  ADDWFC 03,W
0041A:  MOVWF  FEA
0041C:  MOVFF  B61,FEF
.................... 	 
.................... #else 
.................... 	tris_userport	=USERPORT_ON;	// iooo iooo 
....................  
.................... 	nok_dc=1; 
.................... 	nok_cs=0;	// chip enabled 
....................    if(char_invert) 
....................       bytefornokia_data = ~bytefornokia_data; 
.................... 	nokia_write_dorc(bytefornokia_data); 
.................... 	nok_cs=1;	// chip disabled 
....................  
.................... 	tris_userport	=USERPORT_OFF;	// iiii iooo 
.................... #endif 
....................  
.................... } 
00420:  MOVLB  0
00422:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_write_dorc(char bytefornokia)			// serial write data or command subroutine 
.................... { 
.................... 	signed char caa; 
.................... 	for (caa=7;caa>=0;caa--) 
*
004DE:  MOVLW  07
004E0:  MOVLB  B
004E2:  MOVWF  x63
004E4:  BTFSC  x63.7
004E6:  BRA    050E
.................... 	{ 
.................... 		nok_sclk=0; 
004E8:  BCF    F83.0
.................... 		delay_us(2); 
004EA:  BRA    04EC
004EC:  BRA    04EE
.................... 		nok_sda = bit_test(bytefornokia, caa); 
004EE:  MOVFF  B62,00
004F2:  MOVF   x63,W
004F4:  MOVWF  01
004F6:  BZ    0500
004F8:  BCF    FD8.0
004FA:  RRCF   00,F
004FC:  DECFSZ 01,F
004FE:  BRA    04F8
00500:  BTFSS  00.0
00502:  BCF    F83.1
00504:  BTFSC  00.0
00506:  BSF    F83.1
.................... 		nok_sclk=1; 
00508:  BSF    F83.0
.................... 	}	 
0050A:  DECF   x63,F
0050C:  BRA    04E4
....................  
.................... } 
0050E:  MOVLB  0
00510:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_gotoxy(byte xnokia, byte ynokia)		// Nokia LCD 3310 Position cursor 
.................... { 
.................... #ifdef NOKIA_GRAPH 
.................... 	nCharPos = ynokia; 
*
003C0:  MOVLB  A
003C2:  CLRF   xDC
003C4:  MOVFF  B60,ADB
.................... 	nCharPos *= 84; 
003C8:  MOVFF  ADC,B62
003CC:  MOVFF  ADB,B61
003D0:  MOVLB  B
003D2:  CLRF   x64
003D4:  MOVLW  54
003D6:  MOVWF  x63
003D8:  MOVLB  0
003DA:  RCALL  039E
003DC:  MOVFF  02,ADC
003E0:  MOVFF  01,ADB
.................... 	nCharPos += xnokia; 
003E4:  MOVLB  B
003E6:  MOVF   x5F,W
003E8:  MOVLB  A
003EA:  ADDWF  xDB,F
003EC:  MOVLW  00
003EE:  ADDWFC xDC,F
.................... #else 
.................... 	nokia_write_command(0x40|(ynokia&0x07));	// Y axe initialisation: 0100 0yyy 
.................... 	nokia_write_command(0x80|(xnokia&0x7f));	// X axe initialisation: 1xxx xxxx 
.................... #endif 
.................... } 
003F0:  MOVLB  0
003F2:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //#SEPARATE 
.................... void nokia_printchar(byte cvar)					// Write 1 character to LCD 
.................... { 
.................... 	charsel=cvar; 
*
004D6:  MOVFF  B60,AE2
.................... 	table_to_nokialcd(); 
004DA:  BRA    0424
.................... } 
004DC:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void table_to_nokialcd(void)	// extract ascii from tables & write to LCD 
.................... { 
.................... 	if (charsel<0x20)return; 
*
00424:  MOVLB  A
00426:  MOVF   xE2,W
00428:  SUBLW  1F
0042A:  BNC   042E
0042C:  BRA    04D0
.................... 	if (charsel>0x7f)return; 
0042E:  MOVF   xE2,W
00430:  SUBLW  7F
00432:  BC    0436
00434:  BRA    04D0
....................  
.................... 	for (char_row=0;char_row<5;char_row++) 
00436:  CLRF   xE1
00438:  MOVF   xE1,W
0043A:  SUBLW  04
0043C:  BNC   04C6
.................... 	{		// 5 bytes 
....................  
.................... 		if (charsel<0x50) 
0043E:  MOVF   xE2,W
00440:  SUBLW  4F
00442:  BNC   047C
.................... 			{charpos=(((charsel&0xff)-0x20)*5);chardata=TABLE5[(charpos+char_row)];}				// use TABLE5 
00444:  MOVF   xE2,W
00446:  ADDLW  E0
00448:  MULLW  05
0044A:  MOVF   FF3,W
0044C:  CLRF   xE0
0044E:  MOVWF  xDF
00450:  MOVF   xE1,W
00452:  ADDWF  xDF,W
00454:  MOVLB  B
00456:  MOVWF  x61
00458:  MOVLW  00
0045A:  MOVLB  A
0045C:  ADDWFC xE0,W
0045E:  MOVLB  B
00460:  MOVWF  x62
00462:  MOVWF  03
00464:  MOVF   x61,W
00466:  MOVFF  FF2,B63
0046A:  BCF    FF2.7
0046C:  MOVLB  0
0046E:  RCALL  0024
00470:  MOVLB  B
00472:  BTFSC  x63.7
00474:  BSF    FF2.7
00476:  MOVFF  FE8,AE3
0047A:  MOVLB  A
.................... 		if (charsel>0x4f){charpos=(((charsel&0xff)-0x50)*5);chardata=TABLE6[(charpos+char_row)];}				// use TABLE6 
0047C:  MOVF   xE2,W
0047E:  SUBLW  4F
00480:  BC    04B8
00482:  MOVF   xE2,W
00484:  ADDLW  B0
00486:  MULLW  05
00488:  MOVF   FF3,W
0048A:  CLRF   xE0
0048C:  MOVWF  xDF
0048E:  MOVF   xE1,W
00490:  ADDWF  xDF,W
00492:  MOVLB  B
00494:  MOVWF  x61
00496:  MOVLW  00
00498:  MOVLB  A
0049A:  ADDWFC xE0,W
0049C:  MOVLB  B
0049E:  MOVWF  x62
004A0:  MOVWF  03
004A2:  MOVF   x61,W
004A4:  MOVFF  FF2,B63
004A8:  BCF    FF2.7
004AA:  MOVLB  0
004AC:  RCALL  0128
004AE:  MOVLB  B
004B0:  BTFSC  x63.7
004B2:  BSF    FF2.7
004B4:  MOVFF  FE8,AE3
....................  
.................... 		nokia_write_data(chardata);		// send data to nokia 
004B8:  MOVFF  AE3,B61
004BC:  MOVLB  0
004BE:  RCALL  03F4
.................... 		 
.................... 	} 
004C0:  MOVLB  A
004C2:  INCF   xE1,F
004C4:  BRA    0438
....................  
.................... 	nokia_write_data(0x00);		// 	1 byte (always blank) 
004C6:  MOVLB  B
004C8:  CLRF   x61
004CA:  MOVLB  0
004CC:  RCALL  03F4
004CE:  MOVLB  A
....................  
.................... } 
004D0:  MOVLB  0
004D2:  GOTO   04DC (RETURN)
.................... //#SEPARATE 
.................... void nokia_power_down(void) 
.................... { 
....................    nokia_clean_ddram(); 
....................    nokia_write_command(0x25); 
.................... } 
.................... //#SEPARATE 
.................... void nokia_power_up() 
.................... { 
....................    nokia_write_command(0x21); 
.................... } 
.................... //#SEPARATE 
.................... void nokia_char_invert(int bInvert) 
.................... { 
....................      char_invert = bInvert; 
.................... } 
....................  
.................... #ifdef NOKIA_GRAPH 
.................... char nokia_getpixel(int x, int y) 
.................... { 
.................... 	int16 nPos; 
.................... 	char nPixel; 
.................... 	nPos = (y/8); 
.................... 	nPos = nPos*84+x; 
....................  
.................... 	nPixel = nokia_vram[nPos]; 
....................  
.................... 	nPixel = bit_test(nPixel, (y%8)); 
.................... 	return nPixel; 
.................... } 
....................  
.................... void nokia_putpixel(int x, int y, int nColor) 
.................... { 
.................... 	int16 nPos; 
.................... 	char nPixel; 
....................  
.................... 	 
.................... 	nPos = y; 
.................... 	nPos >>= 3; 
.................... 	nPos = nPos*84+x; 
....................  
.................... 	nPixel = nokia_vram[nPos]; 
....................  
.................... 	if(nColor) 
.................... 		bit_set(nPixel, (y%8)); 
.................... 	else 
.................... 		bit_clear(nPixel, (y%8)); 
....................  
.................... 	nokia_vram[nPos] = nPixel; 
....................  
.................... } 
....................  
.................... void nokia_drawtextxy(int x, int y, char *pText, int nColor) 
.................... { 
.................... 	 
.................... } 
....................  
.................... void nokia_line(int x1, int y1, int x2, int y2, int color) 
.................... { 
.................... 	signed int16 deltax, deltay, numpixels; 
.................... 	signed int16 i, 
....................     d, dinc1, dinc2, 
....................     x, xinc1, xinc2, 
....................     y, yinc1, yinc2; 
....................  
....................  
....................   	deltax = abs(x2 - x1); 
....................   	deltay = abs(y2 - y1); 
....................  
....................   	//Initialize all vars based on which is the independent variable } 
....................   	if( deltax >= deltay ) 
....................   	{ 
....................  
....................       //{ x is independent variable } 
....................       numpixels = deltax + 1; 
....................       d = (2 * deltay) - deltax; 
....................       dinc1 = deltay<<1; 
....................       dinc2 = (deltay - deltax) * 2; 
....................       xinc1 = 1; 
....................       xinc2 = 1; 
....................       yinc1 = 0; 
....................       yinc2 = 1; 
....................    	} 
....................   	else 
....................   	{ 
....................  
....................       //{ y is independent variable } 
....................       numpixels = deltay + 1; 
....................       d = (2 * deltax) - deltay; 
....................       dinc1 = deltax << 1; 
....................       dinc2 = (deltax - deltay) *2; 
....................       xinc1 = 0; 
....................       xinc2 = 1; 
....................       yinc1 = 1; 
....................       yinc2 = 1; 
....................     } 
....................  
....................   //{ Make sure x and y move in the right directions } 
....................   if( x1 > x2 ) 
....................   { 
....................       xinc1 = -xinc1; 
....................       xinc2 = -xinc2; 
....................    } 
....................   if( y1 > y2 ) 
....................     { 
....................       yinc1 = -yinc1; 
....................       yinc2 = -yinc2; 
....................     } 
....................  
....................   //{ Start drawing at <x1, y1> } 
....................   x = x1; 
....................   y = y1; 
....................  
....................   //{ Draw the pixels } 
....................   for( i = 1; i< numpixels; i++) 
....................    { 
....................       nokia_putpixel(x, y, color); 
....................  
....................       if( d < 0 ) 
....................        { 
....................           d = d + dinc1; 
....................           x = x + xinc1; 
....................           y = y + yinc1; 
....................        } 
....................       else 
....................         { 
....................           d = d + dinc2; 
....................           x = x + xinc2; 
....................           y = y + yinc2; 
....................         } 
....................     } 
....................  
.................... } 
....................  
.................... void nokia_circle(int x, int y, int r, int color) 
.................... { 
....................  
.................... 	signed int x1, y1; 
....................  
.................... 	signed int p; 
....................  
.................... 	 x1 = 0; y1 = r; p= 1-r; 
.................... 	while(x1<=y1) 
.................... 	{ 
....................  		//Make all the 8 parts 
....................  		nokia_putpixel(x+x1,y+y1,color); 
.................... 		nokia_putpixel(x+x1,y-y1,color); 
....................  		nokia_putpixel(x-x1,y+y1,color); 
.................... 		nokia_putpixel(x-x1,y-y1,color); 
.................... 		nokia_putpixel(x+y1,y+x1,color); 
.................... 		nokia_putpixel(x+y1,y-x1,color); 
.................... 		nokia_putpixel(x-y1,y+x1,color); 
.................... 		nokia_putpixel(x-y1,y-x1,color);  
....................   
....................  		if(p < 0) 
....................  		{ 
....................   			p += 2*x1 + 3; 
....................  		} 
....................  		else 
....................  		{ 
....................   			p += 2*(x1-y1)+5; 
....................   			--y1; 
....................  		} 
....................   
....................  		++x1; 
.................... 	} 
....................   
.................... } 
.................... void nokia_refresh(void) 
.................... { 
.................... 	int16 i; 
.................... 	 
.................... 	//Set DRAM address 0 
.................... 	nokia_write_command(0x40);	// Y axe initialisation: 0100 0yyy 
*
00528:  MOVLW  40
0052A:  MOVLB  B
0052C:  MOVWF  x61
0052E:  MOVLB  0
00530:  RCALL  0512
.................... 	nokia_write_command(0x80);	// X axe initialisation: 1xxx xxxx 
00532:  MOVLW  80
00534:  MOVLB  B
00536:  MOVWF  x61
00538:  MOVLB  0
0053A:  RCALL  0512
.................... 	 
.................... 	tris_userport	=USERPORT_ON;	// iooo iooo 
0053C:  MOVLW  E0
0053E:  MOVWF  F95
....................  
.................... 	nok_dc=1; 
00540:  BSF    F83.2
.................... 	nok_cs=0;	// chip enabled 
00542:  BCF    F83.3
.................... 	 
.................... 	for (i=0; i<504; i++) 
00544:  MOVLB  B
00546:  CLRF   x60
00548:  CLRF   x5F
0054A:  MOVF   x60,W
0054C:  SUBLW  01
0054E:  BNC   057A
00550:  BNZ   0558
00552:  MOVF   x5F,W
00554:  SUBLW  F7
00556:  BNC   057A
.................... 		nokia_write_dorc(nokia_vram[i]); 
00558:  MOVLW  E3
0055A:  ADDWF  x5F,W
0055C:  MOVWF  FE9
0055E:  MOVLW  08
00560:  ADDWFC x60,W
00562:  MOVWF  FEA
00564:  MOVFF  FEF,B61
00568:  MOVFF  B61,B62
0056C:  MOVLB  0
0056E:  RCALL  04DE
00570:  MOVLB  B
00572:  INCF   x5F,F
00574:  BTFSC  FD8.2
00576:  INCF   x60,F
00578:  BRA    054A
....................  
.................... 	nok_cs=1;	// chip disabled 
0057A:  BSF    F83.3
.................... 	tris_userport	=USERPORT_OFF;	// iiii iooo 
0057C:  MOVLW  EF
0057E:  MOVWF  F95
.................... } 
00580:  MOVLB  0
00582:  RETLW  00
....................  
.................... #endif 
....................  
....................  
.................... unsigned int atoi_b16(char *s) {  // Convert two hex characters to a int8 
....................    unsigned int result = 0; 
....................    int i; 
....................  
....................    for (i=0; i<2; i++,s++)  { 
....................       if (*s >= 'A') 
....................          result = 16*result + (*s) - 'A' + 10; 
....................       else 
....................          result = 16*result + (*s) - '0'; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #byte TBLPTRU=0xFF8 
.................... #byte TBLPTRH=0xFF7 
.................... #byte TBLPTRL=0xFF6 
.................... #byte TABLAT=0xFF5 
....................  
.................... #byte EECON1=0xFA6 
.................... #byte EECON2=0xFA7 
.................... #byte INTCON=0xFF2 
....................  
.................... #bit WR=EECON1.1 
.................... #bit WREN=EECON1.2 
.................... #bit FREE=EECON1.4 
.................... #bit CFGS=EECON1.5 
.................... #bit EEPGD=EECON1.6 
....................  
.................... void WriteFlashBlock(int32 addr, BYTE * pBuff, long nLen) 
.................... { 
.................... 	int i,j; 
....................  
.................... 	addr = gBlockAddr; 
*
03CBE:  MOVFF  8E0,AF4
03CC2:  MOVFF  8DF,AF3
03CC6:  MOVFF  8DE,AF2
03CCA:  MOVFF  8DD,AF1
....................  
.................... 	//Erase flash first 
.................... 	TBLPTRU = (byte)(addr>>16); 
03CCE:  MOVFF  AF3,FF8
.................... 	TBLPTRH = (byte)((addr>>8)&0xFF); 
03CD2:  MOVLB  A
03CD4:  MOVFF  AF2,FF7
.................... 	TBLPTRL = (byte)(addr&0xFF); 
03CD8:  MOVFF  AF1,FF6
....................  
....................  
.................... 	//EEPGD = 1; 
.................... 	//CFGS = 0; 
.................... 	WREN = 1; 
03CDC:  BSF    FA6.2
.................... 	FREE = 1; 
03CDE:  BSF    FA6.4
.................... 	 
.................... 	disable_interrupts(GLOBAL);  
03CE0:  BCF    FF2.6
03CE2:  BCF    FF2.7
03CE4:  BTFSC  FF2.7
03CE6:  BRA    3CE2
.................... 	 
.................... 	EECON2 = 0x55; 
03CE8:  MOVLW  55
03CEA:  MOVWF  FA7
.................... 	EECON2 = 0xAA; 
03CEC:  MOVLW  AA
03CEE:  MOVWF  FA7
.................... 	 
.................... 	WR = 1;	//Start erase 
03CF0:  BSF    FA6.1
.................... 	 
.................... 	for(i=0; i<16; i++) 
03CF2:  CLRF   xF9
03CF4:  MOVF   xF9,W
03CF6:  SUBLW  0F
03CF8:  BNC   3D54
.................... 	{ 
.................... 		for(j=0; j<64; j++) 
03CFA:  CLRF   xFA
03CFC:  MOVF   xFA,W
03CFE:  SUBLW  3F
03D00:  BNC   3D1E
.................... 		{ 
.................... 			TABLAT = *pBuff++; 
03D02:  MOVFF  AF6,03
03D06:  MOVF   xF5,W
03D08:  INCF   xF5,F
03D0A:  BTFSC  FD8.2
03D0C:  INCF   xF6,F
03D0E:  MOVWF  FE9
03D10:  MOVFF  03,FEA
03D14:  MOVFF  FEF,FF5
.................... #asm 
.................... 			TBLWT*+ 
03D18:  TBLWT*+
.................... #endasm		 
.................... 		} 
03D1A:  INCF   xFA,F
03D1C:  BRA    3CFC
....................  
.................... 		TBLPTRU = (byte)(addr>>16); 
03D1E:  MOVFF  AF3,FF8
.................... 		TBLPTRH = (byte)((addr>>8)&0xFF); 
03D22:  MOVFF  AF2,FF7
.................... 		TBLPTRL = (byte)(addr&0xFF); 
03D26:  MOVFF  AF1,FF6
.................... 		addr += 64; 
03D2A:  MOVLW  40
03D2C:  ADDWF  xF1,F
03D2E:  MOVLW  00
03D30:  ADDWFC xF2,F
03D32:  ADDWFC xF3,F
03D34:  ADDWFC xF4,F
....................  
.................... 		disable_interrupts(GLOBAL); 
03D36:  BCF    FF2.6
03D38:  BCF    FF2.7
03D3A:  BTFSC  FF2.7
03D3C:  BRA    3D38
.................... 		WREN = 1; 
03D3E:  BSF    FA6.2
.................... 		EECON2 = 0x55; 
03D40:  MOVLW  55
03D42:  MOVWF  FA7
.................... 		EECON2 = 0xAA; 
03D44:  MOVLW  AA
03D46:  MOVWF  FA7
.................... 		 
.................... 		WR = 1;	//Start program 
03D48:  BSF    FA6.1
.................... 		 
.................... 		enable_interrupts(GLOBAL); 
03D4A:  MOVLW  C0
03D4C:  IORWF  FF2,F
.................... 		WREN = 0; 
03D4E:  BCF    FA6.2
.................... 	} 
03D50:  INCF   xF9,F
03D52:  BRA    3CF4
.................... 	 
.................... 	 
.................... 	enable_interrupts(GLOBAL); 
03D54:  MOVLW  C0
03D56:  IORWF  FF2,F
.................... 	 
.................... } 
03D58:  MOVLB  0
03D5A:  GOTO   411C (RETURN)
....................  
.................... void LoadProgram(HANDLE hFile) 
.................... { 
.................... 	char nChar; 
.................... 	int bMoreChar; 
.................... 	int bDone = 0; 
03D5E:  MOVLB  A
03D60:  CLRF   xEE
.................... 	int16 i; 
....................  
.................... 	gBlockAddr = 0; 
03D62:  MOVLB  8
03D64:  CLRF   xE0
03D66:  CLRF   xDF
03D68:  CLRF   xDE
03D6A:  CLRF   xDD
.................... 	gBlockWritePtr = 0; 
03D6C:  CLRF   xE2
03D6E:  CLRF   xE1
.................... 	memset(gBinBlock, 0xFF, BUFFER_BIN_BLOCK); 
03D70:  MOVLW  04
03D72:  MOVWF  FEA
03D74:  MOVLW  DD
03D76:  MOVWF  FE9
03D78:  MOVLW  FF
03D7A:  MOVLB  A
03D7C:  MOVWF  xF1
03D7E:  MOVLW  04
03D80:  MOVWF  xF3
03D82:  CLRF   xF2
03D84:  MOVLB  0
03D86:  CALL   05AC
....................  
.................... 	nokia_clean_ddram(); 
03D8A:  CALL   0370
.................... 	nokia_gotoxy(0,0); 
03D8E:  MOVLB  B
03D90:  CLRF   x5F
03D92:  CLRF   x60
03D94:  MOVLB  0
03D96:  CALL   03C0
.................... 	printf(nokia_printchar, "SW Update"); 
03D9A:  MOVLB  A
03D9C:  CLRF   xF1
03D9E:  MOVF   xF1,W
03DA0:  MOVLB  0
03DA2:  CALL   022C
03DA6:  MOVLB  A
03DA8:  INCF   xF1,F
03DAA:  MOVWF  00
03DAC:  MOVFF  FE8,B60
03DB0:  MOVLB  0
03DB2:  CALL   04D6
03DB6:  MOVLW  09
03DB8:  MOVLB  A
03DBA:  SUBWF  xF1,W
03DBC:  BNZ   3D9E
.................... 	nokia_refresh(); 
03DBE:  MOVLB  0
03DC0:  CALL   0528
....................  
.................... 	//Read BIN file indentifier 
.................... 	bMoreChar = fgetch(&nChar, hFile); 
03DC4:  MOVLW  0A
03DC6:  MOVLB  A
03DC8:  MOVWF  xFD
03DCA:  MOVLW  EC
03DCC:  MOVWF  xFC
03DCE:  MOVFF  AEB,AFE
03DD2:  MOVLB  0
03DD4:  CALL   3580
03DD8:  MOVFF  01,AED
.................... 	if(!bMoreChar || nChar != 'W') 
03DDC:  MOVLB  A
03DDE:  MOVF   xED,F
03DE0:  BZ    3DE8
03DE2:  MOVF   xEC,W
03DE4:  SUBLW  57
03DE6:  BZ    3E24
.................... 	{ 
.................... 		nokia_gotoxy(0,1); 
03DE8:  MOVLB  B
03DEA:  CLRF   x5F
03DEC:  MOVLW  01
03DEE:  MOVWF  x60
03DF0:  MOVLB  0
03DF2:  CALL   03C0
.................... 		printf(nokia_printchar, "Invalid File"); 
03DF6:  MOVLB  A
03DF8:  CLRF   xF1
03DFA:  MOVF   xF1,W
03DFC:  MOVLB  0
03DFE:  CALL   024A
03E02:  MOVLB  A
03E04:  INCF   xF1,F
03E06:  MOVWF  00
03E08:  MOVFF  FE8,B60
03E0C:  MOVLB  0
03E0E:  CALL   04D6
03E12:  MOVLW  0C
03E14:  MOVLB  A
03E16:  SUBWF  xF1,W
03E18:  BNZ   3DFA
.................... 		nokia_refresh(); 
03E1A:  MOVLB  0
03E1C:  CALL   0528
.................... 		while(1); 
03E20:  BRA    3E20
03E22:  MOVLB  A
.................... 	} 
....................  
.................... 	bMoreChar = fgetch(&nChar, hFile); 
03E24:  MOVLW  0A
03E26:  MOVWF  xFD
03E28:  MOVLW  EC
03E2A:  MOVWF  xFC
03E2C:  MOVFF  AEB,AFE
03E30:  MOVLB  0
03E32:  CALL   3580
03E36:  MOVFF  01,AED
.................... 	if(!bMoreChar || nChar != 'F') 
03E3A:  MOVLB  A
03E3C:  MOVF   xED,F
03E3E:  BZ    3E46
03E40:  MOVF   xEC,W
03E42:  SUBLW  46
03E44:  BZ    3E82
.................... 	{ 
.................... 		nokia_gotoxy(0,1); 
03E46:  MOVLB  B
03E48:  CLRF   x5F
03E4A:  MOVLW  01
03E4C:  MOVWF  x60
03E4E:  MOVLB  0
03E50:  CALL   03C0
.................... 		printf(nokia_printchar, "Invalid File"); 
03E54:  MOVLB  A
03E56:  CLRF   xF1
03E58:  MOVF   xF1,W
03E5A:  MOVLB  0
03E5C:  CALL   024A
03E60:  MOVLB  A
03E62:  INCF   xF1,F
03E64:  MOVWF  00
03E66:  MOVFF  FE8,B60
03E6A:  MOVLB  0
03E6C:  CALL   04D6
03E70:  MOVLW  0C
03E72:  MOVLB  A
03E74:  SUBWF  xF1,W
03E76:  BNZ   3E58
.................... 		nokia_refresh(); 
03E78:  MOVLB  0
03E7A:  CALL   0528
.................... 		while(1); 
03E7E:  BRA    3E7E
03E80:  MOVLB  A
.................... 	} 
....................  
.................... 	while(!bDone) 
.................... 	{ 
03E82:  MOVF   xEE,F
03E84:  BTFSS  FD8.2
03E86:  BRA    4120
.................... 		gBlockAddr = 0xFFFFFFFF; 
03E88:  MOVLW  FF
03E8A:  MOVLB  8
03E8C:  MOVWF  xE0
03E8E:  MOVWF  xDF
03E90:  MOVWF  xDE
03E92:  MOVWF  xDD
.................... 		fread(&gBlockAddr, 4, hFile); 
03E94:  MOVLW  08
03E96:  MOVLB  A
03E98:  MOVWF  xF2
03E9A:  MOVLW  DD
03E9C:  MOVWF  xF1
03E9E:  CLRF   xF4
03EA0:  MOVLW  04
03EA2:  MOVWF  xF3
03EA4:  MOVFF  AEB,AF5
03EA8:  MOVLB  0
03EAA:  RCALL  3B88
....................  
.................... 		if(gBLockAddr == 0xFFFFFFFF) 
03EAC:  MOVLB  8
03EAE:  INCFSZ xDD,W
03EB0:  BRA    3EC2
03EB2:  INCFSZ xDE,W
03EB4:  BRA    3EC2
03EB6:  INCFSZ xDF,W
03EB8:  BRA    3EC2
03EBA:  INCFSZ xE0,W
03EBC:  BRA    3EC2
.................... 			break; 
03EBE:  MOVLB  A
03EC0:  BRA    4120
.................... 		 
.................... 		if(fread(gBinBLock, BUFFER_BIN_BLOCK, hFile) != BUFFER_BIN_BLOCK) 
03EC2:  MOVLW  04
03EC4:  MOVLB  A
03EC6:  MOVWF  xF2
03EC8:  MOVLW  DD
03ECA:  MOVWF  xF1
03ECC:  MOVLW  04
03ECE:  MOVWF  xF4
03ED0:  CLRF   xF3
03ED2:  MOVFF  AEB,AF5
03ED6:  MOVLB  0
03ED8:  RCALL  3B88
03EDA:  MOVFF  02,AF2
03EDE:  MOVFF  01,AF1
03EE2:  MOVLB  A
03EE4:  MOVF   xF1,F
03EE6:  BNZ   3EEE
03EE8:  MOVF   xF2,W
03EEA:  SUBLW  04
03EEC:  BZ    3F2A
.................... 		{ 
.................... 			nokia_gotoxy(0,1); 
03EEE:  MOVLB  B
03EF0:  CLRF   x5F
03EF2:  MOVLW  01
03EF4:  MOVWF  x60
03EF6:  MOVLB  0
03EF8:  CALL   03C0
.................... 			printf(nokia_printchar, "File corrupted"); 
03EFC:  MOVLB  A
03EFE:  CLRF   xF1
03F00:  MOVF   xF1,W
03F02:  MOVLB  0
03F04:  CALL   026C
03F08:  MOVLB  A
03F0A:  INCF   xF1,F
03F0C:  MOVWF  00
03F0E:  MOVFF  FE8,B60
03F12:  MOVLB  0
03F14:  CALL   04D6
03F18:  MOVLW  0E
03F1A:  MOVLB  A
03F1C:  SUBWF  xF1,W
03F1E:  BNZ   3F00
.................... 			nokia_refresh(); 
03F20:  MOVLB  0
03F22:  CALL   0528
.................... 			while(1); 
03F26:  BRA    3F26
03F28:  MOVLB  A
.................... 		} 
....................  
.................... 		//Decode program code 
.................... 		for(i=0; i<BUFFER_BIN_BLOCK; i++) 
03F2A:  CLRF   xF0
03F2C:  CLRF   xEF
03F2E:  MOVF   xF0,W
03F30:  SUBLW  03
03F32:  BNC   3F4E
.................... 			gBinBlock[i] ^= 'W'; 
03F34:  MOVLW  DD
03F36:  ADDWF  xEF,W
03F38:  MOVWF  FE9
03F3A:  MOVLW  04
03F3C:  ADDWFC xF0,W
03F3E:  MOVWF  FEA
03F40:  MOVF   FEF,W
03F42:  XORLW  57
03F44:  MOVWF  FEF
03F46:  INCF   xEF,F
03F48:  BTFSC  FD8.2
03F4A:  INCF   xF0,F
03F4C:  BRA    3F2E
....................  
.................... 		if(gBlockAddr > LOADER_END)	//There is something in Block 
03F4E:  MOVLB  8
03F50:  MOVF   xE0,F
03F52:  BNZ   3F60
03F54:  MOVF   xDF,F
03F56:  BNZ   3F60
03F58:  MOVF   xDE,W
03F5A:  SUBLW  4F
03F5C:  BTFSC  FD8.0
03F5E:  BRA    411C
.................... 		{ 
.................... 				//Write block to flash 
.................... 			 
.................... 				nokia_gotoxy(0,3); 
03F60:  MOVLB  B
03F62:  CLRF   x5F
03F64:  MOVLW  03
03F66:  MOVWF  x60
03F68:  MOVLB  0
03F6A:  CALL   03C0
.................... 				printf(nokia_printchar, "Loading..."); 
03F6E:  MOVLB  A
03F70:  CLRF   xF1
03F72:  MOVF   xF1,W
03F74:  MOVLB  0
03F76:  CALL   0290
03F7A:  MOVLB  A
03F7C:  INCF   xF1,F
03F7E:  MOVWF  00
03F80:  MOVFF  FE8,B60
03F84:  MOVLB  0
03F86:  CALL   04D6
03F8A:  MOVLW  0A
03F8C:  MOVLB  A
03F8E:  SUBWF  xF1,W
03F90:  BNZ   3F72
.................... 				nokia_gotoxy(0,4); 
03F92:  MOVLB  B
03F94:  CLRF   x5F
03F96:  MOVLW  04
03F98:  MOVWF  x60
03F9A:  MOVLB  0
03F9C:  CALL   03C0
.................... 				printf(nokia_printchar, "%lu%%", gFiles[hFile].wFileSize*100/gFiles[hFile].DirEntry.wSize); 
03FA0:  MOVLB  B
03FA2:  CLRF   x62
03FA4:  MOVFF  AEB,B61
03FA8:  MOVLW  02
03FAA:  MOVWF  x64
03FAC:  MOVLW  33
03FAE:  MOVWF  x63
03FB0:  MOVLB  0
03FB2:  CALL   039E
03FB6:  MOVFF  02,AF2
03FBA:  MOVFF  01,AF1
03FBE:  MOVLW  27
03FC0:  MOVLB  A
03FC2:  ADDWF  01,W
03FC4:  MOVWF  01
03FC6:  MOVLW  02
03FC8:  ADDWFC 02,W
03FCA:  MOVWF  03
03FCC:  MOVF   01,W
03FCE:  ADDLW  70
03FD0:  MOVWF  FE9
03FD2:  MOVLW  02
03FD4:  ADDWFC 03,W
03FD6:  MOVWF  FEA
03FD8:  MOVFF  FEF,AF3
03FDC:  MOVFF  FEC,AF4
03FE0:  MOVFF  FEC,AF5
03FE4:  MOVFF  FEC,AF6
03FE8:  MOVFF  FEA,AF8
03FEC:  MOVFF  FE9,AF7
03FF0:  MOVFF  AF6,B3C
03FF4:  MOVFF  AF5,B3B
03FF8:  MOVFF  AF4,B3A
03FFC:  MOVFF  AF3,B39
04000:  MOVLB  B
04002:  CLRF   x40
04004:  CLRF   x3F
04006:  CLRF   x3E
04008:  MOVLW  64
0400A:  MOVWF  x3D
0400C:  MOVLB  0
0400E:  CALL   08F4
04012:  MOVFF  AF8,FEA
04016:  MOVFF  AF7,FE9
0401A:  MOVFF  03,AF7
0401E:  MOVFF  02,AF6
04022:  MOVFF  01,AF5
04026:  MOVFF  00,AF4
0402A:  MOVLB  B
0402C:  CLRF   x62
0402E:  MOVFF  AEB,B61
04032:  MOVLW  02
04034:  MOVWF  x64
04036:  MOVLW  33
04038:  MOVWF  x63
0403A:  MOVLB  0
0403C:  CALL   039E
04040:  MOVFF  02,AFA
04044:  MOVFF  01,AF9
04048:  MOVLB  A
0404A:  MOVFF  01,AFB
0404E:  MOVLW  02
04050:  ADDWF  02,W
04052:  MOVWF  xFC
04054:  MOVLW  1C
04056:  ADDWF  01,W
04058:  MOVWF  01
0405A:  MOVLW  00
0405C:  ADDWFC xFC,W
0405E:  MOVWF  03
04060:  MOVF   01,W
04062:  ADDLW  70
04064:  MOVWF  FE9
04066:  MOVLW  02
04068:  ADDWFC 03,W
0406A:  MOVWF  FEA
0406C:  MOVFF  FEF,00
04070:  MOVFF  FEC,01
04074:  MOVFF  FEC,02
04078:  MOVFF  FEC,03
0407C:  MOVFF  03,B00
04080:  MOVFF  02,AFF
04084:  MOVFF  01,AFE
04088:  MOVFF  00,AFD
0408C:  MOVFF  FEA,B02
04090:  MOVFF  FE9,B01
04094:  MOVFF  AF7,B12
04098:  MOVFF  AF6,B11
0409C:  MOVFF  AF5,B10
040A0:  MOVFF  AF4,B0F
040A4:  MOVFF  03,B16
040A8:  MOVFF  02,B15
040AC:  MOVFF  01,B14
040B0:  MOVFF  00,B13
040B4:  MOVLB  0
040B6:  CALL   0950
040BA:  MOVFF  B02,FEA
040BE:  MOVFF  B01,FE9
040C2:  MOVFF  03,AF8
040C6:  MOVFF  02,AF7
040CA:  MOVFF  01,AF6
040CE:  MOVFF  00,AF5
040D2:  MOVLW  41
040D4:  MOVWF  FE9
040D6:  MOVFF  03,B06
040DA:  MOVFF  02,B05
040DE:  MOVFF  01,B04
040E2:  MOVFF  00,B03
040E6:  BRA    3BF4
040E8:  MOVLW  25
040EA:  MOVLB  B
040EC:  MOVWF  x60
040EE:  MOVLB  0
040F0:  CALL   04D6
.................... 				nokia_refresh(); 
040F4:  CALL   0528
....................  
.................... 				WriteFlashBlock(gBlockAddr, gBinBlock, BUFFER_BIN_BLOCK); 
040F8:  MOVFF  8E0,AF4
040FC:  MOVFF  8DF,AF3
04100:  MOVFF  8DE,AF2
04104:  MOVFF  8DD,AF1
04108:  MOVLW  04
0410A:  MOVLB  A
0410C:  MOVWF  xF6
0410E:  MOVLW  DD
04110:  MOVWF  xF5
04112:  MOVLW  04
04114:  MOVWF  xF8
04116:  CLRF   xF7
04118:  MOVLB  0
0411A:  BRA    3CBE
.................... 		} 
.................... 	} 
0411C:  MOVLB  A
0411E:  BRA    3E82
.................... 	 
.................... } 
04120:  MOVLB  0
04122:  GOTO   4E06 (RETURN)
....................  
.................... #ORG APPLICATION_START, APPLICATION_START + 0xff 
.................... void UserProgram() 
.................... { 
.................... 	nokia_clean_ddram(); 
*
05000:  CALL   0370
.................... 	nokia_gotoxy(3, 6); 
05004:  MOVLW  03
05006:  MOVLB  B
05008:  MOVWF  x5F
0500A:  MOVLW  06
0500C:  MOVWF  x60
0500E:  MOVLB  0
05010:  CALL   03C0
.................... 	printf(nokia_printchar, "BOOT LOADER"); 
05014:  MOVLB  B
05016:  CLRF   x67
05018:  MOVF   x67,W
0501A:  MOVLB  0
0501C:  CALL   02B0
05020:  MOVLB  B
05022:  INCF   x67,F
05024:  MOVWF  00
05026:  MOVWF  x60
05028:  MOVLB  0
0502A:  CALL   04D6
0502E:  MOVLW  0B
05030:  MOVLB  B
05032:  SUBWF  x67,W
05034:  BNZ   5018
.................... 	nokia_refresh(); 
05036:  MOVLB  0
05038:  CALL   0528
.................... 	delay_ms(2000); 
0503C:  MOVLW  08
0503E:  MOVLB  B
05040:  MOVWF  x67
05042:  MOVLW  FA
05044:  MOVWF  x60
05046:  MOVLB  0
05048:  CALL   0584
0504C:  MOVLB  B
0504E:  DECFSZ x67,F
05050:  BRA    5042
.................... 	while(1); 
05052:  BRA    5052
.................... } 
05054:  MOVLB  0
05056:  RETLW  00
....................  
.................... #ORG default 
.................... void main() 
.................... { 
*
04B38:  CLRF   FF8
04B3A:  BCF    FD0.7
04B3C:  CLRF   FEA
04B3E:  CLRF   FE9
04B40:  BCF    F7E.3
04B42:  MOVLW  0C
04B44:  MOVWF  FAF
04B46:  MOVLW  A6
04B48:  MOVWF  FAC
04B4A:  MOVLW  90
04B4C:  MOVWF  FAB
04B4E:  BCF    F7C.3
04B50:  MOVLW  0C
04B52:  MOVWF  F6F
04B54:  MOVLW  A6
04B56:  MOVWF  F6C
04B58:  MOVLW  90
04B5A:  MOVWF  F6B
04B5C:  MOVF   FC1,W
04B5E:  ANDLW  C0
04B60:  MOVWF  FC1
04B62:  MOVLW  07
04B64:  MOVWF  FB4
04B66:  CLRF   05
04B68:  CLRF   06
04B6A:  MOVLW  46
04B6C:  MOVLB  4
04B6E:  MOVWF  xA3
04B70:  MOVLW  41
04B72:  MOVWF  xA4
04B74:  MOVLW  54
04B76:  MOVWF  xA5
04B78:  MOVLW  3F
04B7A:  MOVWF  xA6
04B7C:  CLRF   xA7
04B7E:  CLRF   xA8
04B80:  MOVLW  46
04B82:  MOVWF  xA9
04B84:  MOVLW  41
04B86:  MOVWF  xAA
04B88:  MOVLW  54
04B8A:  MOVWF  xAB
04B8C:  MOVLW  31
04B8E:  MOVWF  xAC
04B90:  MOVLW  32
04B92:  MOVWF  xAD
04B94:  CLRF   xAE
04B96:  MOVLW  46
04B98:  MOVWF  xAF
04B9A:  MOVLW  41
04B9C:  MOVWF  xB0
04B9E:  MOVLW  54
04BA0:  MOVWF  xB1
04BA2:  MOVLW  31
04BA4:  MOVWF  xB2
04BA6:  MOVLW  36
04BA8:  MOVWF  xB3
04BAA:  CLRF   xB4
04BAC:  MOVLW  46
04BAE:  MOVWF  xB5
04BB0:  MOVLW  41
04BB2:  MOVWF  xB6
04BB4:  MOVLW  54
04BB6:  MOVWF  xB7
04BB8:  MOVLW  33
04BBA:  MOVWF  xB8
04BBC:  MOVLW  32
04BBE:  MOVWF  xB9
04BC0:  CLRF   xBA
04BC2:  MOVLW  FF
04BC4:  MOVWF  xBC
04BC6:  MOVLB  A
04BC8:  CLRF   xDB
04BCA:  CLRF   xDC
04BCC:  CLRF   xE5
04BCE:  CLRF   xE6
.................... 	long i; 
.................... 	int error; 
.................... 	char bSDReady; 
....................  
.................... 	BootloaderActive = 1; 
04BD0:  MOVLW  01
04BD2:  MOVWF  0A
.................... 	 
.................... 	memset(gFiles, 0, sizeof(FILE)); 
04BD4:  MOVLW  02
04BD6:  MOVWF  FEA
04BD8:  MOVLW  70
04BDA:  MOVWF  FE9
04BDC:  CLRF   xF1
04BDE:  MOVLW  02
04BE0:  MOVWF  xF3
04BE2:  MOVLW  33
04BE4:  MOVWF  xF2
04BE6:  MOVLB  0
04BE8:  CALL   05AC
.................... 	gFiles[0].wFileSize = 0; 
04BEC:  MOVLB  4
04BEE:  CLRF   x9A
04BF0:  CLRF   x99
04BF2:  CLRF   x98
04BF4:  CLRF   x97
.................... 	gFilename[0] = 0; 
04BF6:  CLRF   xBD
....................  
.................... #ifdef 4XCLOCK 
.................... 	OSCTUNE=0x40; 
.................... #endif 
....................  
.................... 	bSDReady = 0; 
04BF8:  MOVLB  A
04BFA:  CLRF   xEA
....................  
.................... 	setup_adc_ports(AN0|VSS_VDD); 
04BFC:  MOVF   FC1,W
04BFE:  ANDLW  C0
04C00:  IORLW  0E
04C02:  MOVWF  FC1
.................... 	setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
04C04:  MOVF   FC0,W
04C06:  ANDLW  C0
04C08:  IORLW  07
04C0A:  MOVWF  FC0
04C0C:  BSF    FC0.7
04C0E:  BSF    FC2.0
04C10:  BSF    FC2.7
04C12:  BSF    FC2.1
04C14:  BTFSC  FC2.1
04C16:  BRA    4C14
04C18:  BCF    FC2.7
.................... 	setup_psp(PSP_DISABLED); 
04C1A:  BCF    FB0.4
.................... 	//setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_4); 
.................... 	set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
04C1C:  MOVLW  93
04C1E:  MOVWF  F94
.................... 	SETUP_SPI(SPI_MASTER | SPI_CLK_DIV_4 | SPI_H_TO_L |SPI_XMIT_L_TO_H ); 
04C20:  BCF    FC6.5
04C22:  MOVLW  30
04C24:  MOVWF  FC6
04C26:  MOVLW  00
04C28:  MOVWF  FC7
....................  
.................... 	setup_spi2(FALSE); 
04C2A:  BCF    F63.5
04C2C:  MOVWF  F63
04C2E:  MOVWF  F64
.................... 	setup_wdt(WDT_OFF); 
04C30:  BCF    FD1.0
.................... 	setup_timer_0(RTCC_INTERNAL); 
04C32:  MOVLW  80
04C34:  MOVWF  FD5
.................... 	setup_timer_1(T1_DISABLED); 
04C36:  CLRF   FCD
.................... 	setup_timer_2(T2_DIV_BY_1,255,1); 
04C38:  MOVLW  00
04C3A:  IORLW  04
04C3C:  MOVWF  FCA
04C3E:  MOVLW  FF
04C40:  MOVWF  FCB
....................  
.................... 	setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
04C42:  MOVF   FB1,W
04C44:  ANDLW  48
04C46:  MOVWF  FB1
.................... 	//setup_timer_3(T3_INTERNAL|T3_DIV_BY_8); 
.................... 	//set_timer3(15535);	//200ms 
....................  
.................... 	setup_timer_4(T4_DISABLED,0,1); 
04C48:  MOVLW  00
04C4A:  MOVWF  F76
04C4C:  MOVLW  00
04C4E:  MOVWF  F77
.................... 	setup_comparator(NC_NC_NC_NC); 
04C50:  MOVLW  07
04C52:  MOVWF  FB4
04C54:  MOVF   F97,W
04C56:  MOVLW  06
04C58:  MOVWF  00
04C5A:  DECFSZ 00,F
04C5C:  BRA    4C5A
04C5E:  NOP   
04C60:  MOVF   FB4,W
04C62:  BCF    FA1.6
.................... 	setup_vref(FALSE); 
04C64:  CLRF   FB5
.................... //	enable_interrupts(INT_RDA); 
.................... 	RBPU = 0; 
04C66:  BCF    FF1.7
.................... //	enable_interrupts(INT_RB); 
.................... //   	enable_interrupts(INT_TIMER3); 
.................... //	enable_interrupts(GLOBAL); 
.................... 	setup_oscillator(False); 
04C68:  CLRF   F9B
04C6A:  CLRF   FD3
04C6C:  MOVF   FD3,W
....................  
....................  
.................... 	setup_ccp2(CCP_PWM); 
04C6E:  BCF    F8B.1
04C70:  MOVLW  0C
04C72:  MOVWF  FBA
04C74:  CLRF   F67
.................... 	setup_ccp3(CCP_PWM); 
04C76:  BCF    F98.0
04C78:  BCF    F8F.0
04C7A:  MOVWF  FB7
04C7C:  CLRF   F69
.................... //	setup_ccp4(CCP_PWM); 
....................  
.................... 	setup_comparator(NC_NC_NC_NC); 
04C7E:  MOVLW  07
04C80:  MOVWF  FB4
04C82:  MOVF   F97,W
04C84:  MOVLW  06
04C86:  MOVWF  00
04C88:  DECFSZ 00,F
04C8A:  BRA    4C88
04C8C:  NOP   
04C8E:  MOVF   FB4,W
04C90:  BCF    FA1.6
.................... 	setup_vref(FALSE); 
04C92:  CLRF   FB5
....................  
....................  
.................... 	output_high(PIN_E7); 
04C94:  BCF    F96.7
04C96:  BSF    F8D.7
.................... 	output_high(PIN_G0); 
04C98:  BCF    F98.0
04C9A:  BSF    F8F.0
.................... 	output_high(PIN_G3); 
04C9C:  BCF    F98.3
04C9E:  BSF    F8F.3
....................  
.................... 	set_pwm2_duty(100); 
04CA0:  MOVLW  64
04CA2:  MOVWF  FBB
.................... 	set_pwm3_duty(80); 
04CA4:  MOVLW  50
04CA6:  MOVWF  FB8
.................... //	set_pwm4_duty(80); 
....................  
.................... 	//Init Nokia 3310 LCD 
.................... 	nokia_init(); 
04CA8:  MOVLB  0
04CAA:  GOTO   05CA
....................  
.................... 	nokia_clean_ddram(); 
04CAE:  CALL   0370
.................... 	nokia_refresh(); 
04CB2:  CALL   0528
....................  
.................... 	i=0; 
04CB6:  MOVLB  A
04CB8:  CLRF   xE8
04CBA:  CLRF   xE7
.................... 	gPrevCard = 1; 
04CBC:  MOVLW  01
04CBE:  MOVWF  08
....................  
.................... 	hFile = 0xff; 
04CC0:  MOVLW  FF
04CC2:  MOVLB  4
04CC4:  MOVWF  xBC
.................... 	set_pwm2_duty(500); 
04CC6:  MOVLW  7D
04CC8:  MOVWF  FBB
04CCA:  MOVF   FBA,W
04CCC:  ANDLW  CF
04CCE:  MOVWF  FBA
....................  
....................  
.................... 	gActCard = input(CardInserted);  
04CD0:  BSF    F93.0
04CD2:  CLRF   07
04CD4:  BTFSC  F81.0
04CD6:  INCF   07,F
....................  
.................... 	if (gActCard == 0 )  // card inserted 
04CD8:  MOVF   07,F
04CDA:  BNZ   4D58
.................... 	{ 
.................... 		bSDReady = 0; 
04CDC:  MOVLB  A
04CDE:  CLRF   xEA
.................... 		error  = 1; 
04CE0:  MOVLW  01
04CE2:  MOVWF  xE9
....................  
.................... 		set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
04CE4:  MOVLW  93
04CE6:  MOVWF  F94
.................... 		SETUP_SPI(SPI_MASTER | SPI_CLK_DIV_4 | SPI_H_TO_L |SPI_XMIT_L_TO_H ); 
04CE8:  BCF    FC6.5
04CEA:  MOVLW  30
04CEC:  MOVWF  FC6
04CEE:  MOVLW  00
04CF0:  MOVWF  FC7
....................  
.................... 		TRACE0("\r\nSD card Inserted."); 
....................  
.................... 		delay_ms(50);  
04CF2:  MOVLW  32
04CF4:  MOVLB  B
04CF6:  MOVWF  x60
04CF8:  MOVLB  0
04CFA:  CALL   0584
.................... 		for(i=0; i<10&&error; i++) 
04CFE:  MOVLB  A
04D00:  CLRF   xE8
04D02:  CLRF   xE7
04D04:  MOVF   xE8,F
04D06:  BNZ   4D36
04D08:  MOVF   xE7,W
04D0A:  SUBLW  09
04D0C:  BNC   4D36
04D0E:  MOVF   xE9,F
04D10:  BZ    4D36
.................... 		{ 
.................... 			TRACE1("\r\nInit SD (%ld)...", i);  
.................... 			error = init_mmc(10); 
04D12:  MOVLW  0A
04D14:  MOVWF  xEB
04D16:  MOVLB  0
04D18:  GOTO   06F8
04D1C:  MOVFF  01,AE9
.................... 			delay_ms(50);  
04D20:  MOVLW  32
04D22:  MOVLB  B
04D24:  MOVWF  x60
04D26:  MOVLB  0
04D28:  CALL   0584
.................... 		}   
04D2C:  MOVLB  A
04D2E:  INCF   xE7,F
04D30:  BTFSC  FD8.2
04D32:  INCF   xE8,F
04D34:  BRA    4D04
....................  
.................... 		if(InitFAT() != MMC_NO_ERR) 
04D36:  MOVLB  0
04D38:  GOTO   09D0
04D3C:  MOVF   01,F
04D3E:  BZ    4D46
.................... 		{ 
.................... 			TRACE1("\r\n Failed to initFat, error code = 0x%02X.", gFATErrCode); 
.................... 			error = 1; 
04D40:  MOVLW  01
04D42:  MOVLB  A
04D44:  MOVWF  xE9
.................... 		} 
....................  
....................  
.................... 		if(!error) 
04D46:  MOVLB  A
04D48:  MOVF   xE9,F
04D4A:  BNZ   4D58
.................... 		{	 
.................... 			hFile = 0xFF; 
04D4C:  MOVLW  FF
04D4E:  MOVLB  4
04D50:  MOVWF  xBC
.................... 			bSDReady = 1; 
04D52:  MOVLW  01
04D54:  MOVLB  A
04D56:  MOVWF  xEA
.................... 		}				 
....................  
.................... 	} 
....................  
....................  
.................... 	if(bSDReady) 
04D58:  MOVLB  A
04D5A:  MOVF   xEA,F
04D5C:  BTFSC  FD8.2
04D5E:  BRA    4EA2
.................... 	{ 
.................... 		sprintf(gfilename, "GPSLOGSW.BIN"); 
04D60:  MOVLW  04
04D62:  MOVWF  xE6
04D64:  MOVLW  BD
04D66:  MOVWF  xE5
04D68:  CLRF   xEB
04D6A:  MOVF   xEB,W
04D6C:  MOVLB  0
04D6E:  CALL   02D0
04D72:  MOVLB  A
04D74:  INCF   xEB,F
04D76:  MOVWF  00
04D78:  MOVWF  xEC
04D7A:  MOVLB  0
04D7C:  GOTO   0D78
04D80:  MOVLW  0C
04D82:  MOVLB  A
04D84:  SUBWF  xEB,W
04D86:  BNZ   4D6A
.................... 		hFile = fopen(gfilename, 'r'); 
04D88:  MOVLW  04
04D8A:  MOVWF  xEC
04D8C:  MOVLW  BD
04D8E:  MOVWF  xEB
04D90:  MOVLW  72
04D92:  MOVWF  xED
04D94:  MOVLB  0
04D96:  GOTO   2D70
04D9A:  MOVFF  01,4BC
.................... 		if(hFile == 0) 
04D9E:  MOVLB  4
04DA0:  MOVF   xBC,F
04DA2:  BTFSS  FD8.2
04DA4:  BRA    4EA4
.................... 		{ 
.................... 			nokia_clean_ddram(); 
04DA6:  MOVLB  0
04DA8:  CALL   0370
.................... 			nokia_gotoxy(0, 2); 
04DAC:  MOVLB  B
04DAE:  CLRF   x5F
04DB0:  MOVLW  02
04DB2:  MOVWF  x60
04DB4:  MOVLB  0
04DB6:  CALL   03C0
.................... 			printf(nokia_printchar, "Found GPSLOGSW.BIN"); 
04DBA:  MOVLB  A
04DBC:  CLRF   xEB
04DBE:  MOVF   xEB,W
04DC0:  MOVLB  0
04DC2:  CALL   02F2
04DC6:  MOVLB  A
04DC8:  INCF   xEB,F
04DCA:  MOVWF  00
04DCC:  MOVFF  FE8,B60
04DD0:  MOVLB  0
04DD2:  CALL   04D6
04DD6:  MOVLW  12
04DD8:  MOVLB  A
04DDA:  SUBWF  xEB,W
04DDC:  BNZ   4DBE
.................... 			nokia_refresh(); 
04DDE:  MOVLB  0
04DE0:  CALL   0528
.................... 			delay_ms(2000); 
04DE4:  MOVLW  08
04DE6:  MOVLB  A
04DE8:  MOVWF  xEB
04DEA:  MOVLW  FA
04DEC:  MOVLB  B
04DEE:  MOVWF  x60
04DF0:  MOVLB  0
04DF2:  CALL   0584
04DF6:  MOVLB  A
04DF8:  DECFSZ xEB,F
04DFA:  BRA    4DEA
....................  
.................... 			LoadProgram(hFile); 
04DFC:  MOVFF  4BC,AEB
04E00:  MOVLB  0
04E02:  GOTO   3D5E
....................  
.................... 			fclose(hFile); 
04E06:  MOVFF  4BC,AEB
04E0A:  GOTO   45C2
.................... 			remove(gfilename); 
04E0E:  MOVLW  04
04E10:  MOVLB  A
04E12:  MOVWF  xEC
04E14:  MOVLW  BD
04E16:  MOVWF  xEB
04E18:  MOVLB  0
04E1A:  BRA    48B0
....................  
.................... 			nokia_clean_ddram(); 
04E1C:  CALL   0370
.................... 			nokia_gotoxy(0,0); 
04E20:  MOVLB  B
04E22:  CLRF   x5F
04E24:  CLRF   x60
04E26:  MOVLB  0
04E28:  CALL   03C0
.................... 			printf(nokia_printchar, "SW update completed."); 
04E2C:  MOVLB  A
04E2E:  CLRF   xEB
04E30:  MOVF   xEB,W
04E32:  MOVLB  0
04E34:  CALL   031A
04E38:  MOVLB  A
04E3A:  INCF   xEB,F
04E3C:  MOVWF  00
04E3E:  MOVFF  FE8,B60
04E42:  MOVLB  0
04E44:  CALL   04D6
04E48:  MOVLW  14
04E4A:  MOVLB  A
04E4C:  SUBWF  xEB,W
04E4E:  BNZ   4E30
.................... 			nokia_gotoxy(0,2); 
04E50:  MOVLB  B
04E52:  CLRF   x5F
04E54:  MOVLW  02
04E56:  MOVWF  x60
04E58:  MOVLB  0
04E5A:  CALL   03C0
.................... 			printf(nokia_printchar, "Please restart device."); 
04E5E:  MOVLB  A
04E60:  CLRF   xEB
04E62:  MOVF   xEB,W
04E64:  MOVLB  0
04E66:  CALL   0344
04E6A:  MOVLB  A
04E6C:  INCF   xEB,F
04E6E:  MOVWF  00
04E70:  MOVFF  FE8,B60
04E74:  MOVLB  0
04E76:  CALL   04D6
04E7A:  MOVLW  16
04E7C:  MOVLB  A
04E7E:  SUBWF  xEB,W
04E80:  BNZ   4E62
.................... 			nokia_refresh(); 
04E82:  MOVLB  0
04E84:  CALL   0528
.................... 			delay_ms(5000); 
04E88:  MOVLW  14
04E8A:  MOVLB  A
04E8C:  MOVWF  xEB
04E8E:  MOVLW  FA
04E90:  MOVLB  B
04E92:  MOVWF  x60
04E94:  MOVLB  0
04E96:  CALL   0584
04E9A:  MOVLB  A
04E9C:  DECFSZ xEB,F
04E9E:  BRA    4E8E
.................... 			while(1); 
04EA0:  BRA    4EA0
04EA2:  MOVLB  4
.................... 		} 
....................  
.................... 	} 
....................  
.................... 	//Call user application 
.................... 	//UserProgram(); 
.................... 	BootloaderActive = 0; 
04EA4:  CLRF   0A
.................... 	goto_address(APPLICATION_START); 
04EA6:  MOVLB  0
04EA8:  GOTO   5000
.................... } 
04EAC:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NODEBUG NOXINST STVREN NOWDT NOPROTECT RESERVED
   Word  2: F744   HS WDT128 FCMEN NOIESO PRIMARY RESERVED
   Word  3: F3F8   CCP2C1 RESERVED
