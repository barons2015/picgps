#ifndef SCP1000_H
#define SCP1000_H

#define SCP_SCL   PIN_D6
#define SCP_SDA   PIN_D5
#define SCP_DELAY 5

//Address
#define SCP1000_ADDRESS      0x22

//Registers
#define SCPREG_REVID   0x00
#define SCPREG_DATAWR   0x01   //Indirect register access data
#define SCPREG_ADDPTR   0x02   //Indirect register access pointer
#define SCPREG_OPERATION   0x03   //Operation register
#define SCPREG_OPSTATUS   0x04   //Operation status
#define SCPREG_RSTR      0x06   //ASIC software reset
#define SCPREG_STATUS   0x07   //ASIC top-level status
#define SCPREG_DATARD8   0x7F   //Pressure output data (MSB)
#define SCPREG_DATARD16   0x80   //Pressure output data (LSB)
#define SCPREG_TEMPOUT   0x81   //14bit temperature output data

void scp_start()
{
   output_float(SCP_SCL);
   output_float(SCP_SDA);
   delay_us(SCP_DELAY);
   output_low(SCP_SDA);
   delay_us(SCP_DELAY);
}

void scp_restart()
{
	output_float(SCP_SDA);
	output_low(SCP_SCL);
	delay_us(SCP_DELAY);
	output_float(SCP_SCL);
	delay_us(SCP_DELAY);
	output_low(SCP_SDA);
	delay_us(SCP_DELAY);
	output_float(SCP_SDA);
}

int scp_write(byte by)
{
   int i = 8;
   do
   {
      --i;
      output_low(SCP_SCL);
      delay_us(SCP_DELAY);
      
      if(bit_test(by, i))
         output_float(SCP_SDA);
      else
         output_low(SCP_SDA);
      delay_us(SCP_DELAY);
      
      output_float(SCP_SCL);
      delay_us(SCP_DELAY);
      delay_us(SCP_DELAY);      
   }while(i != 0);
   
   //read ack
   output_float(SCP_SDA);
   output_low(SCP_SCL);
   delay_us(SCP_DELAY);   
   output_float(SCP_SCL);
   delay_us(SCP_DELAY/2);
   i = input(SCP_SDA);
   delay_us(SCP_DELAY/2);
   
   return i;
   
}

int scp_read()
{
   int i;
   int data=0;
   output_float(SCP_SDA);
   for(i=0; i<8; i++)
   {
      data <<= 1;
      output_low(SCP_SCL);
      delay_us(SCP_DELAY);
      
      output_float(SCP_SCL);
      delay_us(SCP_DELAY/2);
      if(input(SCP_SDA))
         data |= 1;
      delay_us(SCP_DELAY/2);
   }
   
   //read ack
   output_float(SCP_SDA);
   output_low(SCP_SCL);
   delay_us(SCP_DELAY);   
   output_float(SCP_SCL);
   delay_us(SCP_DELAY/2);
   i = input(SCP_SDA);
   delay_us(SCP_DELAY/2);
   return data;
}

void scp_stop()
{
   output_low(SCP_SDA);
   output_low(SCP_SCL);
   delay_us(SCP_DELAY);
   output_float(SCP_SCL);
   output_low(SCP_SDA);
   delay_us(SCP_DELAY);
   output_float(SCP_SDA);
}

int   SCP1000_ReadID()
{
   int nREVID;
   
   scp_start();

   if(scp_write(SCP1000_ADDRESS))           // Send the address of the device
      ; //return 0xAA;   //NO ACK

   scp_write(SCPREG_REVID);
   
   scp_restart();
   scp_write(SCP1000_ADDRESS| 0x01);           // Send the address of the device
   
   nREVID = scp_read();      

   scp_stop();

   return nREVID;   
}

int16 SCP1000_ReadTemp()
{
   int16 nTemp;
   
   scp_start();

   if(scp_write(SCP1000_ADDRESS))           // Send the address of the device
      return 0xAA;   //No ACK

   scp_write(SCPREG_TEMPOUT);
   
   scp_start();
   scp_write(SCP1000_ADDRESS| 0x01);           // Send the address of the device
   
   nTemp = scp_read();     
   nTemp <<= 8;
   nTemp += scp_read();     

   scp_stop();

   return nTemp;   
}

int16 SCP1000_ReadPressure()
{
   int16 nPressure;
   
   scp_start();

   scp_write(SCP1000_ADDRESS);           // Send the address of the device

   scp_write(SCPREG_DATARD16);
   
   scp_start();
   scp_write(SCP1000_ADDRESS| 0x01);           // Send the address of the device
   
   nPressure = scp_read();      
   nPressure <<= 8;
   nPressure += scp_read();      

   scp_stop();

   return nPressure;   
}

#endif
